# Secci√≥n 14: Kubernetes

---

## Introducci√≥n

### [Kubernetes vs Docker Compose](https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/What-is-Kubernetes-vs-Docker-Compose-How-these-DevOps-tools-compare)

`Kubernetes y Docker Compose` **son marcos de orquestaci√≥n de contenedores.**

- `Docker Compose` ejecuta contenedores en un √∫nico equipo anfitri√≥n.
- `Kubernetes` ejecuta contenedores en varios ordenadores, virtuales o reales.

![01.png](assets/section-14/01.png)

`Entendiendo Docker Compose`, como se mencion√≥ anteriormente, Docker Compose es una tecnolog√≠a de orquestaci√≥n de
contenedores que est√° destinada a ejecutar una serie de contenedores en una sola m√°quina host. Los desarrolladores
crean un archivo Docker Compose que describe las im√°genes de contenedor y la configuraci√≥n con la que se compone el
Docker Compose. El nombre de este archivo es `compose.yml` o para versiones anteriores `docker-compose.yml`.

`Entendiendo Kubernetes`, como se ha mencionado anteriormente, Kubernetes es una tecnolog√≠a de orquestaci√≥n de
contenedores. Bajo Kubernetes, la l√≥gica de una aplicaci√≥n web se segmenta en contenedores. Los contenedores se
organizan en una abstracci√≥n llamada pod. Un pod puede tener uno o varios contenedores. La l√≥gica de un pod se expone
a la red a trav√©s de otra abstracci√≥n de Kubernetes denominada servicio. En resumen, la red conoce los servicios de
Kubernetes y un servicio conoce el pod o los pods que tienen su l√≥gica. Dentro de cada pod hay uno o varios
contenedores que realizan la l√≥gica del pod en cuesti√≥n (Ver figura de abajo).

Un servicio de Kubernetes expone la l√≥gica de los contenedores de un pod a la red.

![02.png](assets/section-14/02.png)

En `Kubernetes`, los contenedores, pods y servicios se alojan dentro de una colecci√≥n de uno o varios equipos, reales
o virtuales. En la jerga de `Kubernetes`, `un ordenador se denomina nodo`. `Kubernetes` se ejecuta en varios nodos.
La colecci√≥n de nodos se denomina `cl√∫ster de Kubernetes`.

Los pods y los contenedores asociados a un servicio se pueden alojar en varios equipos. Adem√°s, Kubernetes tiene
caracter√≠sticas de escalado y tolerancia a errores que hacen que Kubernetes pueda crear autom√°ticamente m√°s pods en
tiempo de ejecuci√≥n para satisfacer el aumento de la demanda sin p√©rdida de servicio. Adem√°s, si un pod falla,
Kubernetes lo repondr√° autom√°ticamente. Docker Compose admite reinicios autom√°ticos en caso de error, pero no est√°
dise√±ado para admitir el escalado autom√°tico.

Lo importante que hay que entender sobre la diferencia entre Docker Compose es que, mientras que en Docker Compose, un
contenedor y su servicio y red correspondientes se ejecutan en una sola m√°quina, en Kubernetes los contenedores se
organizan seg√∫n una abstracci√≥n llamada pod. Un pod puede ser utilizado por uno o varios servicios, y los pods asociados
a un solo servicio suelen estar distribuidos en varios equipos.

### [¬øQu√© es Kubernetes?](https://kubernetes.io/es/docs/concepts/overview/what-is-kubernetes/)

`Kubernetes (K8s)` es una plataforma de c√≥digo abierto para automatizar la implementaci√≥n, el escalado y la
administraci√≥n de aplicaciones en contenedores.

El despliegue de contenedores con `Kubernetes` pueden ayudarnos de mejor forma y m√°s estandarizada.

- `Revisi√≥n de salud (health check) del contenedor y re-deploy`, los contenedores pueden fallar y detenerse, se pueden
  caer y necesitan ser reemplazados.
- `Autoescalado (Autoscaling)`, necesitamos escalar nuestros servicios seg√∫n aumenta o disminuye el tr√°fico.
- `Balanceo de carga (Load Balancer)`, distribuir uniformemente el tr√°fico entrante o carga de trabajo entre los
  contenedores.

`Kubernetes` provee configuraci√≥n estandarizada, archivos de manifiesto `yml`, contenedores, n√∫meros de instancias,
servicios, puertos, recursos, etc.

- Se puede llevar a cualquier proveedor en la nube como `Amazon EKS`, `Microsoft Azure`, `Google Cloud`, etc.
- O bien, se puede configurar en m√°quinas remotas o data centers administrador por nosotros, por ejemplo `VPS`.

üì¢ **IMPORTANTE**

> `Kubernetes` no es un servicio en la nube, sino m√°s bien, es un software que podemos instalar y configurar en la nube
> ya sea en una m√°quina remota que administraremos nosotros (Ejm. EC2, alg√∫n otro VPS, etc), es decir, al igual que
> hicimos con `Docker` cuando usamos `Amazon EC2`, tambi√©n podemos hacer lo mismo con `Kubernetes`, instalar y
> configurarlo, de forma que sea auto-administrada por nosotros.
>
> Por lo tanto, `Kubernetes` no es un proveedor de servicio, es un `framework` que nos ayuda en el despliegue de
> contenedores de forma automatizada con **revisi√≥n de salud, re-deploy, auto-escalamiento, balanceo de carga.**
>
> Podemos usar `Kubernetes` en `Amazon`, `Azure`, `Google Cloud`, etc.

## Conceptos Arquitect√≥nicos detr√°s de Kubernetes

Un `cl√∫ster de Kubernetes` consta de un `control plane` y un conjunto de `m√°quinas de trabajo`, llamadas `nodos`, que
ejecutan aplicaciones en contenedores. Cada cl√∫ster necesita al menos un nodo de trabajo para ejecutar `pods`.

Los `nodos de trabajo` alojan los `pods` que componen la carga de trabajo de la aplicaci√≥n. El `control plane`
administra los `nodos de trabajo` y los `pods` del cl√∫ster. En entornos de producci√≥n, el `control plane` suele
ejecutarse en varios equipos y un cl√∫ster suele ejecutar varios nodos, lo que proporciona tolerancia a fallos y alta
disponibilidad.

Este documento describe los diversos componentes necesarios para un `cl√∫ster de Kubernetes` completo y funcional.

![04.png](assets/section-14/04.png)

### üß† Componentes del control plane

Los componentes del plano de control toman decisiones globales sobre el cl√∫ster (por ejemplo, el scheduling), adem√°s de
detectar y responder a eventos del cl√∫ster (por ejemplo, iniciar un nuevo pod cuando el campo de r√©plicas de una
implementaci√≥n no est√° satisfecho).

Los componentes del plano de control se pueden ejecutar en cualquier equipo del cl√∫ster. Sin embargo, para simplificar,
los scripts de configuraci√≥n suelen iniciar todos los componentes del plano de control en el mismo equipo y no ejecutan
contenedores de usuario en este.

### üß† Kube-apiserver

El `API Server` es un componente del plano de control de Kubernetes que expone la API de Kubernetes. El API server es
la interfaz del plano de control de Kubernetes.

La implementaci√≥n principal de un API Server de Kubernetes es `kube-apiserver`. `Kube-apiserver` est√° dise√±ado para
escalar horizontalmente; es decir, escala mediante la implementaci√≥n de m√°s instancias. Se pueden ejecutar varias
instancias de `kube-apiserver` y equilibrar el tr√°fico entre ellas.Almac√©n de valores clave consistente y de alta
disponibilidad que se utiliza como almac√©n de respaldo de Kubernetes para todos los datos del cl√∫ster.

### üß† Etcd

Almac√©n de valores clave consistente y de alta disponibilidad que se utiliza como almac√©n de respaldo de `Kubernetes`
para todos los datos del cl√∫ster.

Si su cl√∫ster de Kubernetes utiliza etcd como almac√©n de respaldo, aseg√∫rese de contar con un plan de respaldo para los
datos.

### üß† kube-scheduler

Es el componente del control plane encargado de asignar los `Pods` reci√©n creados (que a√∫n no est√°n asignados a ning√∫n
nodo) a un nodo disponible del cl√∫ster.

El scheduler eval√∫a varios factores como: uso de recursos, afinidad/anti-afinidad, restricciones de nodo, tolerancias y
m√°s, para decidir en qu√© nodo es m√°s adecuado ejecutar ese Pod.

### üß† kube-controller-manager

Es el componente que se encarga de ejecutar varios controladores (programas que vigilan el estado del cl√∫ster) en un
solo proceso.

Algunos de los controladores m√°s importantes son:

- Node Controller: monitorea el estado de los nodos.
- Replication Controller: garantiza que el n√∫mero deseado de r√©plicas de un Pod est√© siempre corriendo.
- Endpoints Controller: gestiona los objetos Endpoint para servicios.
- Service Account & Token Controllers: maneja cuentas de servicio y tokens de acceso.

En resumen, el `kube-controller-manager` se asegura de que el estado real del cl√∫ster coincida con el estado deseado
definido en las configuraciones de Kubernetes.

### üß† cloud-controller-manager

Es un componente del `control plane` que permite que `Kubernetes` interact√∫e con los proveedores de nube (como `AWS`,
`GCP`, `Azure`).

Se encarga de separar la l√≥gica espec√≠fica del proveedor de nube del resto del cl√∫ster. Algunas de sus funciones
incluyen:

- Gestionar nodos seg√∫n la infraestructura de nube (por ejemplo, eliminar nodos apagados).
- Asignar IPs externas a servicios.
- Crear balanceadores de carga (load balancers).

Solo es necesario si el cl√∫ster corre en un entorno de nube.

### üß† Componentes del Nodo (Node components)

Son los procesos que se ejecutan en cada `nodo del cl√∫ster` y se encargan de que los `Pods` funcionen correctamente.
Incluyen:

- `kubelet`: Agente que se comunica con el control plane, ejecuta los `Pods` en el nodo y reporta su estado.
- `kube-proxy`: Maneja la red en cada nodo, configurando reglas de red para permitir la comunicaci√≥n entre `Pods` y
  `Servicios`.
- `Container Runtime`: Software que ejecuta los contenedores (por ejemplo, `containerd`, `CRI-O` o `Docker`).

Estos componentes son esenciales para que cada nodo participe activamente en el `cl√∫ster de Kubernetes`.

### üß† kubelet

Un agente que se ejecuta en cada nodo del cl√∫ster. Garantiza que los contenedores se ejecuten en un pod.

`Kubelet` toma un conjunto de `PodSpecs` proporcionados mediante diversos mecanismos y garantiza que los contenedores
descritos en ellas se ejecuten correctamente. Kubelet no administra contenedores que no hayan sido creados por
Kubernetes.

### üß† Container runtime

Un componente fundamental que permite a `Kubernetes` ejecutar contenedores eficazmente. Se encarga de gestionar la
ejecuci√≥n y el ciclo de vida de los contenedores dentro del entorno de `Kubernetes`.

A continuaci√≥n se muestra el diagrama de la arquitectura de kubernetes mostrado en el curso.

![03.png](assets/section-14/03.png)

üìù **NOTA**

- `Minikube` es una herramienta que nos permite crear un cl√∫ster local de `Kubernetes` en nuestra m√°quina. Es ideal para
  desarrollo y pruebas, ya que simula un entorno de cl√∫ster real.


- `kubectl` (**abreviatura de Kubernetes control**) es la `herramienta de l√≠nea de comandos` para interactuar con un
  cl√∫ster de `Kubernetes`. Permite ejecutar comandos para desplegar aplicaciones, inspeccionar recursos y administrar el
  cl√∫ster. Funciona tanto con `minikube` en entornos locales como con cl√∫steres remotos en la nube (por ejemplo,
  en `Amazon EKS`, `Google GKE`, `Azure AKS`, etc.).

## Introducci√≥n a los objetos de Kubernetes

`Kubernetes` define y gestiona su infraestructura a trav√©s de una serie de objetos que representan el estado deseado
del sistema. Estos objetos son entidades persistentes del cl√∫ster y permiten declarar qu√© quieres que ocurra
(por ejemplo, cu√°ntas r√©plicas de una aplicaci√≥n deben estar ejecut√°ndose), y `Kubernetes` se encarga de hacerlo
realidad.

A continuaci√≥n se listan algunos de los objetos fundamentales en Kubernetes:

- üí° `Pod`: Unidad m√°s peque√±a de ejecuci√≥n. Representa una o m√°s contenedores que comparten almacenamiento, red y
  especificaciones sobre c√≥mo ejecutar los contenedores.


- üí° `Deployment`: Controlador que gestiona la creaci√≥n y actualizaci√≥n de r√©plicas de `Pods` de forma declarativa.
  Permite realizar escalamiento y actualizaciones sin tiempo de inactividad.


- üí° `Service`: Objeto que expone un conjunto de `Pods` como un √∫nico servicio de red. Garantiza acceso estable a los
  `Pods`, incluso cuando sus direcciones IP cambian.


- üí° `Namespace`: Mecanismo para agrupar y aislar recursos dentro de un mismo cl√∫ster. √ötil para organizar ambientes
  (dev, staging, prod) o equipos.


- üí° `Volume`: Abstracci√≥n para gestionar almacenamiento persistente que puede ser compartido entre contenedores de un
  mismo `Pod`.

## Pods en Kubernetes

Los `Pods` son la unidad m√°s peque√±a que se puede desplegar y administrar en `Kubernetes`. Representan una instancia en
ejecuci√≥n de una aplicaci√≥n dentro del cl√∫ster.

Un `Pod` encapsula uno o m√°s contenedores (por ejemplo, contenedores Docker), junto con recursos compartidos como:

- Direcci√≥n IP y puerto
- Almacenamiento (vol√∫menes)
- Configuraciones para la ejecuci√≥n de contenedores

Los contenedores dentro de un mismo `Pod`:

- Se ejecutan en el mismo nodo.
- Comparten la misma red, por lo tanto, pueden comunicarse entre s√≠ usando `localhost` y puertos expuestos.
- Pueden compartir almacenamiento, accediendo a los mismos vol√∫menes montados.
- Est√°n co-ubicados y co-programados, lo que significa que se despliegan y se terminan juntos como una unidad l√≥gica.

Por dise√±o, los contenedores dentro de un Pod est√°n estrechamente relacionados. Esto es √∫til en casos donde uno de los
contenedores complementa al otro, como un contenedor principal que sirve la aplicaci√≥n, y un contenedor sidecar que
recolecta logs o realiza tareas auxiliares.

> ‚ö†Ô∏è `Buenas pr√°cticas`: Aunque un `Pod` puede contener varios contenedores, lo m√°s habitual (y recomendable) es
> usar un solo contenedor por `Pod`. Esto simplifica la gesti√≥n, el escalamiento y el monitoreo de las aplicaciones.

### Comunicaci√≥n entre Pods

- Cada `Pod` tiene su propia IP √∫nica dentro del cl√∫ster.
- La comunicaci√≥n entre `Pods` se realiza a trav√©s de esta IP o mediante un Service, que act√∫a como punto de acceso
  estable incluso si los `Pods` cambian.

## Deployments en Kubernetes

Un `Deployment` es un objeto de `Kubernetes` que permite administrar el ciclo de vida de los `Pods` de forma
declarativa. Es uno de los controladores m√°s comunes, y se utiliza para definir c√≥mo crear, actualizar, escalar y
revertir instancias de una aplicaci√≥n en contenedores.

Con un `Deployment` puedes:

- Crear y mantener m√∫ltiples r√©plicas de un `Pod` en ejecuci√≥n.
- Realizar actualizaciones controladas (rolling updates) de versiones del contenedor sin tiempo de inactividad.
- Revertir a una versi√≥n anterior en caso de error.
- Escalar la aplicaci√≥n (aumentar o reducir la cantidad de Pods) f√°cilmente.

El `Deployment` act√∫a como un controlador de alto nivel que administra objetos m√°s bajos llamados ReplicaSets,
los cuales a su vez garantizan que el n√∫mero especificado de `Pods` est√© siempre corriendo.

Cuando defines un `Deployment` (mediante un manifiesto `YML`), indicas el estado deseado de la aplicaci√≥n (imagen del
contenedor, cantidad de r√©plicas, puertos, etc.). `Kubernetes` se encarga de alinear el estado actual del sistema con
ese estado deseado de forma autom√°tica y segura.

> ‚öôÔ∏è Las operaciones con `Deployments` suelen ejecutarse mediante `kubectl`, la herramienta de l√≠nea de comandos de
> Kubernetes disponible para Linux, macOS y Windows.

## Modos de creaci√≥n de objetos

Existen dos enfoques principales para crear objetos en Kubernetes:

- `Imperativo`: Se realiza directamente desde la l√≠nea de comandos (`kubectl`) especificando los par√°metros de manera
  expl√≠cita. Es √∫til para tareas r√°pidas, pero dif√≠cil de reproducir y versionar.

  Ejemplo:

  ````bash
  $ kubectl run mi-app --image=nginx --port=80
  ````

- `Declarativo`: Se basa en archivos de configuraci√≥n `YML` (tambi√©n llamados manifiestos), donde se describe el estado
  deseado del objeto. Es el enfoque recomendado para entornos productivos, ya que facilita el versionado, reutilizaci√≥n
  y control de cambios.

  Ejemplo:
  ````yml
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: mi-app
  spec:
    replicas: 2
    selector:
      matchLabels:
        app: mi-app
  ...
  ````
