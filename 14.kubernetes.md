# Secci칩n 14: Kubernetes

---

## Introducci칩n

### [Kubernetes vs Docker Compose](https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/What-is-Kubernetes-vs-Docker-Compose-How-these-DevOps-tools-compare)

`Kubernetes y Docker Compose` **son marcos de orquestaci칩n de contenedores.**

- `Docker Compose` ejecuta contenedores en un 칰nico equipo anfitri칩n.
- `Kubernetes` ejecuta contenedores en varios ordenadores, virtuales o reales.

![01.png](assets/section-14/01.png)

`Entendiendo Docker Compose`, como se mencion칩 anteriormente, Docker Compose es una tecnolog칤a de orquestaci칩n de
contenedores que est치 destinada a ejecutar una serie de contenedores en una sola m치quina host. Los desarrolladores
crean un archivo Docker Compose que describe las im치genes de contenedor y la configuraci칩n con la que se compone el
Docker Compose. El nombre de este archivo es `compose.yml` o para versiones anteriores `docker-compose.yml`.

`Entendiendo Kubernetes`, como se ha mencionado anteriormente, Kubernetes es una tecnolog칤a de orquestaci칩n de
contenedores. Bajo Kubernetes, la l칩gica de una aplicaci칩n web se segmenta en contenedores. Los contenedores se
organizan en una abstracci칩n llamada pod. Un pod puede tener uno o varios contenedores. La l칩gica de un pod se expone
a la red a trav칠s de otra abstracci칩n de Kubernetes denominada servicio. En resumen, la red conoce los servicios de
Kubernetes y un servicio conoce el pod o los pods que tienen su l칩gica. Dentro de cada pod hay uno o varios
contenedores que realizan la l칩gica del pod en cuesti칩n (Ver figura de abajo).

Un servicio de Kubernetes expone la l칩gica de los contenedores de un pod a la red.

![02.png](assets/section-14/02.png)

En `Kubernetes`, los contenedores, pods y servicios se alojan dentro de una colecci칩n de uno o varios equipos, reales
o virtuales. En la jerga de `Kubernetes`, `un ordenador se denomina nodo`. `Kubernetes` se ejecuta en varios nodos.
La colecci칩n de nodos se denomina `cl칰ster de Kubernetes`.

Los pods y los contenedores asociados a un servicio se pueden alojar en varios equipos. Adem치s, Kubernetes tiene
caracter칤sticas de escalado y tolerancia a errores que hacen que Kubernetes pueda crear autom치ticamente m치s pods en
tiempo de ejecuci칩n para satisfacer el aumento de la demanda sin p칠rdida de servicio. Adem치s, si un pod falla,
Kubernetes lo repondr치 autom치ticamente. Docker Compose admite reinicios autom치ticos en caso de error, pero no est치
dise침ado para admitir el escalado autom치tico.

Lo importante que hay que entender sobre la diferencia entre Docker Compose es que, mientras que en Docker Compose, un
contenedor y su servicio y red correspondientes se ejecutan en una sola m치quina, en Kubernetes los contenedores se
organizan seg칰n una abstracci칩n llamada pod. Un pod puede ser utilizado por uno o varios servicios, y los pods asociados
a un solo servicio suelen estar distribuidos en varios equipos.

### [쯈u칠 es Kubernetes?](https://kubernetes.io/es/docs/concepts/overview/what-is-kubernetes/)

`Kubernetes (K8s)` es una plataforma de c칩digo abierto para automatizar la implementaci칩n, el escalado y la
administraci칩n de aplicaciones en contenedores.

El despliegue de contenedores con `Kubernetes` pueden ayudarnos de mejor forma y m치s estandarizada.

- `Revisi칩n de salud (health check) del contenedor y re-deploy`, los contenedores pueden fallar y detenerse, se pueden
  caer y necesitan ser reemplazados.
- `Autoescalado (Autoscaling)`, necesitamos escalar nuestros servicios seg칰n aumenta o disminuye el tr치fico.
- `Balanceo de carga (Load Balancer)`, distribuir uniformemente el tr치fico entrante o carga de trabajo entre los
  contenedores.

`Kubernetes` provee configuraci칩n estandarizada, archivos de manifiesto `yml`, contenedores, n칰meros de instancias,
servicios, puertos, recursos, etc.

- Se puede llevar a cualquier proveedor en la nube como `Amazon EKS`, `Microsoft Azure`, `Google Cloud`, etc.
- O bien, se puede configurar en m치quinas remotas o data centers administrador por nosotros, por ejemplo `VPS`.

游닉 **IMPORTANTE**

> `Kubernetes` no es un servicio en la nube, sino m치s bien, es un software que podemos instalar y configurar en la nube
> ya sea en una m치quina remota que administraremos nosotros (Ejm. EC2, alg칰n otro VPS, etc), es decir, al igual que
> hicimos con `Docker` cuando usamos `Amazon EC2`, tambi칠n podemos hacer lo mismo con `Kubernetes`, instalar y
> configurarlo, de forma que sea auto-administrada por nosotros.
>
> Por lo tanto, `Kubernetes` no es un proveedor de servicio, es un `framework` que nos ayuda en el despliegue de
> contenedores de forma automatizada con **revisi칩n de salud, re-deploy, auto-escalamiento, balanceo de carga.**
>
> Podemos usar `Kubernetes` en `Amazon`, `Azure`, `Google Cloud`, etc.

## Conceptos Arquitect칩nicos detr치s de Kubernetes

Un `cl칰ster de Kubernetes` consta de un `control plane` y un conjunto de `m치quinas de trabajo`, llamadas `nodos`, que
ejecutan aplicaciones en contenedores. Cada cl칰ster necesita al menos un nodo de trabajo para ejecutar `pods`.

Los `nodos de trabajo` alojan los `pods` que componen la carga de trabajo de la aplicaci칩n. El `control plane`
administra los `nodos de trabajo` y los `pods` del cl칰ster. En entornos de producci칩n, el `control plane` suele
ejecutarse en varios equipos y un cl칰ster suele ejecutar varios nodos, lo que proporciona tolerancia a fallos y alta
disponibilidad.

Este documento describe los diversos componentes necesarios para un `cl칰ster de Kubernetes` completo y funcional.

![04.png](assets/section-14/04.png)

### 游 Componentes del control plane

Los componentes del plano de control toman decisiones globales sobre el cl칰ster (por ejemplo, el scheduling), adem치s de
detectar y responder a eventos del cl칰ster (por ejemplo, iniciar un nuevo pod cuando el campo de r칠plicas de una
implementaci칩n no est치 satisfecho).

Los componentes del plano de control se pueden ejecutar en cualquier equipo del cl칰ster. Sin embargo, para simplificar,
los scripts de configuraci칩n suelen iniciar todos los componentes del plano de control en el mismo equipo y no ejecutan
contenedores de usuario en este.

### 游 Kube-apiserver

El `API Server` es un componente del plano de control de Kubernetes que expone la API de Kubernetes. El API server es
la interfaz del plano de control de Kubernetes.

La implementaci칩n principal de un API Server de Kubernetes es `kube-apiserver`. `Kube-apiserver` est치 dise침ado para
escalar horizontalmente; es decir, escala mediante la implementaci칩n de m치s instancias. Se pueden ejecutar varias
instancias de `kube-apiserver` y equilibrar el tr치fico entre ellas.Almac칠n de valores clave consistente y de alta
disponibilidad que se utiliza como almac칠n de respaldo de Kubernetes para todos los datos del cl칰ster.

### 游 Etcd

Almac칠n de valores clave consistente y de alta disponibilidad que se utiliza como almac칠n de respaldo de `Kubernetes`
para todos los datos del cl칰ster.

Si su cl칰ster de Kubernetes utiliza etcd como almac칠n de respaldo, aseg칰rese de contar con un plan de respaldo para los
datos.

### 游 kube-scheduler

Es el componente del control plane encargado de asignar los `Pods` reci칠n creados (que a칰n no est치n asignados a ning칰n
nodo) a un nodo disponible del cl칰ster.

El scheduler eval칰a varios factores como: uso de recursos, afinidad/anti-afinidad, restricciones de nodo, tolerancias y
m치s, para decidir en qu칠 nodo es m치s adecuado ejecutar ese Pod.

### 游 kube-controller-manager

Es el componente que se encarga de ejecutar varios controladores (programas que vigilan el estado del cl칰ster) en un
solo proceso.

Algunos de los controladores m치s importantes son:

- Node Controller: monitorea el estado de los nodos.
- Replication Controller: garantiza que el n칰mero deseado de r칠plicas de un Pod est칠 siempre corriendo.
- Endpoints Controller: gestiona los objetos Endpoint para servicios.
- Service Account & Token Controllers: maneja cuentas de servicio y tokens de acceso.

En resumen, el `kube-controller-manager` se asegura de que el estado real del cl칰ster coincida con el estado deseado
definido en las configuraciones de Kubernetes.

### 游 cloud-controller-manager

Es un componente del `control plane` que permite que `Kubernetes` interact칰e con los proveedores de nube (como `AWS`,
`GCP`, `Azure`).

Se encarga de separar la l칩gica espec칤fica del proveedor de nube del resto del cl칰ster. Algunas de sus funciones
incluyen:

- Gestionar nodos seg칰n la infraestructura de nube (por ejemplo, eliminar nodos apagados).
- Asignar IPs externas a servicios.
- Crear balanceadores de carga (load balancers).

Solo es necesario si el cl칰ster corre en un entorno de nube.

### 游 Componentes del Nodo (Node components)

Son los procesos que se ejecutan en cada `nodo del cl칰ster` y se encargan de que los `Pods` funcionen correctamente.
Incluyen:

- `kubelet`: Agente que se comunica con el control plane, ejecuta los `Pods` en el nodo y reporta su estado.
- `kube-proxy`: Maneja la red en cada nodo, configurando reglas de red para permitir la comunicaci칩n entre `Pods` y
  `Servicios`.
- `Container Runtime`: Software que ejecuta los contenedores (por ejemplo, `containerd`, `CRI-O` o `Docker`).

Estos componentes son esenciales para que cada nodo participe activamente en el `cl칰ster de Kubernetes`.

### 游 kubelet

Un agente que se ejecuta en cada nodo del cl칰ster. Garantiza que los contenedores se ejecuten en un pod.

`Kubelet` toma un conjunto de `PodSpecs` proporcionados mediante diversos mecanismos y garantiza que los contenedores
descritos en ellas se ejecuten correctamente. Kubelet no administra contenedores que no hayan sido creados por
Kubernetes.

### 游 Container runtime

Un componente fundamental que permite a `Kubernetes` ejecutar contenedores eficazmente. Se encarga de gestionar la
ejecuci칩n y el ciclo de vida de los contenedores dentro del entorno de `Kubernetes`.

A continuaci칩n se muestra el diagrama de la arquitectura de kubernetes mostrado en el curso.

![03.png](assets/section-14/03.png)

游닇 **NOTA**

- `Minikube` es una herramienta que nos permite crear un cl칰ster local de `Kubernetes` en nuestra m치quina. Es ideal para
  desarrollo y pruebas, ya que simula un entorno de cl칰ster real.


- `kubectl` (**abreviatura de Kubernetes control**) es la `herramienta de l칤nea de comandos` para interactuar con un
  cl칰ster de `Kubernetes`. Permite ejecutar comandos para desplegar aplicaciones, inspeccionar recursos y administrar el
  cl칰ster. Funciona tanto con `minikube` en entornos locales como con cl칰steres remotos en la nube (por ejemplo,
  en `Amazon EKS`, `Google GKE`, `Azure AKS`, etc.).

## Introducci칩n a los objetos de Kubernetes

`Kubernetes` define y gestiona su infraestructura a trav칠s de una serie de objetos que representan el estado deseado
del sistema. Estos objetos son entidades persistentes del cl칰ster y permiten declarar qu칠 quieres que ocurra
(por ejemplo, cu치ntas r칠plicas de una aplicaci칩n deben estar ejecut치ndose), y `Kubernetes` se encarga de hacerlo
realidad.

A continuaci칩n se listan algunos de los objetos fundamentales en Kubernetes:

- 游눠 `Pod`: Unidad m치s peque침a de ejecuci칩n. Representa una o m치s contenedores que comparten almacenamiento, red y
  especificaciones sobre c칩mo ejecutar los contenedores.


- 游눠 `Deployment`: Controlador que gestiona la creaci칩n y actualizaci칩n de r칠plicas de `Pods` de forma declarativa.
  Permite realizar escalamiento y actualizaciones sin tiempo de inactividad.


- 游눠 `Service`: Objeto que expone un conjunto de `Pods` como un 칰nico servicio de red. Garantiza acceso estable a los
  `Pods`, incluso cuando sus direcciones IP cambian.


- 游눠 `Namespace`: Mecanismo para agrupar y aislar recursos dentro de un mismo cl칰ster. 칔til para organizar ambientes
  (dev, staging, prod) o equipos.


- 游눠 `Volume`: Abstracci칩n para gestionar almacenamiento persistente que puede ser compartido entre contenedores de un
  mismo `Pod`.

## Pods en Kubernetes

Los `Pods` son la unidad m치s peque침a que se puede desplegar y administrar en `Kubernetes`. Representan una instancia en
ejecuci칩n de una aplicaci칩n dentro del cl칰ster.

Un `Pod` encapsula uno o m치s contenedores (por ejemplo, contenedores Docker), junto con recursos compartidos como:

- Direcci칩n IP y puerto
- Almacenamiento (vol칰menes)
- Configuraciones para la ejecuci칩n de contenedores

Los contenedores dentro de un mismo `Pod`:

- Se ejecutan en el mismo nodo.
- Comparten la misma red, por lo tanto, pueden comunicarse entre s칤 usando `localhost` y puertos expuestos.
- Pueden compartir almacenamiento, accediendo a los mismos vol칰menes montados.
- Est치n co-ubicados y co-programados, lo que significa que se despliegan y se terminan juntos como una unidad l칩gica.

Por dise침o, los contenedores dentro de un Pod est치n estrechamente relacionados. Esto es 칰til en casos donde uno de los
contenedores complementa al otro, como un contenedor principal que sirve la aplicaci칩n, y un contenedor sidecar que
recolecta logs o realiza tareas auxiliares.

> 丘멆잺 `Buenas pr치cticas`: Aunque un `Pod` puede contener varios contenedores, lo m치s habitual (y recomendable) es
> usar un solo contenedor por `Pod`. Esto simplifica la gesti칩n, el escalamiento y el monitoreo de las aplicaciones.

### Comunicaci칩n entre Pods

- Cada `Pod` tiene su propia IP 칰nica dentro del cl칰ster.
- La comunicaci칩n entre `Pods` se realiza a trav칠s de esta IP o mediante un Service, que act칰a como punto de acceso
  estable incluso si los `Pods` cambian.

## Deployments en Kubernetes

Un `Deployment` es un objeto de `Kubernetes` que permite administrar el ciclo de vida de los `Pods` de forma
declarativa. Es uno de los controladores m치s comunes, y se utiliza para definir c칩mo crear, actualizar, escalar y
revertir instancias de una aplicaci칩n en contenedores.

Con un `Deployment` puedes:

- Crear y mantener m칰ltiples r칠plicas de un `Pod` en ejecuci칩n.
- Realizar actualizaciones controladas (rolling updates) de versiones del contenedor sin tiempo de inactividad.
- Revertir a una versi칩n anterior en caso de error.
- Escalar la aplicaci칩n (aumentar o reducir la cantidad de Pods) f치cilmente.

El `Deployment` act칰a como un controlador de alto nivel que administra objetos m치s bajos llamados ReplicaSets,
los cuales a su vez garantizan que el n칰mero especificado de `Pods` est칠 siempre corriendo.

Cuando defines un `Deployment` (mediante un manifiesto `YML`), indicas el estado deseado de la aplicaci칩n (imagen del
contenedor, cantidad de r칠plicas, puertos, etc.). `Kubernetes` se encarga de alinear el estado actual del sistema con
ese estado deseado de forma autom치tica y segura.

> 丘뙖잺 Las operaciones con `Deployments` suelen ejecutarse mediante `kubectl`, la herramienta de l칤nea de comandos de
> Kubernetes disponible para Linux, macOS y Windows.

## Modos de creaci칩n de objetos

Existen dos enfoques principales para crear objetos en Kubernetes:

- `Imperativo`: Se realiza directamente desde la l칤nea de comandos (`kubectl`) especificando los par치metros de manera
  expl칤cita. Es 칰til para tareas r치pidas, pero dif칤cil de reproducir y versionar.

  Ejemplo:

  ````bash
  $ kubectl run mi-app --image=nginx --port=80
  ````

- `Declarativo`: Se basa en archivos de configuraci칩n `YML` (tambi칠n llamados manifiestos), donde se describe el estado
  deseado del objeto. Es el enfoque recomendado para entornos productivos, ya que facilita el versionado, reutilizaci칩n
  y control de cambios.

  Ejemplo:
  ````yml
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: mi-app
  spec:
    replicas: 2
    selector:
      matchLabels:
        app: mi-app
  ...
  ````

## Instalando Herramientas

### [Kubectl](https://kubernetes.io/docs/tasks/tools/#kubectl)

La herramienta de l칤nea de comandos de `Kubernetes`, `kubectl`, permite ejecutar comandos en cl칰steres de `Kubernetes`.
Puede usar `kubectl` para implementar aplicaciones, inspeccionar y administrar recursos del cl칰ster y consultar
registros.

`kubectl` se puede instalar en diversas plataformas Linux, macOS y Windows. Para ver las distintas formas de instalar
`kubectl` en nuestra m치quina de windows podemos visitar el siguiente enlace
[Install and Set Up kubectl on Windows](https://kubernetes.io/docs/tasks/tools/install-kubectl-windows/).

En nuestro caso elegimos la opci칩n de instalar `kubectl` mediante el administrador de paquetes
[Chocolatey](https://community.chocolatey.org/). Para eso podemos visitar el siguiente enlace
[Install on Windows using Chocolatey, Scoop, or winget](https://kubernetes.io/docs/tasks/tools/install-kubectl-windows/#install-nonstandard-package-tools)
o, si no, ir directamente a la p치gina de [Chocolatey](https://community.chocolatey.org/).

Pero para resumir lo que haremos ser치:

- Abrir el `PowerShell` de windows en modo administrador y ejecutar el siguiente comando para instalar el administrador
  de paquetes chocolatey.
  ````bash
  $ Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
  ````
- Una vez que finalice la instalaci칩n, comprobamos que se efectu칩 correctamente.
  ````bash
  $ choco --version
  2.4.3
  ````
- Ahora ya podemos instalar `kubectl`, para eso ejecutamos el comando de abajo (en el proceso nos pedir치 que si queremos
  ejecutar un script, solo le decimos que s칤 con `Y`).
  ````bash
  $ choco install kubernetes-cli
  ````

- Finalizada la instalaci칩n de `kubectl`, comprobamos que se efectu칩 correctamente.
  ````bash
  $ kubectl version --client
  Client Version: v1.33.2
  Kustomize Version: v5.6.0
  ````

Luego de la instalaci칩n haremos dos cosas:

- Verificar que el directorio `.kube` exista en la siguiente ruta: `C:\Users\magadiflo\.kube`.
- Si no existe, crearlo manualmente o con `mkdir .kube`.
- Dentro del directorio `.kube` creamos el archivo `config` sin extensi칩n usando el siguiente comando:
  ````bash
  $ touch config
  ````

### [Minikube](https://kubernetes.io/docs/tasks/tools/#minikube)

`Minikube` es `Kubernetes local`, enfocado en facilitar el aprendizaje y desarrollo para `Kubernetes`.

Solo necesitas un contenedor `Docker` (o similarmente compatible) o un entorno de m치quina virtual, y `Kubernetes` est치
a un solo comando: `minikube start`.

[Pasos para instalar minikube:](https://minikube.sigs.k8s.io/docs/start/?arch=%2Fwindows%2Fx86-64%2Fstable%2F.exe+download)

- Descargamos e instalamos la
  [칰ltima versi칩n](https://storage.googleapis.com/minikube/releases/latest/minikube-installer.exe) del instalador.

Luego de la instalaci칩n:

- Volvemos a abrir la terminal pero esta vez con `acceso de administrador` y ejecutamos:
  ````bash
  $ minikube start --driver=hyperv
  ````
    - `minikube start`, inicia un cl칰ster de `Kubernetes local`. Este cl칰ster consiste en un solo nodo que act칰a como
      control plane (maestro y trabajador al mismo tiempo). Ideal para desarrollo, pruebas y aprendizaje.
    - `--driver=hyperv`, especifica que el cl칰ster se debe ejecutar dentro de una m치quina virtual gestionada por
      `Hyper-V`, el hipervisor nativo de Windows. `Minikube` soporta m칰ltiples drivers como `docker`, `virtualbox`,
      `hyperv`, etc.


- Luego de iniciar minikube con el driver `hyperv`, vemos que la ejecuci칩n se efect칰a correctamente:
  ````bash
  $ minikube start --driver=hyperv
  * minikube v1.36.0 on Microsoft Windows 11 Pro 10.0.26100.4349 Build 26100.4349
  * Using the hyperv driver based on user configuration
  * Starting "minikube" primary control-plane node in "minikube" cluster
  * Creating hyperv VM (CPUs=2, Memory=6000MB, Disk=20000MB) ...
  ! Image was not built for the current minikube version. To resolve this you can delete and recreate your minikube cluster using the latest images. Expected minikube version: v1.35.0 -> Actual minikube version: v1.36.0
  ! Failing to connect to https://registry.k8s.io/ from inside the minikube VM
  * To pull new external images, you may need to configure a proxy: https://minikube.sigs.k8s.io/docs/reference/networking/proxy/
  * Preparing Kubernetes v1.33.1 on Docker 28.0.4 ...
    - Generating certificates and keys ...
    - Booting up control plane ...
    - Configuring RBAC rules ...
  * Configuring bridge CNI (Container Networking Interface) ...
  * Verifying Kubernetes components...
    - Using image gcr.io/k8s-minikube/storage-provisioner:v5
  * Enabled addons: storage-provisioner, default-storageclass
  * Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default
  ````

- Procedemos a verificar el `status` de `minikube`.
  ````bash
  $ minikube status
  minikube
  type: Control Plane
  host: Running
  kubelet: Running
  apiserver: Running
  kubeconfig: Configured
  ````

En el apartado de creaci칩n de `kubectl` creamos el archivo `config` en la siguiente ruta
`C:\Users\magadiflo\.kube\config`. Si ahora revisamos dicho archivo, veremos que se habr치 poblado con las
configuraciones de cl칰ster de `minikube` para que `kubectl` se pueda comunicar con 칠l.

````yml
apiVersion: v1
clusters:
  - cluster:
      certificate-authority: C:\Users\magadiflo\.minikube\ca.crt
      extensions:
        - extension:
            last-update: Wed, 25 Jun 2025 23:32:37 -05
            provider: minikube.sigs.k8s.io
            version: v1.36.0
          name: cluster_info
      server: https://172.25.56.162:8443
    name: minikube
contexts:
  - context:
      cluster: minikube
      extensions:
        - extension:
            last-update: Wed, 25 Jun 2025 23:32:37 -05
            provider: minikube.sigs.k8s.io
            version: v1.36.0
          name: context_info
      namespace: default
      user: minikube
    name: minikube
current-context: minikube
kind: Config
preferences: { }
users:
  - name: minikube
    user:
      client-certificate: C:\Users\magadiflo\.minikube\profiles\minikube\client.crt
      client-key: C:\Users\magadiflo\.minikube\profiles\minikube\client.key
````

## Creando deployment MySQL - Forma Imperativa

Antes de crear el deployment con `MySQL` debemos asegurarnos de levantar `minikube`, as칤 que ejecutamos el siguiente
comando usando la l칤nea de comandos en `modo administrador`:

````bash
$ minikube start --driver=hyperv
* minikube v1.36.0 on Microsoft Windows 11 Pro 10.0.26100.4349 Build 26100.4349
* Using the hyperv driver based on existing profile
* Starting "minikube" primary control-plane node in "minikube" cluster
* Restarting existing hyperv VM for "minikube" ...
! Image was not built for the current minikube version. To resolve this you can delete and recreate your minikube cluster using the latest images. Expected minikube version: v1.35.0 -> Actual minikube version: v1.36.0
! Failing to connect to https://registry.k8s.io/ from inside the minikube VM
* To pull new external images, you may need to configure a proxy: https://minikube.sigs.k8s.io/docs/reference/networking/proxy/
* Preparing Kubernetes v1.33.1 on Docker 28.0.4 ...
* Configuring bridge CNI (Container Networking Interface) ...
* Verifying Kubernetes components...
  - Using image gcr.io/k8s-minikube/storage-provisioner:v5
* Enabled addons: storage-provisioner, default-storageclass
* Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default
````

**NOTA**
> Si al ejecutar el `minikube start` nos sale el siguiente mensaje:  `Unable to resolve the current
> Docker CLI context "default": context "default" does not exist`, podemos detener el servicio con `minikube stop`
> y luego ejecutar el siguiente comando: `docker context use default`. Ahora s칤 volvemos a iniciar minikube y ya no
> deber칤amos ver ese mensaje.

Verificamos que se est칠n ejecutando todos los servicios:

````bash
$ minikube status
minikube
type: Control Plane
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured
````

Ahora s칤, iniciamos con la creaci칩n del `deployment` para `MySQL`. Recordemos que un deployment tendr치 un pod y un pod
tendr치 uno o muchos contenedores (en nuestro caso idealmente solo uno). El contenedor que crearemos requerir치 una
imagen.

La imagen en kubernetes siempre se descarga de `docker hub`. Ahora, con la `forma imperativa`
`no podemos mandar variables de entorno (ambiente)`, que es lo que en este caso est치 esperando la imagen de `MySQL`
como el asignar un nombre a la base de datos, el username, el password, etc., por lo que al crear el deployment de
manera imperativa esperaremos obtener errores.

````bash
$ kubectl create deployment d-mysql --image=mysql:8.0.41-debian --port=3306
deployment.apps/d-mysql created
````

### 游늶 쯈u칠 hace este comando?

Este comando crea un `Deployment` en `Kubernetes` llamado `d-mysql` que:

1. Despliega un `Pod` con un `contenedor` basado en la imagen oficial de `MySQL 8.0.41` (versi칩n Debian).
2. El contenedor usar치 internamente el puerto `3306` (por defecto en MySQL). Este puerto solo est치 disponible dentro
   del Pod y no es accesible desde fuera del cl칰ster a menos que se cree un Service.

**Resumen**

- `create deployment`, indica que se crear치 un recurso del tipo `Deployment`, que gestiona r칠plicas y actualizaciones
  de `Pods`.
- `d-mysql`, es el nombre asignado al `Deployment`, y por defecto, el nombre de los `Pods` creados por este comenzar치
  con ese nombre seguido de un identificador aleatorio.
- `--image=mysql:8.0.41-debian`, imagen de Docker que se usar치 para el contenedor. En este caso, MySQL 8 basado en
  Debian que bajada de `Docker Hub`.
- `--port=3306`, indica que el contenedor escuchar치 internamente en el puerto `3306`, que es el puerto por defecto de
  MySQL. Sin embargo, este par치metro `no expone el puerto fuera del Pod`, ni crea un Service. Para permitir el acceso
  desde otros Pods o desde fuera del cl칰ster, es necesario crear un Service por separado.

### 游늷 Nota importante

Este comando:

- `No crea un Service`, as칤 que el contenedor `no es accesible desde fuera del cl칰ster` todav칤a.
- El `comando imperativo` no permite asignar variables de entorno como `MYSQL_ROOT_PASSWORD`, por lo que `MySQL` no
  iniciar치 correctamente. Para definir variables de ambiente es necesario usar la `forma declarativa`, mediante un
  archivo `YAML`. Por eso pueden aparecer errores al iniciar el contenedor.

Si listamos los deployments veremos que el deployment que acabamos de construir `d-mysql` tiene el valor
`READY: 0/1`. Eso significa que no est치 listo, ya que el contenedor de `MySQL` espera recibir variables de ambiente y
no le hemos pasado, por eso `no est치 READY`.

````bash
$ kubectl get deployments
NAME      READY   UP-TO-DATE   AVAILABLE   AGE
d-mysql   0/1     1            0           47s
````

Listamos los pods y vemos que estamos obteniendo lo mismo, es decir el status del pod est치 en `CrashLoopBackOff`, como
que ocurri칩 un error y es precisamente por lo de las variables de entorno que el contenedor de mysql espera recibir,
pero que no le hemos pasado.

````bash
$ kubectl get pods
NAME                       READY   STATUS             RESTARTS       AGE
d-mysql-7cbc75f4bd-mvgcf   0/1     CrashLoopBackOff   9 (3m2s ago)   24m
````

Podemos describir el pod para ver qu칠 ocurri칩.

````bash
$ kubectl describe pods d-mysql-7cbc75f4bd-mvgcf
Name:             d-mysql-7cbc75f4bd-mvgcf
Namespace:        default
Priority:         0
Service Account:  default
Node:             minikube/172.25.48.212
Start Time:       Wed, 25 Jun 2025 23:55:50 -0500
Labels:           app=d-mysql
                  pod-template-hash=7cbc75f4bd
Annotations:      <none>
Status:           Running
IP:               10.244.0.5
IPs:
  IP:           10.244.0.5
Controlled By:  ReplicaSet/d-mysql-7cbc75f4bd
Containers:
  mysql:
    Container ID:   docker://ab9887847eca5d7bafa2487ae6b2b21f72b30d0e8bcfbbabea7469bfd77a38fc
    Image:          mysql:8.0.41-debian
    Image ID:       docker-pullable://mysql@sha256:b2252987e0ecdb820e96928948ac3bca1adcd2b4a2a2c7b0d7ea78f77a9dc6ac
    Port:           3306/TCP
    Host Port:      0/TCP
    State:          Waiting
      Reason:       CrashLoopBackOff
    Last State:     Terminated
      Reason:       Error
      Exit Code:    1
      Started:      Thu, 26 Jun 2025 00:22:49 -0500
      Finished:     Thu, 26 Jun 2025 00:22:49 -0500
    Ready:          False
    Restart Count:  10
    Environment:    <none>
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-g6wd7 (ro)
Conditions:
  Type                        Status
  PodReadyToStartContainers   True
  Initialized                 True
  Ready                       False
  ContainersReady             False
  PodScheduled                True
Volumes:
  kube-api-access-g6wd7:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    Optional:                false
    DownwardAPI:             true
QoS Class:                   BestEffort
Node-Selectors:              <none>
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type     Reason     Age                   From               Message
  ----     ------     ----                  ----               -------
  Normal   Scheduled  29m                   default-scheduler  Successfully assigned default/d-mysql-7cbc75f4bd-mvgcf to minikube
  Normal   Pulling    29m                   kubelet            Pulling image "mysql:8.0.41-debian"
  Normal   Pulled     29m                   kubelet            Successfully pulled image "mysql:8.0.41-debian" in 34.872s (34.872s including waiting). Image size: 609852301 bytes.
  Normal   Created    13m (x9 over 29m)     kubelet            Created container: mysql
  Normal   Started    13m (x9 over 29m)     kubelet            Started container mysql
  Warning  BackOff    4m6s (x119 over 29m)  kubelet            Back-off restarting failed container mysql in pod d-mysql-7cbc75f4bd-mvgcf_default(1ca29ba5-12eb-4013-bfc0-a5e4707240aa)
  Normal   Pulled     2m54s (x10 over 29m)  kubelet            Container image "mysql:8.0.41-debian" already present on machine
````

Otra forma de ver en detalle el error que ocurri칩 es con el comando `kubectl logs`:

````bash
$ kubectl logs d-mysql-7cbc75f4bd-mvgcf
2025-06-26 05:22:49+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.41-1debian12 started.
2025-06-26 05:22:49+00:00 [Note] [Entrypoint]: Switching to dedicated user 'mysql'
2025-06-26 05:22:49+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.41-1debian12 started.
2025-06-26 05:22:49+00:00 [ERROR] [Entrypoint]: Database is uninitialized and password option is not specified
    You need to specify one of the following as an environment variable:
    - MYSQL_ROOT_PASSWORD
    - MYSQL_ALLOW_EMPTY_PASSWORD
    - MYSQL_RANDOM_ROOT_PASSWORD
````

## Creando deployment MySQL - Forma Declarativa

Lo primero que haremos ser치 eliminar el `deployment` creado en el apartado anterior.

````bash
$ kubectl delete deployment d-mysql
deployment.apps "d-mysql" deleted
````

La idea en este apartado es que a partir de la forma `imperativa`, es decir, mediante la l칤nea de comandos
podamos crear el `deployment` en forma `declarativa` generando la configuraci칩n en un archivo `yml`.

Para organizar mejor nuestros archivos, vamos a crear un directorio en la ra칤z de este proyecto llamado `/kubernetes`
y dentro de 칠l del directorio `/deployments` donde iremos colocando todos los archivos relacionados a 칠l.

Ejecutamos el siguiente comando para generar el archivo `YAML` del `Deployment` de `MySQL`:

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-14)
$ kubectl create deployment d-mysql --image=mysql:8.0.41-debian --port=3306 --dry-run=client -o yaml > .\kubernetes\deployments\deployment-mysql.yml
````

**DONDE**

- `kubectl create deployment d-mysql --image=mysql:8.0.41-debian --port=3306`, crea un `Deployment` llamado `d-mysql`
  de forma imperativa, especificando la imagen de MySQL versi칩n `8.0.41-debian` y el puerto `3306`.
- `--dry-run=client`, simula la creaci칩n del recurso y muestra la configuraci칩n resultante, pero sin enviarla al
  cl칰ster. 칔til para verificar o generar archivos de configuraci칩n. En nuestro caso nos permitir치 colocar la
  configuraci칩n resultante en un archivo `yml`.
- `-o yaml`, define que la salida se muestre en formato `YAML`.
- `deployment-mysql.yml`, le damos un nombre al archivo de configuraci칩n del deployment de mysql.
- `> ./kubernetes/deployments/deployment-mysql.yml`, redirige la salida del comando al archivo `deployment-mysql.yml`
  dentro de la carpeta `kubernetes/deployments`.

Como salida podemos observar en el directorio `./kubernetes/deployments` el archivo `deployment-mysql.yml`
con la siguiente configuraci칩n por defecto (algunas configuraciones no lo vamos a necesitar):

````yml
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: d-mysql
  name: d-mysql
spec:
  replicas: 1
  selector:
    matchLabels:
      app: d-mysql
  strategy: { }
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: d-mysql
    spec:
      containers:
        - image: mysql:8.0.41-debian
          name: mysql
          ports:
            - containerPort: 3306
          resources: { }
status: { }
````

Limpiamos el archivo yml anterior y dejamos solo las configuraciones importantes agregando, por supuesto, las variables
de entorno, que fueron el motivo por le cu치l creamos este archivo.

````yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: d-mysql
spec:
  replicas: 1
  selector:
    matchLabels:
      app: d-mysql
  template:
    metadata:
      labels:
        app: d-mysql
    spec:
      containers:
        - image: mysql:8.0.41-debian
          name: c-mysql
          ports:
            - containerPort: 3306
          env:
            - name: MYSQL_ROOT_PASSWORD
              value: magadiflo
            - name: MYSQL_DATABASE
              value: db_user_service
            - name: MYSQL_USER
              value: admin
            - name: MYSQL_PASSWORD
              value: magadiflo
````

**NOTA**
> En mi caso, le cambi칠 el nombre del contenedor a `c-mysql`. Cuando generamos el archivo desde la l칤nea de comandos,
> nos cre칩 el nombre del contendor `mysql`, pero en mi caso lo renombr칠 a `c-mysql` para tenerlo similar a c칩mo lo
> venimos trabajando en el `docker compose`.

Ahora que ya tenemos el archivo del `deployment` con las variables de entorno agregadas, creamos el deployment pero
esta vez usando el comando `apply`, ya que usaremos un archivo `yml`. Es decir, cuando usemos un archivo `yml` la
instrucci칩n ser치 `apply` y no `create`.

````bash
$ kubectl apply -f .\kubernetes\deployments\deployment-mysql.yml
deployment.apps/d-mysql created
````

Ahora, debemos verificar que se ha creado el `deployment` llamado `d-mysql` y est치 en `READY 1/1`.

````bash
$ kubectl get deployments
NAME      READY   UP-TO-DATE   AVAILABLE   AGE
d-mysql   1/1     1            1           60s
````

Lo mismo debe ocurrir si listamos los pods.

````bash
$ kubectl get pods
NAME                       READY   STATUS    RESTARTS   AGE
d-mysql-7b947869d5-d77d4   1/1     Running   0          2m6s
````

Describimos el pod y vemos que todo est치 ok.

````bash
$ kubectl describe pods d-mysql-7b947869d5-d77d4
Name:             d-mysql-7b947869d5-d77d4
Namespace:        default
Priority:         0
Service Account:  default
Node:             minikube/172.25.48.212
Start Time:       Fri, 27 Jun 2025 00:18:25 -0500
Labels:           app=d-mysql
                  pod-template-hash=7b947869d5
Annotations:      <none>
Status:           Running
IP:               10.244.0.9
IPs:
  IP:           10.244.0.9
Controlled By:  ReplicaSet/d-mysql-7b947869d5
Containers:
  c-mysql:
    Container ID:   docker://ddd4ed7ac3ae8618818f6aefbb0852f1ed7a30913f0dbcd9a6c4a281d1d5fa63
    Image:          mysql:8.0.41-debian
    Image ID:       docker-pullable://mysql@sha256:b2252987e0ecdb820e96928948ac3bca1adcd2b4a2a2c7b0d7ea78f77a9dc6ac
    Port:           3306/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Fri, 27 Jun 2025 00:18:25 -0500
    Ready:          True
    Restart Count:  0
    Environment:
      MYSQL_ROOT_PASSWORD:  magadiflo
      MYSQL_DATABASE:       db_user_service
      MYSQL_USER:           admin
      MYSQL_PASSWORD:       magadiflo
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-shnpg (ro)
Conditions:
  Type                        Status
  PodReadyToStartContainers   True
  Initialized                 True
  Ready                       True
  ContainersReady             True
  PodScheduled                True
Volumes:
  kube-api-access-shnpg:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    Optional:                false
    DownwardAPI:             true
QoS Class:                   BestEffort
Node-Selectors:              <none>
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age    From               Message
  ----    ------     ----   ----               -------
  Normal  Scheduled  2m58s  default-scheduler  Successfully assigned default/d-mysql-7b947869d5-d77d4 to minikube
  Normal  Pulled     2m58s  kubelet            Container image "mysql:8.0.41-debian" already present on machine
  Normal  Created    2m58s  kubelet            Created container: c-mysql
  Normal  Started    2m58s  kubelet            Started container c-mysql
````

Si verificamos el log del pod `d-mysql-7b947869d5-d77d4` tambi칠n observaremos que la ejecuci칩n es exitosa.

````bash
$ kubectl logs d-mysql-7b947869d5-d77d4
2025-06-27 05:18:25+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.41-1debian12 started.
2025-06-27 05:18:25+00:00 [Note] [Entrypoint]: Switching to dedicated user 'mysql'
2025-06-27 05:18:25+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.41-1debian12 started.
2025-06-27 05:18:26+00:00 [Note] [Entrypoint]: Initializing database files
...
2025-06-27 05:18:38+00:00 [Note] [Entrypoint]: Creating database db_user_service
2025-06-27 05:18:38+00:00 [Note] [Entrypoint]: Creating user admin
2025-06-27 05:18:38+00:00 [Note] [Entrypoint]: Giving user admin access to schema db_user_service
...
2025-06-27 05:18:40+00:00 [Note] [Entrypoint]: MySQL init process done. Ready for start up.

2025-06-27T05:18:40.909649Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.41) starting as process 1
2025-06-27T05:18:40.914564Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started.
2025-06-27T05:18:41.169343Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended.
...
2025-06-27T05:18:41.411612Z 0 [System] [MY-011323] [Server] X Plugin ready for connections. Bind-address: '::' port: 33060, socket: /var/run/mysqld/mysqlx.sock
2025-06-27T05:18:41.411673Z 0 [System] [MY-010931] [Server] /usr/sbin/mysqld: ready for connections. Version: '8.0.41'  socket: '/var/run/mysqld/mysqld.sock'  port: 3306  MySQL Community Server - GPL.
````
