# Sección 20: Kubernetes: Security JWT con OAuth 2.1

> En esta sección nos apoyaremos en gran medida en la documentación que elaboramos previamente para el curso
> `Microservicios Spring Boot, Spring Cloud Netflix Eureka`
> [ver (sección 10)](https://github.com/magadiflo/microservices-project/blob/main/10.spring_authorization_server_oauth_2.1.md),
> donde también implementamos un `Servidor de Autorización` con `OAuth 2.1` y que se encuentra documentado en detalle.
>
> La diferencia principal es que en este curso —`Microservicios: Guía Completa de Docker & Kubernetes`—
> el tutor utiliza como `cliente y servidor de recursos` al microservicio de `usuarios`, mientras que en el curso
> anterior empleamos como `cliente y servidor de recursos` al `gateway-server`.
>
> Finalmente, en mi caso, optaré también por utilizar al `gateway-server` como `cliente y servidor de recursos`.

---

## Creando microservicio Spring Authorization Server (OAuth 2.1)

Iniciaremos creando un nuevo microservicio llamado `authorization-server` utilizando
[Spring Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.5.5&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=authorization-server&name=authorization-server&description=Authorization%20Server&packageName=dev.magadiflo.authorization.server.app&dependencies=web,lombok,security,oauth2-authorization-server,actuator,cloud-starter).

Al ser `Spring Authorization Server` una capa construida por encima de `Spring Security`, necesitamos añadir también
esta dependencia, al igual que `Spring Web` para el manejo de solicitudes y respuestas HTTP que utiliza
`Spring Authorization Server` para realizar las tareas de autenticación y autorización.

````xml
<!--Spring Boot 3.5.5-->
<!--Spring Cloud Version 2025.0.0-->
<!--Java 21-->
<project>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-authorization-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter</artifactId>
        </dependency>
        <!--Agregado manualmente-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-kubernetes-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-kubernetes-client-loadbalancer</artifactId>
        </dependency>
        <!--/Agregado manualmente-->

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
````

**Nota**
> En `spring initializr` agregamos la dependencia `Cloud Bootstrap (spring-cloud-starter)` únicamente para asegurarnos
> de que desde el inicio el proyecto reconozca la versión correcta de `Spring Cloud`.
>
> Recordemos que cada versión de `Spring Boot` está asociada a una versión específica de `Spring Cloud`.

### Configuraciones iniciales del Authorization Server

En el archivo `application.yml` del `authorization-server` definimos las configuraciones básicas del microservicio.

````yml
server:
  port: 9000
  error:
    include-message: always

spring:
  application:
    name: authorization-server
````

En la clase principal del proyecto añadimos la anotación `@EnableDiscoveryClient`, lo que permite al microservicio
registrarse y descubrir otros servicios a través del mecanismo de descubrimiento de `Spring Cloud Kubernetes`.

````java

@EnableDiscoveryClient
@SpringBootApplication
public class AuthorizationServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthorizationServerApplication.class, args);
    }
}
````

## Configurando el servidor de autorización

Para que nuestro `Authorization Server` funcione correctamente, debemos añadir una clase de configuración de seguridad.
En ella se definen las reglas de seguridad, los clientes registrados, las claves para firmar tokens JWT, y el emisor de
los mismos.

En nuestro caso hemos realizado algunas adaptaciones importantes, como modificar el `redirectUri(...)` de nuestro
cliente registrado, establecer el `issuer("http://127.0.0.1:9000")` como autoridad emisora de los tokens y algunos
otros cambios más.

````java

@Configuration
public class SecurityConfig {

    @Bean
    @Order(1)
    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {
        OAuth2AuthorizationServerConfigurer authorizationServerConfigurer =
                OAuth2AuthorizationServerConfigurer.authorizationServer();

        http
                .securityMatcher(authorizationServerConfigurer.getEndpointsMatcher())
                .with(authorizationServerConfigurer, (authorizationServer) ->
                        authorizationServer
                                .oidc(Customizer.withDefaults())    // Enable OpenID Connect 1.0
                )
                .authorizeHttpRequests((authorize) ->
                        authorize
                                .anyRequest().authenticated()
                )
                // Redirect to the login page when not authenticated from the
                // authorization endpoint
                .exceptionHandling((exceptions) -> exceptions
                        .defaultAuthenticationEntryPointFor(
                                new LoginUrlAuthenticationEntryPoint("/login"),
                                new MediaTypeRequestMatcher(MediaType.TEXT_HTML)
                        )
                );

        return http.build();
    }

    @Bean
    @Order(2)
    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
        http
                .authorizeHttpRequests((authorize) -> authorize
                        .anyRequest().authenticated()
                )
                .csrf(AbstractHttpConfigurer::disable)
                // Form login handles the redirect to the login page from the
                // authorization server filter chain
                .formLogin(Customizer.withDefaults());

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails admin = User.builder()
                .username("admin")
                .password("{noop}123456")
                .roles("USER", "ADMIN")
                .build();

        UserDetails user = User.builder()
                .username("user")
                .password("{noop}123456")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(admin, user);
    }

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret("{noop}123456")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/authorized")
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

    @Bean
    public JWKSource<SecurityContext> jwkSource() {
        KeyPair keyPair = generateRsaKey();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        RSAKey rsaKey = new RSAKey.Builder(publicKey)
                .privateKey(privateKey)
                .keyID(UUID.randomUUID().toString())
                .build();
        JWKSet jwkSet = new JWKSet(rsaKey);
        return new ImmutableJWKSet<>(jwkSet);
    }

    private static KeyPair generateRsaKey() {
        KeyPair keyPair;
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            keyPair = keyPairGenerator.generateKeyPair();
        } catch (Exception ex) {
            throw new IllegalStateException(ex);
        }
        return keyPair;
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {
        return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
    }

    @Bean
    public AuthorizationServerSettings authorizationServerSettings() {
        return AuthorizationServerSettings.builder().issuer("http://127.0.0.1:9000").build();
    }

}
````

- `Filtros de seguridad (SecurityFilterChain)`: definen cómo se protegen los endpoints del servidor de autorización y
  cómo se maneja el login.
- `Usuarios en memoria`: simplificación para pruebas locales.
- `Cliente registrado`: nuestro `gateway-app`, con flujos de autorización (`authorization_code`, `refresh_token`) y
  URIs de redirección configuradas.
- `JWK + RSA keys`: claves generadas en memoria para firmar tokens JWT.
- `AuthorizationServerSettings`: define el issuer oficial de los tokens, necesario para validación en los clientes.

## Implementando endpoint `/authorized` y `/logout` en Gateway Server

En la configuración de seguridad del `authorization-server` (clase `SecurityConfig`), definimos un cliente registrado
que incluye las siguientes URIs:

- http://127.0.0.1:8090/authorized
- http://127.0.0.1:8090/logout

Estas direcciones corresponden al `gateway-server`, por lo que ahora debemos implementarlas allí.

El propósito de cada una es el siguiente:

- `/authorized`: será el punto de redirección donde el Authorization Server enviará el authorization_code una vez
  completado el proceso de autenticación.
- `/logout`: nos servirá como endpoint de prueba para verificar la redirección de cierre de sesión.

````java

@RestController
public class AppController {

    @GetMapping(path = "/authorized")
    public ResponseEntity<Map<String, String>> authorized(@RequestParam String code) {
        return ResponseEntity.ok(Collections.singletonMap("code", code));
    }

    @PostMapping(path = "/logout")
    public ResponseEntity<Map<String, String>> logout() {
        return ResponseEntity.ok(Collections.singletonMap("logout", "OK"));
    }
}
````

👉 Con esto dejamos listos los endpoints requeridos por nuestro cliente (`gateway-app`) para poder integrarse
correctamente en el flujo de autorización definido por `OAuth 2.1`.

## Configurando Resource Server y Cliente OAuth2 en el Gateway Server

Nuestro `gateway-server` será el punto central de entrada al sistema, y por ello cumplirá dos papeles importantes:

1. `Cliente OAuth2 del authorization-server`: inicia el flujo de autenticación del usuario (por ejemplo, con
   `spring-security-oauth2-client`). Una vez autenticado, el usuario obtiene un `access token` que le permitirá consumir
   los microservicios protegidos.

2. `Resource Server`: valida que cada petición entrante tenga un `access token` válido (enviado en el header
   `Authorization: Bearer <token>`). Para esto consulta la configuración publicada por el `authorization-server`
   (`issuer` y claves públicas `JWKs`).

Así que iniciamos agregando las siguientes dependencias al `pom.xml` del `gateway-server`.

````xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
</dependencies>
````

Luego, vamos al `application.yml` del `gateway-server` para configurar nuestro servidor gateway como
`cliente de OAuth2` y como `servidor de recursos`.

````yml
spring:
  application:
    name: gateway-server
  security:
    oauth2:
      # --- Resource Server ---
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
      # --- OAuth2 Client ---
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

Las configuraciones anteriores muestran los dos papeles que estaría cumpliendo nuestro `gateway-server`, veamos uno por
uno.

### 1. Como Resource Server

El gateway valida los `JWT` emitidos por el `Authorization Server`, asegurando que las rutas expuestas estén protegidas:

````yml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
````

### 2. Como OAuth2 Client

Aquí registramos el cliente (`gateway-app`) que participa en el flujo de autorización y recibe tokens desde el
`Authorization Server`:

````yml
spring:
  security:
    oauth2:
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

👉 Con esta configuración, el `gateway-server` ya queda listo para ser la puerta de entrada segura, manejando tanto
la autenticación de usuarios como la validación de tokens en cada petición a los microservicios.

## Configurando clase Resource Server Security Endpoint

Ahora necesitamos implementar la clase `SecurityConfig` en el `gateway-server`, que se encargará de proteger las rutas
expuestas y aplicar las reglas de autorización correspondientes.

> 📌 `Importante`: nuestro `gateway-server` trabaja con programación reactiva (`Spring WebFlux`), por lo que la
> configuración de seguridad se realiza usando `ServerHttpSecurity` en lugar de `HttpSecurity`
> (que se usa en aplicaciones servlet).

````java

@Configuration
public class SecurityConfig {
    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .authorizeExchange(authorize -> authorize
                        .pathMatchers("/authorized", "/logout").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/courses", "/api/v1/users", "/api/v1/users/info").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/courses/{courseId}", "/api/v1/users/{userId}").hasAnyRole("ADMIN", "USER")
                        .pathMatchers("/api/v1/courses/**", "/api/v1/users/**").hasRole("ADMIN")
                        .anyExchange().authenticated()
                )
                .cors(ServerHttpSecurity.CorsSpec::disable)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .oauth2Login(Customizer.withDefaults())
                .oauth2Client(Customizer.withDefaults())
                .oauth2ResourceServer(oauth2ResourceServer ->
                        oauth2ResourceServer.jwt(Customizer.withDefaults()));
        return http.build();
    }
}
````

- Se deshabilita CORS en este ejemplo (aunque en producción suele configurarse) dado que no tenemos un frontEnd.
- `NoOpServerSecurityContextRepository`: evita persistencia de contexto de seguridad en el servidor (`stateless`).
- Se habilitan los tres componentes de seguridad: `OAuth2 Login`, `OAuth2 Client` y `Resource Server` con JWT.

👉 Con esto, el `gateway-server` ya puede distinguir qué rutas son públicas y cuáles están protegidas según rol y
autenticación vía tokens JWT.

## Registrando los claims roles al JWT

Hasta este punto, ya tenemos nuestro `Authorization Server` emitiendo tokens válidos. Sin embargo, necesitamos que el
token incluya también la información de los `roles del usuario`, para que el `gateway-server` pueda aplicarlos en sus
reglas de autorización.

1. `Personalizando el JWT en el Authorization Server`

Agregamos un `@Bean` de tipo `OAuth2TokenCustomizer<JwtEncodingContext>` en la clase `SecurityConfig` del
`authorization-server`. Con esto, interceptamos el proceso de construcción del token y podemos añadir claims
personalizados, en este caso, los `roles` del usuario autenticado.

````java

@Configuration
public class SecurityConfig {

    /* code */

    @Bean
    public OAuth2TokenCustomizer<JwtEncodingContext> tokenCustomizer() {
        return context -> {
            Authentication principal = context.getPrincipal();
            Set<String> roles = principal.getAuthorities().stream()
                    .map(GrantedAuthority::getAuthority)
                    .collect(Collectors.toSet());

            if (context.getTokenType().getValue().equals("access_token")) {
                context.getClaims()
                        .claim("roles", roles)
                        .claim("token_type", "Access Token")
                        .build();
            }

            if (context.getTokenType().getValue().equals("id_token")) {
                context.getClaims()
                        .claim("roles", roles)
                        .claim("token_type", "Id Token")
                        .build();
            }
        };
    }
}
````

Con esta configuración, cada vez que el servidor emita un `access_token` o un `id_token`, añadirá en el payload los
claims personalizados: `roles` y `token_type`.

2. `Usando los roles en el Gateway Server`

Ahora que los tokens incluyen la información de los roles, debemos indicarle al `gateway-server` cómo interpretar esos
claims y convertirlos en autoridades (`GrantedAuthority`) que serán utilizadas por `Spring Security` en las reglas de
autorización.

Para ello, personalizamos el `JwtAuthenticationConverter` en la configuración de seguridad del gateway:

````java

@Configuration
public class SecurityConfig {
    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .authorizeExchange(authorize -> authorize
                        .pathMatchers("/authorized", "/logout").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/courses", "/api/v1/users", "/api/v1/users/info").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/courses/{courseId}", "/api/v1/users/{userId}").hasAnyRole("ADMIN", "USER")
                        .pathMatchers("/api/v1/courses/**", "/api/v1/users/**").hasRole("ADMIN")
                        .anyExchange().authenticated()
                )
                .cors(ServerHttpSecurity.CorsSpec::disable)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .oauth2Login(Customizer.withDefaults())
                .oauth2Client(Customizer.withDefaults())
                .oauth2ResourceServer(oauth2ResourceServer ->
                        oauth2ResourceServer.jwt(jwt -> {
                            jwt.jwtAuthenticationConverter(source -> {
                                Collection<String> roles = source.getClaimAsStringList("roles");
                                Collection<GrantedAuthority> authorities = roles.stream()
                                        .map(SimpleGrantedAuthority::new)
                                        .collect(Collectors.toSet());

                                return Mono.just(new JwtAuthenticationToken(source, authorities));
                            });
                        }));
        return http.build();
    }
}
````

De esta forma, los claims `roles` incluidos en el token JWT se traducen a `GrantedAuthority`, y ya podemos usar
anotaciones o reglas como `.hasRole("ADMIN")` o `.hasAnyRole("ADMIN", "USER")` en nuestro gateway para proteger los
endpoints.

👉 Con esto, logramos que el `authorization-server` enriquezca el JWT con roles, y que el `gateway-server` sea capaz
de consumirlos y aplicarlos en sus reglas de autorización.

## Configurando variables de entorno en gateway-server

Hasta ahora hemos configurado las direcciones del `Authorization Server` y del propio `Gateway Server` de forma fija
en el `application.yml`. Sin embargo, cuando despleguemos nuestros microservicios en Kubernetes, esas direcciones
cambiarán y estarán determinadas por los servicios expuestos dentro del cluster.

Para evitar tener que modificar manualmente el archivo `application.yml` en cada entorno (local, Docker, Kubernetes,
etc.), parametrizaremos dichas URLs mediante variables de entorno. De esta forma, podemos reutilizar la misma
configuración y solo cambiar los valores al momento de ejecutar o desplegar.

### Nuevas variables de entorno

En el `application.yml` del `gateway-server` agregamos:

- `LB_AUTHORIZATION_ISSUER_URI` → Define la URL del `Authorization Server` (`issuer`).
- `LB_GATEWAY_URI` → Define la URL pública del `Gateway Server` (usada como `redirect-uri`).

Ambas variables tienen valores por defecto para el entorno local (`127.0.0.1`), pero podrán ser sobrescritas
fácilmente al pasar variables de entorno en Docker o Kubernetes.

````yml
spring:
  application:
    name: gateway-server
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: ${LB_AUTHORIZATION_ISSUER_URI:http://127.0.0.1:9000}
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: ${LB_GATEWAY_URI:http://127.0.0.1:8090}/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: ${LB_AUTHORIZATION_ISSUER_URI:http://127.0.0.1:9000}
````

✅ Con esta configuración, nuestro `gateway-server` ya queda preparado para adaptarse dinámicamente al entorno en que
se ejecute, lo cual será fundamental en la siguiente etapa cuando pasemos al despliegue en Kubernetes.

### Configurando ConfigMap y Deployment para gateway-server

En el apartado anterior parametrizamos las direcciones del authorization server y del gateway server mediante variables
de entorno (`LB_AUTHORIZATION_ISSUER_URI` y `LB_GATEWAY_URI`). Ahora vamos a definir esas variables dentro de Kubernetes
usando un `ConfigMap` y enlazándolas en el `Deployment`.

1. `Creando el ConfigMap`

Creamos el archivo `configmap-gateway.yml` donde declaramos los valores de nuestras variables de entorno:

````yml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cm-gateway-server
data:
  lb_authorization_issuer_uri: http://127.0.0.1:9000
  lb_gateway_uri: http://127.0.0.1:8090
````

> ⚠️ Nota: Por ahora dejamos valores locales, pero cuando despleguemos el proyecto en Kubernetes actualizaremos estas
> direcciones para que apunten a los servicios internos del clúster.

2. `Actualizando el Deployment`

En el archivo `deployment-gateway.yml` añadimos las variables de entorno y las vinculamos al `ConfigMap`:

````yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: d-gateway-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: d-gateway-server
  template:
    metadata:
      labels:
        app: d-gateway-server
    spec:
      containers:
        - image: magadiflo/gateway-server:latest
          name: c-gateway-server
          ports:
            - containerPort: 8090
          env:
            - name: CONTAINER_PORT
              value: '8090'
            - name: LB_AUTHORIZATION_ISSUER_URI
              valueFrom:
                configMapKeyRef:
                  name: cm-gateway-server
                  key: lb_authorization_issuer_uri
            - name: LB_GATEWAY_URI
              valueFrom:
                configMapKeyRef:
                  name: cm-gateway-server
                  key: lb_gateway_uri
````

De esta forma el contenedor tomará los valores de configuración directamente del `ConfigMap`.

3. `Reconstruyendo la imagen Docker`

Como el `gateway-server` ha sido modificado, necesitamos reconstruir la imagen:

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-20)
$ docker image build -t magadiflo/gateway-server .\infrastructure\gateway-server
````

Luego subimos la nueva versión a Docker Hub:

````bash
$ docker push magadiflo/gateway-server
````

## Configurando variables de entorno en el Authorization Server

En el `authorization-server` también vamos a trabajar con variables de entorno, de manera que podamos alinear su
configuración con la del `gateway-server`.

En este caso, necesitamos que el cliente registrado en el `authorization-server` tenga como `redirect-uri` y
`post-logout-redirect-uri` la misma dirección que se definió en el `application.yml` del `gateway-server`.

Para lograrlo, en la clase `SecurityConfig` inyectamos la interfaz `Environment`, que nos permite acceder a las
variables de entorno.

````java

@RequiredArgsConstructor
@Configuration
public class SecurityConfig {

    private final Environment env;

    /* code */

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret("{noop}123456")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri(String.format("%s/authorized", this.env.getProperty("LB_GATEWAY_URI")))
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri(String.format("%s/logout", this.env.getProperty("LB_GATEWAY_URI")))
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

    /* code */
}
````

Con esto, el `authorization-server` podrá leer dinámicamente la dirección del gateway definida en la variable
`LB_GATEWAY_URI` y asociarla a los redirect URIs del cliente.

De esta manera evitamos valores fijos en el código y facilitamos la configuración en diferentes entornos (local,
pruebas, producción, Kubernetes, etc.).

### Creando imagen Docker del Authorization Server

Al igual que con el `gateway-server`, debemos crear la imagen Docker para nuestro `authorization-server`. En este caso,
el microservicio se ejecuta en el puerto `9000`, por lo que lo exponemos en el `Dockerfile`.

El `Dockerfile` definido en la raíz del proyecto es el siguiente:

````dockerfile
ARG JDK_VERSION=21-jdk-alpine
ARG JRE_VERSION=21-jre-alpine

FROM eclipse-temurin:${JDK_VERSION} AS dependencies
WORKDIR /app
COPY ./mvnw ./
COPY ./.mvn ./.mvn
COPY ./pom.xml ./
RUN sed -i -e 's/\r$//' ./mvnw
RUN ./mvnw dependency:go-offline
COPY ./src ./src
RUN ./mvnw clean package -DskipTests

FROM eclipse-temurin:${JRE_VERSION} AS builder
WORKDIR /app
COPY --from=dependencies /app/target/*.jar ./app.jar
RUN java -Djarmode=layertools -jar app.jar extract

FROM eclipse-temurin:${JRE_VERSION} AS runner
WORKDIR /app
RUN mkdir ./logs
COPY --from=builder /app/dependencies ./
COPY --from=builder /app/spring-boot-loader ./
COPY --from=builder /app/snapshot-dependencies ./
COPY --from=builder /app/application ./

ENV CONTAINER_PORT=9000
EXPOSE ${CONTAINER_PORT}
CMD ["java", "org.springframework.boot.loader.launch.JarLauncher"]
````

### Construcción de la imagen

Desde la raíz del proyecto ejecutamos el siguiente comando para construir la imagen del `authorization-server`:

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-20)
$ docker image build -t magadiflo/authorization-server .\security\authorization-server
````

### Publicación en Docker Hub

En Docker Hub creamos un repositorio llamado `authorization-server`, donde subiremos la imagen recién creada.

````bash
$ docker push magadiflo/authorization-server
````

De esta manera ya tenemos disponible la imagen Docker del Authorization Server en Docker Hub, lista para ser desplegada
en Kubernetes.

## Escribiendo Deployment y Service del Authorization Server

En este punto desplegaremos nuestro `Authorization Server` en `Kubernetes` mediante un `Deployment` y un `Service`.

### Deployment

Creamos el archivo `deployment-authorization.yml` donde especificamos:

- El nombre del Deployment: `d-authorization-server`.
- La imagen `magadiflo/authorization-server:latest` previamente construida y subida a `Docker Hub`.
- El puerto expuesto por el contenedor (`9000`).
- La variable de entorno `LB_GATEWAY_URI`, cuyo valor obtenemos del `ConfigMap` `cm-gateway-server`.

````yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: d-authorization-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: d-authorization-server
  template:
    metadata:
      labels:
        app: d-authorization-server
    spec:
      containers:
        - image: magadiflo/authorization-server:latest
          name: c-authorization-server
          ports:
            - containerPort: 9000
          env:
            - name: LB_GATEWAY_URI
              valueFrom:
                configMapKeyRef:
                  name: cm-gateway-server
                  key: lb_gateway_uri
````

De esta manera, el `Authorization Server` podrá resolver dinámicamente la URI del `Gateway` en función de la
configuración del entorno.

### Service

Luego, definimos el archivo `service-authorization.yml` que expone nuestro `Authorization Server` dentro del clúster.

- El nombre del servicio será `s-authorization-server`.
- Se expone el puerto `9000` con el protocolo `TCP`.
- Se utiliza un selector para apuntar a los pods etiquetados con `app: d-authorization-server`.
- El tipo de servicio es `LoadBalancer`, lo que permitirá acceder desde fuera del clúster
  (útil cuando despleguemos en la nube).

````yml
apiVersion: v1
kind: Service
metadata:
  name: s-authorization-server
spec:
  ports:
    - port: 9000
      protocol: TCP
      targetPort: 9000
  selector:
    app: d-authorization-server
  type: LoadBalancer
````

Con esta configuración, el `Authorization Server` quedará accesible a través del servicio expuesto por `Kubernetes`.

