# Secci√≥n 20: Kubernetes: Security JWT con OAuth 2.1

> En esta secci√≥n nos apoyaremos en gran medida en la documentaci√≥n que elaboramos previamente para el curso
> `Microservicios Spring Boot, Spring Cloud Netflix Eureka`
> [ver (secci√≥n 10)](https://github.com/magadiflo/microservices-project/blob/main/10.spring_authorization_server_oauth_2.1.md),
> donde tambi√©n implementamos un `Servidor de Autorizaci√≥n` con `OAuth 2.1` y que se encuentra documentado en detalle.
>
> La diferencia principal es que en este curso ‚Äî`Microservicios: Gu√≠a Completa de Docker & Kubernetes`‚Äî
> el tutor utiliza como `cliente y servidor de recursos` al microservicio de `usuarios`, mientras que en el curso
> anterior empleamos como `cliente y servidor de recursos` al `gateway-server`.
>
> Finalmente, en mi caso, optar√© tambi√©n por utilizar al `gateway-server` como `cliente y servidor de recursos`.

---

## Creando microservicio Spring Authorization Server (OAuth 2.1)

Iniciaremos creando un nuevo microservicio llamado `authorization-server` utilizando
[Spring Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.5.5&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=authorization-server&name=authorization-server&description=Authorization%20Server&packageName=dev.magadiflo.authorization.server.app&dependencies=web,lombok,security,oauth2-authorization-server,actuator,cloud-starter).

Al ser `Spring Authorization Server` una capa construida por encima de `Spring Security`, necesitamos a√±adir tambi√©n
esta dependencia, al igual que `Spring Web` para el manejo de solicitudes y respuestas HTTP que utiliza
`Spring Authorization Server` para realizar las tareas de autenticaci√≥n y autorizaci√≥n.

````xml
<!--Spring Boot 3.5.5-->
<!--Spring Cloud Version 2025.0.0-->
<!--Java 21-->
<project>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-authorization-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter</artifactId>
        </dependency>
        <!--Agregado manualmente-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-kubernetes-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-kubernetes-client-loadbalancer</artifactId>
        </dependency>
        <!--/Agregado manualmente-->

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
````

**Nota**
> En `spring initializr` agregamos la dependencia `Cloud Bootstrap (spring-cloud-starter)` √∫nicamente para asegurarnos
> de que desde el inicio el proyecto reconozca la versi√≥n correcta de `Spring Cloud`.
>
> Recordemos que cada versi√≥n de `Spring Boot` est√° asociada a una versi√≥n espec√≠fica de `Spring Cloud`.

### Configuraciones iniciales del Authorization Server

En el archivo `application.yml` del `authorization-server` definimos las configuraciones b√°sicas del microservicio.

````yml
server:
  port: 9000
  error:
    include-message: always

spring:
  application:
    name: authorization-server
````

En la clase principal del proyecto a√±adimos la anotaci√≥n `@EnableDiscoveryClient`, lo que permite al microservicio
registrarse y descubrir otros servicios a trav√©s del mecanismo de descubrimiento de `Spring Cloud Kubernetes`.

````java

@EnableDiscoveryClient
@SpringBootApplication
public class AuthorizationServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthorizationServerApplication.class, args);
    }
}
````

## Configurando el servidor de autorizaci√≥n

Para que nuestro `Authorization Server` funcione correctamente, debemos a√±adir una clase de configuraci√≥n de seguridad.
En ella se definen las reglas de seguridad, los clientes registrados, las claves para firmar tokens JWT, y el emisor de
los mismos.

En nuestro caso hemos realizado algunas adaptaciones importantes, como modificar el `redirectUri(...)` de nuestro
cliente registrado, establecer el `issuer("http://127.0.0.1:9000")` como autoridad emisora de los tokens y algunos
otros cambios m√°s.

````java

@Configuration
public class SecurityConfig {

    @Bean
    @Order(1)
    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {
        OAuth2AuthorizationServerConfigurer authorizationServerConfigurer =
                OAuth2AuthorizationServerConfigurer.authorizationServer();

        http
                .securityMatcher(authorizationServerConfigurer.getEndpointsMatcher())
                .with(authorizationServerConfigurer, (authorizationServer) ->
                        authorizationServer
                                .oidc(Customizer.withDefaults())    // Enable OpenID Connect 1.0
                )
                .authorizeHttpRequests((authorize) ->
                        authorize
                                .anyRequest().authenticated()
                )
                // Redirect to the login page when not authenticated from the
                // authorization endpoint
                .exceptionHandling((exceptions) -> exceptions
                        .defaultAuthenticationEntryPointFor(
                                new LoginUrlAuthenticationEntryPoint("/login"),
                                new MediaTypeRequestMatcher(MediaType.TEXT_HTML)
                        )
                );

        return http.build();
    }

    @Bean
    @Order(2)
    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
        http
                .authorizeHttpRequests((authorize) -> authorize
                        .anyRequest().authenticated()
                )
                .csrf(AbstractHttpConfigurer::disable)
                // Form login handles the redirect to the login page from the
                // authorization server filter chain
                .formLogin(Customizer.withDefaults());

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails admin = User.builder()
                .username("admin")
                .password("{noop}123456")
                .roles("USER", "ADMIN")
                .build();

        UserDetails user = User.builder()
                .username("user")
                .password("{noop}123456")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(admin, user);
    }

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret("{noop}123456")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/authorized")
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

    @Bean
    public JWKSource<SecurityContext> jwkSource() {
        KeyPair keyPair = generateRsaKey();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        RSAKey rsaKey = new RSAKey.Builder(publicKey)
                .privateKey(privateKey)
                .keyID(UUID.randomUUID().toString())
                .build();
        JWKSet jwkSet = new JWKSet(rsaKey);
        return new ImmutableJWKSet<>(jwkSet);
    }

    private static KeyPair generateRsaKey() {
        KeyPair keyPair;
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            keyPair = keyPairGenerator.generateKeyPair();
        } catch (Exception ex) {
            throw new IllegalStateException(ex);
        }
        return keyPair;
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {
        return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
    }

    @Bean
    public AuthorizationServerSettings authorizationServerSettings() {
        return AuthorizationServerSettings.builder().issuer("http://127.0.0.1:9000").build();
    }

}
````

- `Filtros de seguridad (SecurityFilterChain)`: definen c√≥mo se protegen los endpoints del servidor de autorizaci√≥n y
  c√≥mo se maneja el login.
- `Usuarios en memoria`: simplificaci√≥n para pruebas locales.
- `Cliente registrado`: nuestro `gateway-app`, con flujos de autorizaci√≥n (`authorization_code`, `refresh_token`) y
  URIs de redirecci√≥n configuradas.
- `JWK + RSA keys`: claves generadas en memoria para firmar tokens JWT.
- `AuthorizationServerSettings`: define el issuer oficial de los tokens, necesario para validaci√≥n en los clientes.

## Implementando endpoint `/authorized` y `/logout` en Gateway Server

En la configuraci√≥n de seguridad del `authorization-server` (clase `SecurityConfig`), definimos un cliente registrado
que incluye las siguientes URIs:

- http://127.0.0.1:8090/authorized
- http://127.0.0.1:8090/logout

Estas direcciones corresponden al `gateway-server`, por lo que ahora debemos implementarlas all√≠.

El prop√≥sito de cada una es el siguiente:

- `/authorized`: ser√° el punto de redirecci√≥n donde el Authorization Server enviar√° el authorization_code una vez
  completado el proceso de autenticaci√≥n.
- `/logout`: nos servir√° como endpoint de prueba para verificar la redirecci√≥n de cierre de sesi√≥n.

````java

@RestController
public class AppController {

    @GetMapping(path = "/authorized")
    public ResponseEntity<Map<String, String>> authorized(@RequestParam String code) {
        return ResponseEntity.ok(Collections.singletonMap("code", code));
    }

    @PostMapping(path = "/logout")
    public ResponseEntity<Map<String, String>> logout() {
        return ResponseEntity.ok(Collections.singletonMap("logout", "OK"));
    }
}
````

üëâ Con esto dejamos listos los endpoints requeridos por nuestro cliente (`gateway-app`) para poder integrarse
correctamente en el flujo de autorizaci√≥n definido por `OAuth 2.1`.

## Configurando Resource Server y Cliente OAuth2 en el Gateway Server

Nuestro `gateway-server` ser√° el punto central de entrada al sistema, y por ello cumplir√° dos papeles importantes:

1. `Cliente OAuth2 del authorization-server`: inicia el flujo de autenticaci√≥n del usuario (por ejemplo, con
   `spring-security-oauth2-client`). Una vez autenticado, el usuario obtiene un `access token` que le permitir√° consumir
   los microservicios protegidos.

2. `Resource Server`: valida que cada petici√≥n entrante tenga un `access token` v√°lido (enviado en el header
   `Authorization: Bearer <token>`). Para esto consulta la configuraci√≥n publicada por el `authorization-server`
   (`issuer` y claves p√∫blicas `JWKs`).

As√≠ que iniciamos agregando las siguientes dependencias al `pom.xml` del `gateway-server`.

````xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
</dependencies>
````

Luego, vamos al `application.yml` del `gateway-server` para configurar nuestro servidor gateway como
`cliente de OAuth2` y como `servidor de recursos`.

````yml
spring:
  application:
    name: gateway-server
  security:
    oauth2:
      # --- Resource Server ---
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
      # --- OAuth2 Client ---
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

Las configuraciones anteriores muestran los dos papeles que estar√≠a cumpliendo nuestro `gateway-server`, veamos uno por
uno.

### 1. Como Resource Server

El gateway valida los `JWT` emitidos por el `Authorization Server`, asegurando que las rutas expuestas est√©n protegidas:

````yml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
````

### 2. Como OAuth2 Client

Aqu√≠ registramos el cliente (`gateway-app`) que participa en el flujo de autorizaci√≥n y recibe tokens desde el
`Authorization Server`:

````yml
spring:
  security:
    oauth2:
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

üëâ Con esta configuraci√≥n, el `gateway-server` ya queda listo para ser la puerta de entrada segura, manejando tanto
la autenticaci√≥n de usuarios como la validaci√≥n de tokens en cada petici√≥n a los microservicios.

## Configurando clase Resource Server Security Endpoint

Ahora necesitamos implementar la clase `SecurityConfig` en el `gateway-server`, que se encargar√° de proteger las rutas
expuestas y aplicar las reglas de autorizaci√≥n correspondientes.

> üìå `Importante`: nuestro `gateway-server` trabaja con programaci√≥n reactiva (`Spring WebFlux`), por lo que la
> configuraci√≥n de seguridad se realiza usando `ServerHttpSecurity` en lugar de `HttpSecurity`
> (que se usa en aplicaciones servlet).

````java

@Configuration
public class SecurityConfig {
    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .authorizeExchange(authorize -> authorize
                        .pathMatchers("/authorized", "/logout").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/courses", "/api/v1/users", "/api/v1/users/info").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/courses/{courseId}", "/api/v1/users/{userId}").hasAnyRole("ADMIN", "USER")
                        .pathMatchers("/api/v1/courses/**", "/api/v1/users/**").hasRole("ADMIN")
                        .anyExchange().authenticated()
                )
                .cors(ServerHttpSecurity.CorsSpec::disable)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .oauth2Login(Customizer.withDefaults())
                .oauth2Client(Customizer.withDefaults())
                .oauth2ResourceServer(oauth2ResourceServer ->
                        oauth2ResourceServer.jwt(Customizer.withDefaults()));
        return http.build();
    }
}
````

- Se deshabilita CORS en este ejemplo (aunque en producci√≥n suele configurarse) dado que no tenemos un frontEnd.
- `NoOpServerSecurityContextRepository`: evita persistencia de contexto de seguridad en el servidor (`stateless`).
- Se habilitan los tres componentes de seguridad: `OAuth2 Login`, `OAuth2 Client` y `Resource Server` con JWT.

üëâ Con esto, el `gateway-server` ya puede distinguir qu√© rutas son p√∫blicas y cu√°les est√°n protegidas seg√∫n rol y
autenticaci√≥n v√≠a tokens JWT.

## Registrando los claims roles al JWT

Hasta este punto, ya tenemos nuestro `Authorization Server` emitiendo tokens v√°lidos. Sin embargo, necesitamos que el
token incluya tambi√©n la informaci√≥n de los `roles del usuario`, para que el `gateway-server` pueda aplicarlos en sus
reglas de autorizaci√≥n.

1. `Personalizando el JWT en el Authorization Server`

Agregamos un `@Bean` de tipo `OAuth2TokenCustomizer<JwtEncodingContext>` en la clase `SecurityConfig` del
`authorization-server`. Con esto, interceptamos el proceso de construcci√≥n del token y podemos a√±adir claims
personalizados, en este caso, los `roles` del usuario autenticado.

````java

@Configuration
public class SecurityConfig {

    /* code */

    @Bean
    public OAuth2TokenCustomizer<JwtEncodingContext> tokenCustomizer() {
        return context -> {
            Authentication principal = context.getPrincipal();
            Set<String> roles = principal.getAuthorities().stream()
                    .map(GrantedAuthority::getAuthority)
                    .collect(Collectors.toSet());

            if (context.getTokenType().getValue().equals("access_token")) {
                context.getClaims()
                        .claim("roles", roles)
                        .claim("token_type", "Access Token")
                        .build();
            }

            if (context.getTokenType().getValue().equals("id_token")) {
                context.getClaims()
                        .claim("roles", roles)
                        .claim("token_type", "Id Token")
                        .build();
            }
        };
    }
}
````

Con esta configuraci√≥n, cada vez que el servidor emita un `access_token` o un `id_token`, a√±adir√° en el payload los
claims personalizados: `roles` y `token_type`.

2. `Usando los roles en el Gateway Server`

Ahora que los tokens incluyen la informaci√≥n de los roles, debemos indicarle al `gateway-server` c√≥mo interpretar esos
claims y convertirlos en autoridades (`GrantedAuthority`) que ser√°n utilizadas por `Spring Security` en las reglas de
autorizaci√≥n.

Para ello, personalizamos el `JwtAuthenticationConverter` en la configuraci√≥n de seguridad del gateway:

````java

@Configuration
public class SecurityConfig {
    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .authorizeExchange(authorize -> authorize
                        .pathMatchers("/authorized", "/logout").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/courses", "/api/v1/users", "/api/v1/users/info").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/courses/{courseId}", "/api/v1/users/{userId}").hasAnyRole("ADMIN", "USER")
                        .pathMatchers("/api/v1/courses/**", "/api/v1/users/**").hasRole("ADMIN")
                        .anyExchange().authenticated()
                )
                .cors(ServerHttpSecurity.CorsSpec::disable)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .oauth2Login(Customizer.withDefaults())
                .oauth2Client(Customizer.withDefaults())
                .oauth2ResourceServer(oauth2ResourceServer ->
                        oauth2ResourceServer.jwt(jwt -> {
                            jwt.jwtAuthenticationConverter(source -> {
                                Collection<String> roles = source.getClaimAsStringList("roles");
                                Collection<GrantedAuthority> authorities = roles.stream()
                                        .map(SimpleGrantedAuthority::new)
                                        .collect(Collectors.toSet());

                                return Mono.just(new JwtAuthenticationToken(source, authorities));
                            });
                        }));
        return http.build();
    }
}
````

De esta forma, los claims `roles` incluidos en el token JWT se traducen a `GrantedAuthority`, y ya podemos usar
anotaciones o reglas como `.hasRole("ADMIN")` o `.hasAnyRole("ADMIN", "USER")` en nuestro gateway para proteger los
endpoints.

üëâ Con esto, logramos que el `authorization-server` enriquezca el JWT con roles, y que el `gateway-server` sea capaz
de consumirlos y aplicarlos en sus reglas de autorizaci√≥n.

## Configurando variables de entorno en gateway-server

Hasta ahora hemos configurado las direcciones del `Authorization Server` y del propio `Gateway Server` de forma fija
en el `application.yml`. Sin embargo, cuando despleguemos nuestros microservicios en Kubernetes, esas direcciones
cambiar√°n y estar√°n determinadas por los servicios expuestos dentro del cluster.

Para evitar tener que modificar manualmente el archivo `application.yml` en cada entorno (local, Docker, Kubernetes,
etc.), parametrizaremos dichas URLs mediante variables de entorno. De esta forma, podemos reutilizar la misma
configuraci√≥n y solo cambiar los valores al momento de ejecutar o desplegar.

### Nuevas variables de entorno

En el `application.yml` del `gateway-server` agregamos:

- `LB_AUTHORIZATION_ISSUER_URI` ‚Üí Define la URL del `Authorization Server` (`issuer`).
- `LB_GATEWAY_URI` ‚Üí Define la URL p√∫blica del `Gateway Server` (usada como `redirect-uri`).

Ambas variables tienen valores por defecto para el entorno local (`127.0.0.1`), pero podr√°n ser sobrescritas
f√°cilmente al pasar variables de entorno en Docker o Kubernetes.

````yml
spring:
  application:
    name: gateway-server
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: ${LB_AUTHORIZATION_ISSUER_URI:http://127.0.0.1:9000}
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: ${LB_GATEWAY_URI:http://127.0.0.1:8090}/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: ${LB_AUTHORIZATION_ISSUER_URI:http://127.0.0.1:9000}
````

‚úÖ Con esta configuraci√≥n, nuestro `gateway-server` ya queda preparado para adaptarse din√°micamente al entorno en que
se ejecute, lo cual ser√° fundamental en la siguiente etapa cuando pasemos al despliegue en Kubernetes.

### Configurando ConfigMap y Deployment para gateway-server

En el apartado anterior parametrizamos las direcciones del authorization server y del gateway server mediante variables
de entorno (`LB_AUTHORIZATION_ISSUER_URI` y `LB_GATEWAY_URI`). Ahora vamos a definir esas variables dentro de Kubernetes
usando un `ConfigMap` y enlaz√°ndolas en el `Deployment`.

1. `Creando el ConfigMap`

Creamos el archivo `configmap-gateway.yml` donde declaramos los valores de nuestras variables de entorno:

````yml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cm-gateway-server
data:
  lb_authorization_issuer_uri: http://127.0.0.1:9000
  lb_gateway_uri: http://127.0.0.1:8090
````

> ‚ö†Ô∏è Nota: Por ahora dejamos valores locales, pero cuando despleguemos el proyecto en Kubernetes actualizaremos estas
> direcciones para que apunten a los servicios internos del cl√∫ster.

2. `Actualizando el Deployment`

En el archivo `deployment-gateway.yml` a√±adimos las variables de entorno y las vinculamos al `ConfigMap`:

````yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: d-gateway-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: d-gateway-server
  template:
    metadata:
      labels:
        app: d-gateway-server
    spec:
      containers:
        - image: magadiflo/gateway-server:latest
          name: c-gateway-server
          ports:
            - containerPort: 8090
          env:
            - name: CONTAINER_PORT
              value: '8090'
            - name: LB_AUTHORIZATION_ISSUER_URI
              valueFrom:
                configMapKeyRef:
                  name: cm-gateway-server
                  key: lb_authorization_issuer_uri
            - name: LB_GATEWAY_URI
              valueFrom:
                configMapKeyRef:
                  name: cm-gateway-server
                  key: lb_gateway_uri
````

De esta forma el contenedor tomar√° los valores de configuraci√≥n directamente del `ConfigMap`.

3. `Reconstruyendo la imagen Docker`

Como el `gateway-server` ha sido modificado, necesitamos reconstruir la imagen:

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-20)
$ docker image build -t magadiflo/gateway-server .\infrastructure\gateway-server
````

Luego subimos la nueva versi√≥n a Docker Hub:

````bash
$ docker push magadiflo/gateway-server
````

## Configurando variables de entorno en el Authorization Server

En el `authorization-server` tambi√©n vamos a trabajar con variables de entorno, de manera que podamos alinear su
configuraci√≥n con la del `gateway-server`.

En este caso, necesitamos que el cliente registrado en el `authorization-server` tenga como `redirect-uri` y
`post-logout-redirect-uri` la misma direcci√≥n que se defini√≥ en el `application.yml` del `gateway-server`.

Para lograrlo, en la clase `SecurityConfig` inyectamos la interfaz `Environment`, que nos permite acceder a las
variables de entorno.

````java

@RequiredArgsConstructor
@Configuration
public class SecurityConfig {

    private final Environment env;

    /* code */

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret("{noop}123456")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri(String.format("%s/authorized", this.env.getProperty("LB_GATEWAY_URI")))
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri(String.format("%s/logout", this.env.getProperty("LB_GATEWAY_URI")))
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

    /* code */
}
````

Con esto, el `authorization-server` podr√° leer din√°micamente la direcci√≥n del gateway definida en la variable
`LB_GATEWAY_URI` y asociarla a los redirect URIs del cliente.

De esta manera evitamos valores fijos en el c√≥digo y facilitamos la configuraci√≥n en diferentes entornos (local,
pruebas, producci√≥n, Kubernetes, etc.).

### Creando imagen Docker del Authorization Server

Al igual que con el `gateway-server`, debemos crear la imagen Docker para nuestro `authorization-server`. En este caso,
el microservicio se ejecuta en el puerto `9000`, por lo que lo exponemos en el `Dockerfile`.

El `Dockerfile` definido en la ra√≠z del proyecto es el siguiente:

````dockerfile
ARG JDK_VERSION=21-jdk-alpine
ARG JRE_VERSION=21-jre-alpine

FROM eclipse-temurin:${JDK_VERSION} AS dependencies
WORKDIR /app
COPY ./mvnw ./
COPY ./.mvn ./.mvn
COPY ./pom.xml ./
RUN sed -i -e 's/\r$//' ./mvnw
RUN ./mvnw dependency:go-offline
COPY ./src ./src
RUN ./mvnw clean package -DskipTests

FROM eclipse-temurin:${JRE_VERSION} AS builder
WORKDIR /app
COPY --from=dependencies /app/target/*.jar ./app.jar
RUN java -Djarmode=layertools -jar app.jar extract

FROM eclipse-temurin:${JRE_VERSION} AS runner
WORKDIR /app
RUN mkdir ./logs
COPY --from=builder /app/dependencies ./
COPY --from=builder /app/spring-boot-loader ./
COPY --from=builder /app/snapshot-dependencies ./
COPY --from=builder /app/application ./

ENV CONTAINER_PORT=9000
EXPOSE ${CONTAINER_PORT}
CMD ["java", "org.springframework.boot.loader.launch.JarLauncher"]
````

### Construcci√≥n de la imagen

Desde la ra√≠z del proyecto ejecutamos el siguiente comando para construir la imagen del `authorization-server`:

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-20)
$ docker image build -t magadiflo/authorization-server .\security\authorization-server
````

### Publicaci√≥n en Docker Hub

En Docker Hub creamos un repositorio llamado `authorization-server`, donde subiremos la imagen reci√©n creada.

````bash
$ docker push magadiflo/authorization-server
````

De esta manera ya tenemos disponible la imagen Docker del Authorization Server en Docker Hub, lista para ser desplegada
en Kubernetes.

## Escribiendo Deployment y Service del Authorization Server

En este punto desplegaremos nuestro `Authorization Server` en `Kubernetes` mediante un `Deployment` y un `Service`.

### Deployment

Creamos el archivo `deployment-authorization.yml` donde especificamos:

- El nombre del Deployment: `d-authorization-server`.
- La imagen `magadiflo/authorization-server:latest` previamente construida y subida a `Docker Hub`.
- El puerto expuesto por el contenedor (`9000`).
- La variable de entorno `LB_GATEWAY_URI`, cuyo valor obtenemos del `ConfigMap` `cm-gateway-server`.

````yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: d-authorization-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: d-authorization-server
  template:
    metadata:
      labels:
        app: d-authorization-server
    spec:
      containers:
        - image: magadiflo/authorization-server:latest
          name: c-authorization-server
          ports:
            - containerPort: 9000
          env:
            - name: LB_GATEWAY_URI
              valueFrom:
                configMapKeyRef:
                  name: cm-gateway-server
                  key: lb_gateway_uri
````

De esta manera, el `Authorization Server` podr√° resolver din√°micamente la URI del `Gateway` en funci√≥n de la
configuraci√≥n del entorno.

### Service

Luego, definimos el archivo `service-authorization.yml` que expone nuestro `Authorization Server` dentro del cl√∫ster.

- El nombre del servicio ser√° `s-authorization-server`.
- Se expone el puerto `9000` con el protocolo `TCP`.
- Se utiliza un selector para apuntar a los pods etiquetados con `app: d-authorization-server`.
- El tipo de servicio es `LoadBalancer`, lo que permitir√° acceder desde fuera del cl√∫ster
  (√∫til cuando despleguemos en la nube).

````yml
apiVersion: v1
kind: Service
metadata:
  name: s-authorization-server
spec:
  ports:
    - port: 9000
      protocol: TCP
      targetPort: 9000
  selector:
    app: d-authorization-server
  type: LoadBalancer
````

Con esta configuraci√≥n, el `Authorization Server` quedar√° accesible a trav√©s del servicio expuesto por `Kubernetes`.

