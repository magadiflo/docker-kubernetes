# Secci√≥n 20: Kubernetes: Security JWT con OAuth 2.1

> En esta secci√≥n nos apoyaremos en gran medida en la documentaci√≥n que elaboramos previamente para el curso
> `Microservicios Spring Boot, Spring Cloud Netflix Eureka`
> [ver (secci√≥n 10)](https://github.com/magadiflo/microservices-project/blob/main/10.spring_authorization_server_oauth_2.1.md),
> donde tambi√©n implementamos un `Servidor de Autorizaci√≥n` con `OAuth 2.1` y que se encuentra documentado en detalle.
>
> La diferencia principal es que en este curso ‚Äî`Microservicios: Gu√≠a Completa de Docker & Kubernetes`‚Äî
> el tutor utiliza como `cliente y servidor de recursos` al microservicio de `usuarios`, mientras que en el curso
> anterior empleamos como `cliente y servidor de recursos` al `gateway-server`.
>
> Finalmente, en mi caso, optar√© tambi√©n por utilizar al `gateway-server` como `cliente y servidor de recursos`.

---

## Creando microservicio Spring Authorization Server (OAuth 2.1)

Iniciaremos creando un nuevo microservicio llamado `authorization-server` utilizando
[Spring Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.5.5&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=authorization-server&name=authorization-server&description=Authorization%20Server&packageName=dev.magadiflo.authorization.server.app&dependencies=web,lombok,security,oauth2-authorization-server,actuator,cloud-starter).

Al ser `Spring Authorization Server` una capa construida por encima de `Spring Security`, necesitamos a√±adir tambi√©n
esta dependencia, al igual que `Spring Web` para el manejo de solicitudes y respuestas HTTP que utiliza
`Spring Authorization Server` para realizar las tareas de autenticaci√≥n y autorizaci√≥n.

````xml
<!--Spring Boot 3.5.5-->
<!--Spring Cloud Version 2025.0.0-->
<!--Java 21-->
<project>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-authorization-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter</artifactId>
        </dependency>
        <!--Agregado manualmente-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-kubernetes-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-kubernetes-client-loadbalancer</artifactId>
        </dependency>
        <!--/Agregado manualmente-->

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
````

**Nota**
> En `spring initializr` agregamos la dependencia `Cloud Bootstrap (spring-cloud-starter)` √∫nicamente para asegurarnos
> de que desde el inicio el proyecto reconozca la versi√≥n correcta de `Spring Cloud`.
>
> Recordemos que cada versi√≥n de `Spring Boot` est√° asociada a una versi√≥n espec√≠fica de `Spring Cloud`.

### Configuraciones iniciales del Authorization Server

En el archivo `application.yml` del `authorization-server` definimos las configuraciones b√°sicas del microservicio.

````yml
server:
  port: 9000
  error:
    include-message: always

spring:
  application:
    name: authorization-server
````

En la clase principal del proyecto a√±adimos la anotaci√≥n `@EnableDiscoveryClient`, lo que permite al microservicio
registrarse y descubrir otros servicios a trav√©s del mecanismo de descubrimiento de `Spring Cloud Kubernetes`.

````java

@EnableDiscoveryClient
@SpringBootApplication
public class AuthorizationServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthorizationServerApplication.class, args);
    }
}
````

## Configurando el servidor de autorizaci√≥n

Para que nuestro `Authorization Server` funcione correctamente, debemos a√±adir una clase de configuraci√≥n de seguridad.
En ella se definen las reglas de seguridad, los clientes registrados, las claves para firmar tokens JWT, y el emisor de
los mismos.

En nuestro caso hemos realizado algunas adaptaciones importantes, como modificar el `redirectUri(...)` de nuestro
cliente registrado, establecer el `issuer("http://127.0.0.1:9000")` como autoridad emisora de los tokens y algunos
otros cambios m√°s.

````java

@Configuration
public class SecurityConfig {

    @Bean
    @Order(1)
    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {
        OAuth2AuthorizationServerConfigurer authorizationServerConfigurer =
                OAuth2AuthorizationServerConfigurer.authorizationServer();

        http
                .securityMatcher(authorizationServerConfigurer.getEndpointsMatcher())
                .with(authorizationServerConfigurer, (authorizationServer) ->
                        authorizationServer
                                .oidc(Customizer.withDefaults())    // Enable OpenID Connect 1.0
                )
                .authorizeHttpRequests((authorize) ->
                        authorize
                                .anyRequest().authenticated()
                )
                // Redirect to the login page when not authenticated from the
                // authorization endpoint
                .exceptionHandling((exceptions) -> exceptions
                        .defaultAuthenticationEntryPointFor(
                                new LoginUrlAuthenticationEntryPoint("/login"),
                                new MediaTypeRequestMatcher(MediaType.TEXT_HTML)
                        )
                );

        return http.build();
    }

    @Bean
    @Order(2)
    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
        http
                .authorizeHttpRequests((authorize) -> authorize
                        .anyRequest().authenticated()
                )
                .csrf(AbstractHttpConfigurer::disable)
                // Form login handles the redirect to the login page from the
                // authorization server filter chain
                .formLogin(Customizer.withDefaults());

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails admin = User.builder()
                .username("admin")
                .password("{noop}123456")
                .roles("USER", "ADMIN")
                .build();

        UserDetails user = User.builder()
                .username("user")
                .password("{noop}123456")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(admin, user);
    }

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret("{noop}123456")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/authorized")
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

    @Bean
    public JWKSource<SecurityContext> jwkSource() {
        KeyPair keyPair = generateRsaKey();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        RSAKey rsaKey = new RSAKey.Builder(publicKey)
                .privateKey(privateKey)
                .keyID(UUID.randomUUID().toString())
                .build();
        JWKSet jwkSet = new JWKSet(rsaKey);
        return new ImmutableJWKSet<>(jwkSet);
    }

    private static KeyPair generateRsaKey() {
        KeyPair keyPair;
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            keyPair = keyPairGenerator.generateKeyPair();
        } catch (Exception ex) {
            throw new IllegalStateException(ex);
        }
        return keyPair;
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {
        return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
    }

    @Bean
    public AuthorizationServerSettings authorizationServerSettings() {
        return AuthorizationServerSettings.builder().issuer("http://127.0.0.1:9000").build();
    }

}
````

- `Filtros de seguridad (SecurityFilterChain)`: definen c√≥mo se protegen los endpoints del servidor de autorizaci√≥n y
  c√≥mo se maneja el login.
- `Usuarios en memoria`: simplificaci√≥n para pruebas locales.
- `Cliente registrado`: nuestro `gateway-app`, con flujos de autorizaci√≥n (`authorization_code`, `refresh_token`) y
  URIs de redirecci√≥n configuradas.
- `JWK + RSA keys`: claves generadas en memoria para firmar tokens JWT.
- `AuthorizationServerSettings`: define el issuer oficial de los tokens, necesario para validaci√≥n en los clientes.

## Implementando endpoint `/authorized` y `/logout` en Gateway Server

En la configuraci√≥n de seguridad del `authorization-server` (clase `SecurityConfig`), definimos un cliente registrado
que incluye las siguientes URIs:

- http://127.0.0.1:8090/authorized
- http://127.0.0.1:8090/logout

Estas direcciones corresponden al `gateway-server`, por lo que ahora debemos implementarlas all√≠.

El prop√≥sito de cada una es el siguiente:

- `/authorized`: ser√° el punto de redirecci√≥n donde el Authorization Server enviar√° el authorization_code una vez
  completado el proceso de autenticaci√≥n.
- `/logout`: nos servir√° como endpoint de prueba para verificar la redirecci√≥n de cierre de sesi√≥n.

````java

@RestController
public class AppController {

    @GetMapping(path = "/authorized")
    public ResponseEntity<Map<String, String>> authorized(@RequestParam String code) {
        return ResponseEntity.ok(Collections.singletonMap("code", code));
    }

    @PostMapping(path = "/logout")
    public ResponseEntity<Map<String, String>> logout() {
        return ResponseEntity.ok(Collections.singletonMap("logout", "OK"));
    }
}
````

üëâ Con esto dejamos listos los endpoints requeridos por nuestro cliente (`gateway-app`) para poder integrarse
correctamente en el flujo de autorizaci√≥n definido por `OAuth 2.1`.

## Configurando Resource Server y Cliente OAuth2 en el Gateway Server

Nuestro `gateway-server` ser√° el punto central de entrada al sistema, y por ello cumplir√° dos papeles importantes:

1. `Cliente OAuth2 del authorization-server`: inicia el flujo de autenticaci√≥n del usuario (por ejemplo, con
   `spring-security-oauth2-client`). Una vez autenticado, el usuario obtiene un `access token` que le permitir√° consumir
   los microservicios protegidos.

2. `Resource Server`: valida que cada petici√≥n entrante tenga un `access token` v√°lido (enviado en el header
   `Authorization: Bearer <token>`). Para esto consulta la configuraci√≥n publicada por el `authorization-server`
   (`issuer` y claves p√∫blicas `JWKs`).

As√≠ que iniciamos agregando las siguientes dependencias al `pom.xml` del `gateway-server`.

````xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
</dependencies>
````

Luego, vamos al `application.yml` del `gateway-server` para configurar nuestro servidor gateway como
`cliente de OAuth2` y como `servidor de recursos`.

````yml
spring:
  application:
    name: gateway-server
  security:
    oauth2:
      # --- Resource Server ---
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
      # --- OAuth2 Client ---
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

Las configuraciones anteriores muestran los dos papeles que estar√≠a cumpliendo nuestro `gateway-server`, veamos uno por
uno.

### 1. Como Resource Server

El gateway valida los `JWT` emitidos por el `Authorization Server`, asegurando que las rutas expuestas est√©n protegidas:

````yml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
````

### 2. Como OAuth2 Client

Aqu√≠ registramos el cliente (`gateway-app`) que participa en el flujo de autorizaci√≥n y recibe tokens desde el
`Authorization Server`:

````yml
spring:
  security:
    oauth2:
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

üëâ Con esta configuraci√≥n, el `gateway-server` ya queda listo para ser la puerta de entrada segura, manejando tanto
la autenticaci√≥n de usuarios como la validaci√≥n de tokens en cada petici√≥n a los microservicios.

## Configurando clase Resource Server Security Endpoint

Ahora necesitamos implementar la clase `SecurityConfig` en el `gateway-server`, que se encargar√° de proteger las rutas
expuestas y aplicar las reglas de autorizaci√≥n correspondientes.

> üìå `Importante`: nuestro `gateway-server` trabaja con programaci√≥n reactiva (`Spring WebFlux`), por lo que la
> configuraci√≥n de seguridad se realiza usando `ServerHttpSecurity` en lugar de `HttpSecurity`
> (que se usa en aplicaciones servlet).

````java

@Configuration
public class SecurityConfig {
    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .authorizeExchange(authorize -> authorize
                        .pathMatchers("/authorized", "/logout").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/courses", "/api/v1/users", "/api/v1/users/info").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/courses/{courseId}", "/api/v1/users/{userId}").hasAnyRole("ADMIN", "USER")
                        .pathMatchers("/api/v1/courses/**", "/api/v1/users/**").hasRole("ADMIN")
                        .anyExchange().authenticated()
                )
                .cors(ServerHttpSecurity.CorsSpec::disable)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .oauth2Login(Customizer.withDefaults())
                .oauth2Client(Customizer.withDefaults())
                .oauth2ResourceServer(oauth2ResourceServer ->
                        oauth2ResourceServer.jwt(Customizer.withDefaults()));
        return http.build();
    }
}
````

- Se deshabilita CORS en este ejemplo (aunque en producci√≥n suele configurarse) dado que no tenemos un frontEnd.
- `NoOpServerSecurityContextRepository`: evita persistencia de contexto de seguridad en el servidor (`stateless`).
- Se habilitan los tres componentes de seguridad: `OAuth2 Login`, `OAuth2 Client` y `Resource Server` con JWT.

üëâ Con esto, el `gateway-server` ya puede distinguir qu√© rutas son p√∫blicas y cu√°les est√°n protegidas seg√∫n rol y
autenticaci√≥n v√≠a tokens JWT.

## Registrando los claims roles al JWT

Hasta este punto, ya tenemos nuestro `Authorization Server` emitiendo tokens v√°lidos. Sin embargo, necesitamos que el
token incluya tambi√©n la informaci√≥n de los `roles del usuario`, para que el `gateway-server` pueda aplicarlos en sus
reglas de autorizaci√≥n.

1. `Personalizando el JWT en el Authorization Server`

Agregamos un `@Bean` de tipo `OAuth2TokenCustomizer<JwtEncodingContext>` en la clase `SecurityConfig` del
`authorization-server`. Con esto, interceptamos el proceso de construcci√≥n del token y podemos a√±adir claims
personalizados, en este caso, los `roles` del usuario autenticado.

````java

@Configuration
public class SecurityConfig {

    /* code */

    @Bean
    public OAuth2TokenCustomizer<JwtEncodingContext> tokenCustomizer() {
        return context -> {
            Authentication principal = context.getPrincipal();
            Set<String> roles = principal.getAuthorities().stream()
                    .map(GrantedAuthority::getAuthority)
                    .collect(Collectors.toSet());

            if (context.getTokenType().getValue().equals("access_token")) {
                context.getClaims()
                        .claim("roles", roles)
                        .claim("token_type", "Access Token")
                        .build();
            }

            if (context.getTokenType().getValue().equals("id_token")) {
                context.getClaims()
                        .claim("roles", roles)
                        .claim("token_type", "Id Token")
                        .build();
            }
        };
    }
}
````

Con esta configuraci√≥n, cada vez que el servidor emita un `access_token` o un `id_token`, a√±adir√° en el payload los
claims personalizados: `roles` y `token_type`.

2. `Usando los roles en el Gateway Server`

Ahora que los tokens incluyen la informaci√≥n de los roles, debemos indicarle al `gateway-server` c√≥mo interpretar esos
claims y convertirlos en autoridades (`GrantedAuthority`) que ser√°n utilizadas por `Spring Security` en las reglas de
autorizaci√≥n.

Para ello, personalizamos el `JwtAuthenticationConverter` en la configuraci√≥n de seguridad del gateway:

````java

@Configuration
public class SecurityConfig {
    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .authorizeExchange(authorize -> authorize
                        .pathMatchers("/authorized", "/logout").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/courses", "/api/v1/users", "/api/v1/users/info").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/courses/{courseId}", "/api/v1/users/{userId}").hasAnyRole("ADMIN", "USER")
                        .pathMatchers("/api/v1/courses/**", "/api/v1/users/**").hasRole("ADMIN")
                        .anyExchange().authenticated()
                )
                .cors(ServerHttpSecurity.CorsSpec::disable)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .oauth2Login(Customizer.withDefaults())
                .oauth2Client(Customizer.withDefaults())
                .oauth2ResourceServer(oauth2ResourceServer ->
                        oauth2ResourceServer.jwt(jwt -> {
                            jwt.jwtAuthenticationConverter(source -> {
                                Collection<String> roles = source.getClaimAsStringList("roles");
                                Collection<GrantedAuthority> authorities = roles.stream()
                                        .map(SimpleGrantedAuthority::new)
                                        .collect(Collectors.toSet());

                                return Mono.just(new JwtAuthenticationToken(source, authorities));
                            });
                        }));
        return http.build();
    }
}
````

De esta forma, los claims `roles` incluidos en el token JWT se traducen a `GrantedAuthority`, y ya podemos usar
anotaciones o reglas como `.hasRole("ADMIN")` o `.hasAnyRole("ADMIN", "USER")` en nuestro gateway para proteger los
endpoints.

üëâ Con esto, logramos que el `authorization-server` enriquezca el JWT con roles, y que el `gateway-server` sea capaz
de consumirlos y aplicarlos en sus reglas de autorizaci√≥n.

