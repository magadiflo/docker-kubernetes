# Sección 20: Kubernetes: Security JWT con OAuth 2.1

> En esta sección nos apoyaremos en gran medida en la documentación que elaboramos previamente para el curso
> `Microservicios Spring Boot, Spring Cloud Netflix Eureka`
> [ver (sección 10)](https://github.com/magadiflo/microservices-project/blob/main/10.spring_authorization_server_oauth_2.1.md),
> donde también implementamos un `Servidor de Autorización` con `OAuth 2.1` y que se encuentra documentado en detalle.
>
> La diferencia principal es que en este curso —`Microservicios: Guía Completa de Docker & Kubernetes`—
> el tutor utiliza como `cliente y servidor de recursos` al microservicio de `usuarios`, mientras que en el curso
> anterior empleamos como `cliente y servidor de recursos` al `gateway-server`.
>
> Finalmente, en mi caso, optaré también por utilizar al `gateway-server` como `cliente y servidor de recursos`.

---

## Creando microservicio Spring Authorization Server (OAuth 2.1)

Iniciaremos creando un nuevo microservicio llamado `authorization-server` utilizando
[Spring Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.5.5&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=authorization-server&name=authorization-server&description=Authorization%20Server&packageName=dev.magadiflo.authorization.server.app&dependencies=web,lombok,security,oauth2-authorization-server,actuator,cloud-starter).

Al ser `Spring Authorization Server` una capa construida por encima de `Spring Security`, necesitamos añadir también
esta dependencia, al igual que `Spring Web` para el manejo de solicitudes y respuestas HTTP que utiliza
`Spring Authorization Server` para realizar las tareas de autenticación y autorización.

````xml
<!--Spring Boot 3.5.5-->
<!--Spring Cloud Version 2025.0.0-->
<!--Java 21-->
<project>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-authorization-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter</artifactId>
        </dependency>
        <!--Agregado manualmente-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-kubernetes-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-kubernetes-client-loadbalancer</artifactId>
        </dependency>
        <!--/Agregado manualmente-->

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
````

**Nota**
> En `spring initializr` agregamos la dependencia `Cloud Bootstrap (spring-cloud-starter)` únicamente para asegurarnos
> de que desde el inicio el proyecto reconozca la versión correcta de `Spring Cloud`.
>
> Recordemos que cada versión de `Spring Boot` está asociada a una versión específica de `Spring Cloud`.

### Configuraciones iniciales del Authorization Server

En el archivo `application.yml` del `authorization-server` definimos las configuraciones básicas del microservicio.

````yml
server:
  port: 9000
  error:
    include-message: always

spring:
  application:
    name: authorization-server
````

En la clase principal del proyecto añadimos la anotación `@EnableDiscoveryClient`, lo que permite al microservicio
registrarse y descubrir otros servicios a través del mecanismo de descubrimiento de `Spring Cloud Kubernetes`.

````java

@EnableDiscoveryClient
@SpringBootApplication
public class AuthorizationServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthorizationServerApplication.class, args);
    }
}
````

## Configurando el servidor de autorización

Para que nuestro `Authorization Server` funcione correctamente, debemos añadir una clase de configuración de seguridad.
En ella se definen las reglas de seguridad, los clientes registrados, las claves para firmar tokens JWT, y el emisor de
los mismos.

En nuestro caso hemos realizado algunas adaptaciones importantes, como modificar el `redirectUri(...)` de nuestro
cliente registrado, establecer el `issuer("http://127.0.0.1:9000")` como autoridad emisora de los tokens y algunos
otros cambios más.

````java

@Configuration
public class SecurityConfig {

    @Bean
    @Order(1)
    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {
        OAuth2AuthorizationServerConfigurer authorizationServerConfigurer =
                OAuth2AuthorizationServerConfigurer.authorizationServer();

        http
                .securityMatcher(authorizationServerConfigurer.getEndpointsMatcher())
                .with(authorizationServerConfigurer, (authorizationServer) ->
                        authorizationServer
                                .oidc(Customizer.withDefaults())    // Enable OpenID Connect 1.0
                )
                .authorizeHttpRequests((authorize) ->
                        authorize
                                .anyRequest().authenticated()
                )
                // Redirect to the login page when not authenticated from the
                // authorization endpoint
                .exceptionHandling((exceptions) -> exceptions
                        .defaultAuthenticationEntryPointFor(
                                new LoginUrlAuthenticationEntryPoint("/login"),
                                new MediaTypeRequestMatcher(MediaType.TEXT_HTML)
                        )
                );

        return http.build();
    }

    @Bean
    @Order(2)
    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
        http
                .authorizeHttpRequests((authorize) -> authorize
                        .anyRequest().authenticated()
                )
                .csrf(AbstractHttpConfigurer::disable)
                // Form login handles the redirect to the login page from the
                // authorization server filter chain
                .formLogin(Customizer.withDefaults());

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails admin = User.builder()
                .username("admin")
                .password("{noop}123456")
                .roles("USER", "ADMIN")
                .build();

        UserDetails user = User.builder()
                .username("user")
                .password("{noop}123456")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(admin, user);
    }

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret("{noop}123456")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/authorized")
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

    @Bean
    public JWKSource<SecurityContext> jwkSource() {
        KeyPair keyPair = generateRsaKey();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        RSAKey rsaKey = new RSAKey.Builder(publicKey)
                .privateKey(privateKey)
                .keyID(UUID.randomUUID().toString())
                .build();
        JWKSet jwkSet = new JWKSet(rsaKey);
        return new ImmutableJWKSet<>(jwkSet);
    }

    private static KeyPair generateRsaKey() {
        KeyPair keyPair;
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            keyPair = keyPairGenerator.generateKeyPair();
        } catch (Exception ex) {
            throw new IllegalStateException(ex);
        }
        return keyPair;
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {
        return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
    }

    @Bean
    public AuthorizationServerSettings authorizationServerSettings() {
        return AuthorizationServerSettings.builder().issuer("http://127.0.0.1:9000").build();
    }

}
````

- `Filtros de seguridad (SecurityFilterChain)`: definen cómo se protegen los endpoints del servidor de autorización y
  cómo se maneja el login.
- `Usuarios en memoria`: simplificación para pruebas locales.
- `Cliente registrado`: nuestro `gateway-app`, con flujos de autorización (`authorization_code`, `refresh_token`) y
  URIs de redirección configuradas.
- `JWK + RSA keys`: claves generadas en memoria para firmar tokens JWT.
- `AuthorizationServerSettings`: define el issuer oficial de los tokens, necesario para validación en los clientes.

## Implementando endpoint `/authorized` y `/logout` en Gateway Server

En la configuración de seguridad del `authorization-server` (clase `SecurityConfig`), definimos un cliente registrado
que incluye las siguientes URIs:

- http://127.0.0.1:8090/authorized
- http://127.0.0.1:8090/logout

Estas direcciones corresponden al `gateway-server`, por lo que ahora debemos implementarlas allí.

El propósito de cada una es el siguiente:

- `/authorized`: será el punto de redirección donde el Authorization Server enviará el authorization_code una vez
  completado el proceso de autenticación.
- `/logout`: nos servirá como endpoint de prueba para verificar la redirección de cierre de sesión.

````java

@RestController
public class AppController {

    @GetMapping(path = "/authorized")
    public ResponseEntity<Map<String, String>> authorized(@RequestParam String code) {
        return ResponseEntity.ok(Collections.singletonMap("code", code));
    }

    @PostMapping(path = "/logout")
    public ResponseEntity<Map<String, String>> logout() {
        return ResponseEntity.ok(Collections.singletonMap("logout", "OK"));
    }
}
````

👉 Con esto dejamos listos los endpoints requeridos por nuestro cliente (`gateway-app`) para poder integrarse
correctamente en el flujo de autorización definido por `OAuth 2.1`.

## Configurando Resource Server y Cliente OAuth2 en el Gateway Server

Nuestro `gateway-server` será el punto central de entrada al sistema, y por ello cumplirá dos papeles importantes:

1. `Cliente OAuth2 del authorization-server`: inicia el flujo de autenticación del usuario (por ejemplo, con
   `spring-security-oauth2-client`). Una vez autenticado, el usuario obtiene un `access token` que le permitirá consumir
   los microservicios protegidos.

2. `Resource Server`: valida que cada petición entrante tenga un `access token` válido (enviado en el header
   `Authorization: Bearer <token>`). Para esto consulta la configuración publicada por el `authorization-server`
   (`issuer` y claves públicas `JWKs`).

Así que iniciamos agregando las siguientes dependencias al `pom.xml` del `gateway-server`.

````xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
</dependencies>
````

Luego, vamos al `application.yml` del `gateway-server` para configurar nuestro servidor gateway como
`cliente de OAuth2` y como `servidor de recursos`.

````yml
spring:
  application:
    name: gateway-server
  security:
    oauth2:
      # --- Resource Server ---
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
      # --- OAuth2 Client ---
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

Las configuraciones anteriores muestran los dos papeles que estaría cumpliendo nuestro `gateway-server`, veamos uno por
uno.

### 1. Como Resource Server

El gateway valida los `JWT` emitidos por el `Authorization Server`, asegurando que las rutas expuestas estén protegidas:

````yml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
````

### 2. Como OAuth2 Client

Aquí registramos el cliente (`gateway-app`) que participa en el flujo de autorización y recibe tokens desde el
`Authorization Server`:

````yml
spring:
  security:
    oauth2:
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

👉 Con esta configuración, el `gateway-server` ya queda listo para ser la puerta de entrada segura, manejando tanto
la autenticación de usuarios como la validación de tokens en cada petición a los microservicios.

## Configurando clase Resource Server Security Endpoint

Ahora necesitamos implementar la clase `SecurityConfig` en el `gateway-server`, que se encargará de proteger las rutas
expuestas y aplicar las reglas de autorización correspondientes.

> 📌 `Importante`: nuestro `gateway-server` trabaja con programación reactiva (`Spring WebFlux`), por lo que la
> configuración de seguridad se realiza usando `ServerHttpSecurity` en lugar de `HttpSecurity`
> (que se usa en aplicaciones servlet).

````java

@Configuration
public class SecurityConfig {
    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .authorizeExchange(authorize -> authorize
                        .pathMatchers("/authorized", "/logout").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/courses", "/api/v1/users", "/api/v1/users/info").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/courses/{courseId}", "/api/v1/users/{userId}").hasAnyRole("ADMIN", "USER")
                        .pathMatchers("/api/v1/courses/**", "/api/v1/users/**").hasRole("ADMIN")
                        .anyExchange().authenticated()
                )
                .cors(ServerHttpSecurity.CorsSpec::disable)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .oauth2Login(Customizer.withDefaults())
                .oauth2Client(Customizer.withDefaults())
                .oauth2ResourceServer(oauth2ResourceServer ->
                        oauth2ResourceServer.jwt(Customizer.withDefaults()));
        return http.build();
    }
}
````

- Se deshabilita CORS en este ejemplo (aunque en producción suele configurarse) dado que no tenemos un frontEnd.
- `NoOpServerSecurityContextRepository`: evita persistencia de contexto de seguridad en el servidor (`stateless`).
- Se habilitan los tres componentes de seguridad: `OAuth2 Login`, `OAuth2 Client` y `Resource Server` con JWT.

👉 Con esto, el `gateway-server` ya puede distinguir qué rutas son públicas y cuáles están protegidas según rol y
autenticación vía tokens JWT.

## Registrando los claims roles al JWT

Hasta este punto, ya tenemos nuestro `Authorization Server` emitiendo tokens válidos. Sin embargo, necesitamos que el
token incluya también la información de los `roles del usuario`, para que el `gateway-server` pueda aplicarlos en sus
reglas de autorización.

1. `Personalizando el JWT en el Authorization Server`

Agregamos un `@Bean` de tipo `OAuth2TokenCustomizer<JwtEncodingContext>` en la clase `SecurityConfig` del
`authorization-server`. Con esto, interceptamos el proceso de construcción del token y podemos añadir claims
personalizados, en este caso, los `roles` del usuario autenticado.

````java

@Configuration
public class SecurityConfig {

    /* code */

    @Bean
    public OAuth2TokenCustomizer<JwtEncodingContext> tokenCustomizer() {
        return context -> {
            Authentication principal = context.getPrincipal();
            Set<String> roles = principal.getAuthorities().stream()
                    .map(GrantedAuthority::getAuthority)
                    .collect(Collectors.toSet());

            if (context.getTokenType().getValue().equals("access_token")) {
                context.getClaims()
                        .claim("roles", roles)
                        .claim("token_type", "Access Token")
                        .build();
            }

            if (context.getTokenType().getValue().equals("id_token")) {
                context.getClaims()
                        .claim("roles", roles)
                        .claim("token_type", "Id Token")
                        .build();
            }
        };
    }
}
````

Con esta configuración, cada vez que el servidor emita un `access_token` o un `id_token`, añadirá en el payload los
claims personalizados: `roles` y `token_type`.

2. `Usando los roles en el Gateway Server`

Ahora que los tokens incluyen la información de los roles, debemos indicarle al `gateway-server` cómo interpretar esos
claims y convertirlos en autoridades (`GrantedAuthority`) que serán utilizadas por `Spring Security` en las reglas de
autorización.

Para ello, personalizamos el `JwtAuthenticationConverter` en la configuración de seguridad del gateway:

````java

@Configuration
public class SecurityConfig {
    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .authorizeExchange(authorize -> authorize
                        .pathMatchers("/authorized", "/logout").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/courses", "/api/v1/users", "/api/v1/users/info").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/courses/{courseId}", "/api/v1/users/{userId}").hasAnyRole("ADMIN", "USER")
                        .pathMatchers("/api/v1/courses/**", "/api/v1/users/**").hasRole("ADMIN")
                        .anyExchange().authenticated()
                )
                .cors(ServerHttpSecurity.CorsSpec::disable)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .oauth2Login(Customizer.withDefaults())
                .oauth2Client(Customizer.withDefaults())
                .oauth2ResourceServer(oauth2ResourceServer ->
                        oauth2ResourceServer.jwt(jwt -> {
                            jwt.jwtAuthenticationConverter(source -> {
                                Collection<String> roles = source.getClaimAsStringList("roles");
                                Collection<GrantedAuthority> authorities = roles.stream()
                                        .map(SimpleGrantedAuthority::new)
                                        .collect(Collectors.toSet());

                                return Mono.just(new JwtAuthenticationToken(source, authorities));
                            });
                        }));
        return http.build();
    }
}
````

De esta forma, los claims `roles` incluidos en el token JWT se traducen a `GrantedAuthority`, y ya podemos usar
anotaciones o reglas como `.hasRole("ADMIN")` o `.hasAnyRole("ADMIN", "USER")` en nuestro gateway para proteger los
endpoints.

👉 Con esto, logramos que el `authorization-server` enriquezca el JWT con roles, y que el `gateway-server` sea capaz
de consumirlos y aplicarlos en sus reglas de autorización.

