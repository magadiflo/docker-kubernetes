# Sección 06: Docker - Introducción

---

## [¿Qué es docker?](https://docs.docker.com/get-started/docker-overview/)

`Docker` es una plataforma abierta para desarrollar, enviar y ejecutar aplicaciones. `Docker` le permite separar sus
aplicaciones de su infraestructura para que pueda entregar software rápidamente. Con `Docker`, puede administrar su
infraestructura de la misma manera que administra sus aplicaciones. Al aprovechar las metodologías de `Docker` para
enviar, probar e implementar código, puede reducir significativamente la demora entre la escritura del código y su
ejecución en producción.

## La Plataforma Docker

`Docker` ofrece la posibilidad de empaquetar y ejecutar una aplicación en un entorno ligeramente aislado llamado
`contenedor`. El aislamiento y la seguridad le permiten ejecutar muchos contenedores simultáneamente en un host
determinado. `Los contenedores son livianos y contienen todo lo necesario para ejecutar la aplicación`, por lo que no
necesita depender de lo que esté instalado en el host. Puede compartir contenedores mientras trabaja y estar seguro de
que todos con quienes comparte obtienen el mismo contenedor que funciona de la misma manera.

`Docker` ofrece herramientas y una plataforma para administrar el ciclo de vida de sus contenedores:

- Desarrolle su aplicación y sus componentes de soporte utilizando contenedores.
- El `contenedor` se convierte en la unidad para distribuir y probar su aplicación.
- Cuando esté listo, implemente su aplicación en su entorno de producción, como un contenedor o un servicio orquestado.
  Esto funciona de la misma manera independientemente de si su entorno de producción es un centro de datos local, un
  proveedor de nube o un híbrido de los dos.

## Arquitectura de Docker

`Docker` utiliza una arquitectura `cliente-servidor`. El `cliente de Docker` se comunica con el `demonio de Docker`,
que se encarga de la tarea pesada de crear, ejecutar y distribuir los contenedores de Docker. El `cliente` y el
`demonio de Docker` pueden ejecutarse en el mismo sistema, o puedes conectar un `cliente de Docker` a un
`demonio de Docker remoto`. El `cliente` y el `demonio de Docker` se comunican mediante una `API REST`, a través de
sockets UNIX o una interfaz de red. Otro cliente de Docker es `Docker Compose`, que te permite trabajar con
aplicaciones que constan de un `conjunto de contenedores`.

![01.png](assets/section-06/01.png)

## El Demonio de Docker

El `demonio de Docker` `(dockerd)` escucha las solicitudes de la `API de Docker` y administra `objetos de Docker`, como
`imágenes`, `contenedores`, `redes` y `volúmenes`. Un demonio también puede comunicarse con otros demonios para
administrar los servicios de Docker.

## El Cliente Docker

El `cliente Docker` `(docker)` es la forma principal en la que muchos usuarios de Docker interactúan con Docker. Cuando
se utilizan comandos como `docker container run`, el cliente envía estos comandos a `dockerd`, que los ejecuta. El
comando docker utiliza la API de Docker. El cliente Docker puede comunicarse con más de un demonio.

## Registros de Docker (Docker registries)

Un registro de Docker `almacena imágenes de Docker`. `Docker Hub` es un registro público que cualquiera puede usar y
`Docker` busca imágenes en `Docker Hub de forma predeterminada`. Incluso puedes ejecutar tu propio registro privado.

Cuando usas los comandos `docker pull` o `docker run`, `Docker` extrae las imágenes necesarias de tu registro
configurado. Cuando usas el comando `docker push`, `Docker` envía tu imagen a tu registro configurado.

## Imágenes

Una `imagen` es una plantilla de solo lectura con instrucciones para crear un `contenedor Docker`. A menudo, una
`imagen` se basa en otra `imagen`, con alguna personalización adicional. Por ejemplo, puede crear una imagen que
se base en la imagen de Ubuntu, pero que instale el servidor web Apache y su aplicación, así como los detalles
de configuración necesarios para que su aplicación se ejecute.

Puede crear sus propias imágenes o puede utilizar únicamente las creadas por otros y publicadas en un registro.
`Para crear su propia imagen`, debe crear un `Dockerfile` con una sintaxis simple para definir los pasos necesarios
para crear la imagen y ejecutarla. `Cada instrucción en un Dockerfile crea una capa en la imagen`. Cuando cambia el
`Dockerfile` y reconstruye la imagen, solo se reconstruyen las capas que han cambiado. Esto es parte de lo que hace
que las imágenes sean tan livianas, pequeñas y rápidas, en comparación con otras tecnologías de virtualización.

## Contenedores

`Un contenedor es una instancia ejecutable de una imagen`. Puede crear, iniciar, detener, mover o eliminar un
contenedor mediante la API o la CLI de Docker. Puede conectar un contenedor a una o más redes, adjuntarle
almacenamiento o incluso crear una nueva imagen en función de su estado actual.

De manera predeterminada, `un contenedor está relativamente bien aislado de otros contenedores y de su máquina host`.
Puede controlar el grado de aislamiento de la red, el almacenamiento u otros subsistemas subyacentes de un
contenedor respecto de otros contenedores o de la máquina host.

`Un contenedor se define por su imagen`, así como por las opciones de configuración que le proporcione al crearlo
o iniciarlo. Cuando se elimina un contenedor, desaparecen todos los cambios en su estado que no se almacenan en el
almacenamiento persistente.

## Genera archivo jar para dockerizar

Para dockerizar nuestra aplicación de `Spring Boot` necesitamos generar el empaquetado `jar`. Este empaquetado lo
referenciaremos luego en el archivo `Dockerfile` para generar la imagen de nuestra aplicación.

### Genera archivo jar de user-service

Iniciamos generando el `jar` del `user-service` de manera manual. Posteriormente, para ver que el `jar` funciona, lo
ejecutaremos mediante la línea de comando. Así que, para este primer ejemplo, nos posicionamos en la raíz del
microservicio `user-service` y ejecutamos el siguiente comando.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes\business-domain\user-service (feature/section-6)
$ mvnw clean package
````

### Importante

> Debemos tener levantado la base de datos que está usando ese microservicio, ya que cuando se construya
> el `jar` requerirá realizar los test y al realizar los test ejecutará la aplicación y como tenemos la dependencia
> de `Spring Data JPA`, tratará de establecer una conexión a la base de datos. Si no tenemos levantado la base de datos
> nos mostrará un error y no podremos empaquetar la aplicación.
>
> Si queremos saltarnos los test podemos ejecutar:
>
> `mvnw clean package -DskipTests`
>
> En mi caso sí tengo levantado la base de datos así que ejecutaré el comando sin el `-DskipTests`.

### Donde

- `clean`, borra todos los archivos temporales y compilados que se encuentran en el directorio `/target`, incluidos
  archivos `.class`, `JARs` generados previamente, y otros artefactos generados por una compilación anterior. Es como
  un `reseteo` del proyecto para asegurar que la próxima compilación se realice desde cero, sin interferencia de
  artefactos antiguos. En otras palabras, borra el directorio `/target` que contiene todo lo descrito.


- `package`, compila el código y empaqueta el proyecto en un archivo `jar` dentro del directorio `/target`.

Una vez finalizado el comando anterior, veremos en la raíz del microservicio `user-service` el directorio `/target`
y dentro él, el archivo `jar` compilado `user-service-0.0.1-SNAPSHOT.jar`.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes\business-domain\user-service\target (feature/section-6)
$ ls -l
total 64528
drwxr-xr-x 1 magadiflo 197121        0 May 19 23:26 classes/
drwxr-xr-x 1 magadiflo 197121        0 May 19 23:26 generated-sources/
drwxr-xr-x 1 magadiflo 197121        0 May 19 23:26 generated-test-sources/
drwxr-xr-x 1 magadiflo 197121        0 May 19 23:26 maven-archiver/
drwxr-xr-x 1 magadiflo 197121        0 May 19 23:26 maven-status/
drwxr-xr-x 1 magadiflo 197121        0 May 19 23:26 surefire-reports/
drwxr-xr-x 1 magadiflo 197121        0 May 19 23:26 test-classes/
-rw-r--r-- 1 magadiflo 197121 66044541 May 19 23:26 user-service-0.0.1-SNAPSHOT.jar
-rw-r--r-- 1 magadiflo 197121    24941 May 19 23:26 user-service-0.0.1-SNAPSHOT.jar.original
````

### Ejecuta archivo jar de user-service desde línea de comandos

Supongamos que el `jar` generado anteriormente lo hemos llevado a una máquina remota y lo queremos levantar. Para eso
nos posicionaremos mediante el `cmd` en el directorio donde hayamos puesto el `jar` y ejecutaremos el comando:

````bash
$ java -jar user-service-0.0.1-SNAPSHOT.jar
````

A continuación vemos que nuestra aplicación se levanta sin problemas.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-6)
λ java -jar .\business-domain\user-service\target\user-service-0.0.1-SNAPSHOT.jar

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.4.5)

2025-05-19T23:36:51.792-05:00  INFO 9440 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Starting UserServiceApplication v0.0.1-SNAPSHOT using Java 21.0.6 with PID 9440 (D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes\business-domain\user-service\target\user-service-0.0.1-SNAPSHOT.jar started by magadiflo in D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes)
2025-05-19T23:36:51.795-05:00 DEBUG 9440 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Running with Spring Boot v3.4.5, Spring v6.2.6
2025-05-19T23:36:51.796-05:00  INFO 9440 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : No active profile set, falling back to 1 default profile: "default"
2025-05-19T23:36:53.100-05:00  INFO 9440 --- [user-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-05-19T23:36:53.159-05:00  INFO 9440 --- [user-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 47 ms. Found 1 JPA repository interface.
2025-05-19T23:36:53.356-05:00  INFO 9440 --- [user-service] [           main] o.s.cloud.context.scope.GenericScope     : BeanFactory id=91540a6b-3294-3658-b380-dfb1c22ae3d2
2025-05-19T23:36:54.126-05:00  INFO 9440 --- [user-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8001 (http)
2025-05-19T23:36:54.164-05:00  INFO 9440 --- [user-service] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2025-05-19T23:36:54.165-05:00  INFO 9440 --- [user-service] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.40]
2025-05-19T23:36:54.205-05:00  INFO 9440 --- [user-service] [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2025-05-19T23:36:54.206-05:00  INFO 9440 --- [user-service] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 2344 ms
2025-05-19T23:36:54.599-05:00  INFO 9440 --- [user-service] [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2025-05-19T23:36:54.671-05:00  INFO 9440 --- [user-service] [           main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 6.6.13.Final
2025-05-19T23:36:54.714-05:00  INFO 9440 --- [user-service] [           main] o.h.c.internal.RegionFactoryInitiator    : HHH000026: Second-level cache disabled
2025-05-19T23:36:55.003-05:00  INFO 9440 --- [user-service] [           main] o.s.o.j.p.SpringPersistenceUnitInfo      : No LoadTimeWeaver setup: ignoring JPA class transformer
2025-05-19T23:36:55.038-05:00  INFO 9440 --- [user-service] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2025-05-19T23:36:55.411-05:00  INFO 9440 --- [user-service] [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@1acc768
2025-05-19T23:36:55.413-05:00  INFO 9440 --- [user-service] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2025-05-19T23:36:55.512-05:00  INFO 9440 --- [user-service] [           main] org.hibernate.orm.connections.pooling    : HHH10001005: Database info:
        Database JDBC URL [Connecting through datasource 'HikariDataSource (HikariPool-1)']
        Database driver: undefined/unknown
        Database version: 8.0.41
        Autocommit mode: undefined/unknown
        Isolation level: undefined/unknown
        Minimum pool size: undefined/unknown
        Maximum pool size: undefined/unknown
2025-05-19T23:36:56.363-05:00  INFO 9440 --- [user-service] [           main] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000489: No JTA platform available (set 'hibernate.transaction.jta.platform' to enable JTA platform integration)
2025-05-19T23:36:56.403-05:00  INFO 9440 --- [user-service] [           main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2025-05-19T23:36:57.029-05:00  WARN 9440 --- [user-service] [           main] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2025-05-19T23:36:57.951-05:00  INFO 9440 --- [user-service] [           main] o.s.b.a.e.web.EndpointLinksResolver      : Exposing 1 endpoint beneath base path '/actuator'
2025-05-19T23:36:58.041-05:00  INFO 9440 --- [user-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8001 (http) with context path '/'
2025-05-19T23:36:58.061-05:00  INFO 9440 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Started UserServiceApplication in 6.965 seconds (process running for 7.571)
````

Realizamos una petición a un endpoint del `user-service` para ver que la aplicación está funcionando.

````bash
$ curl -v http://localhost:8001/api/v1/users/1 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Tue, 20 May 2025 04:38:06 GMT
<
{
  "id": 1,
  "name": "Martin",
  "email": "martin@gmail.com",
  "password": "123456"
}
````

Como observamos, no necesitamos el IDE para ejecutar nuestra aplicación, tan solo generamos el `jar`, lo levantamos
y ya nuestra aplicación estará lista para recibir peticiones. Obviamente, si el `jar` lo llevamos a otra máquina, habrá
que tener instalada las dependencias que requiere nuestra aplicación como, la versión de java, las bases de datos, etc.

La idea ahora es realizar todos los pasos anteriores, pero usando `Docker`, es decir `dockerizar` la aplicación,
configurar una imagen, crear el contenedor, etc.

## Creando el archivo Dockerfile para el user-service

En la raíz del microservicio `user-service` creamos el archivo `Dockerfile` y agregamos las siguientes instrucciones:

````dockerfile
FROM eclipse-temurin:21-jdk-alpine
WORKDIR /app
COPY ./target/*.jar ./app.jar
EXPOSE 8001
CMD ["java", "-jar", "app.jar"]
````

**Donde**

- `FROM eclipse-temurin:21-jdk-alpine`, usaremos como imagen base para nuestra versión `21 de java` la imagen de
  `eclipse-temurin` cuyo `tag` es `21-jdk-alpine`.


- `WORKDIR /app`, crearemos un directorio de trabajo donde colocaremos nuestra aplicación y desde donde trabajaremos,
  no es obligatorio, pero teniendo un directorio de trabajo nos aseguramos de saber exactamente dónde está nuestra
  aplicación y dónde se está ejecutando para que cuando se acceda al contenedor sepamos exactamente dónde buscar.


- `COPY ./target/*.jar ./app.jar`, copiamos el archivo `*.jar` que está en la ruta de nuestra máquina
  local `(./target/*.jar)` hacia la ruta en la imagen `(./app.jar)`.
    - Podría haber colocado en vez de `*.jar` de nuestra ruta de la máquina local, el nombre completo que generamos al
      compilar el proyecto `user-service-0.0.1-SNAPSHOT.jar`, pero como siempre habrá un único archivo que termine con
      extensión `.jar` es que coloco el comodín `*.jar`, de esa manera evito escribir todo el nombre.
    - En el directorio de destino, el archivo `*.jar` que estamos copiando lo vamos a renombrar a `app.jar`.
    - La copia se realizará hacia el `WORKDIR /app` que creamos al inicio, es decir, del `./app.jar` el `.` hace
      referencia al directorio que creamos al inicio `/app`, lo que significa que la copia final quedaría
      en la ruta `/app/app.jar`.


- `EXPOSE 8001`, es a modo de documentación `(opcional)`. La instrucción `EXPOSE` informa a `Docker` que el `contenedor`
  escucha en los puertos de red especificados en tiempo de ejecución. La instrucción `EXPOSE` no publica realmente el
  puerto. **Funciona como un tipo de documentación entre la persona que construye la imagen y la persona que ejecuta el
  contenedor**, sobre qué puertos están destinados a ser publicados.
  `El puerto indicado se refiere al puerto interno del contenedor, no al del host`.


- `CMD ["java", "-jar", "app.jar"]`, se ejecuta por defecto en la raíz del `WORKDIR`, o sea en nuestro caso en
  el directorio `/app`. **Es una instrucción para cuando se construyan los contenedores, no para las imágenes.**
  El propósito principal de un CMD es proporcionar valores por defecto para un contenedor en ejecución.

