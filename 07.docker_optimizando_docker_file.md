# Sección 07: Docker - Optimizando Dockerfile

---

## Crea archivo .dockerignore

````dockerignore
# Ignora todos los archivos y directorios del contexto de construcción
*
# Los siguientes directorios y archivos no deben ser ignorados
!src/
!pom.xml
!.mvn/
!mvnw
````

El archivo `.dockerignore` es un archivo de texto que especifica qué archivos y directorios deben ser ignorados al
construir una imagen de `Docker`. Funciona de manera similar a un archivo `.gitignore` en `Git`, ayudando a excluir
ciertos archivos innecesarios del contexto de construcción (es decir, el conjunto de archivos que `Docker` envía al
daemon de `Docker` para crear una imagen).

Cuando `Docker` construye una imagen, toma todo lo que está en el contexto de construcción y lo envía al daemon para
procesarlo. Sin embargo, algunos archivos no son necesarios para la imagen (como archivos temporales, archivos de
configuración específicos del desarrollador, o incluso código fuente que no es relevante para la construcción de la
imagen). El archivo `.dockerignore` te permite especificar esos archivos o carpetas para reducir el tamaño de la imagen
y mejorar la eficiencia.

## Optimizando Dockerfile

Hasta ahora lo que estamos haciendo para generar la imagen de nuestro proyecto de `Spring Boot` es:

1. Generar manualmente el archivo `jar`.
2. Utilizar ese empaquetado para generar la imagen.

Sin embargo, `¡podemos automatizar ese proceso!`; para eso tenemos que realizar modificaciones en nuestro `Dockerfile`.

````dockerfile
FROM eclipse-temurin:21-jdk-alpine
WORKDIR /app
COPY ./ ./
RUN sed -i -e 's/\r$//' ./mvnw  && ./mvnw clean package -DskipTests
EXPOSE 8001
CMD ["java", "-jar", "./target/user-service-0.0.1-SNAPSHOT.jar"]
````

**Dónde**

- `COPY ./ ./` copia todos los archivos y directorios no ignorados del directorio actual (primer `./`) al directorio de
  trabajo dentro del contenedor (segundo `./` es equivalente a `/app`).
- `RUN sed -i -e 's/\r$//' ./mvnw && ./mvnw clean package -DskipTests`, aquí hay dos bloques separados por el `&&`,
  podría haber colocado cada bloque en una línea cada una con el `RUN`, pero `SonarLint` marca un warning y dice que lo
  coloque en una sola línea separada por `&&`.

**Desglose del comando:**

- `sed -i -e 's/\r$//' ./mvnw`:
    - `Descripción`: El comando `sed` se utiliza para eliminar los caracteres de retorno de carro (`\r`, que son típicos
      en sistemas Windows) del archivo `mvnw`.
    - `Propósito`: Evitar problemas de compatibilidad en sistemas basados en `Unix/Linux` (como `Alpine`) cuando se
      ejecuta el script `mvnw`.
    - `-i`: Es una opción que le indica a sed que realice cambios en el archivo en su lugar, es decir, modificará el
      archivo `mvnw` directamente.
    - `-e`: Indica que se proporcionará una expresión de script a `sed`.
    - `'s/\r$//'`: Es la expresión de script que busca y reemplaza el retorno de carro (`\r`) al final de cada línea
      del archivo por una cadena vacía, es decir, lo elimina.
    - `./mvnw`: Es el archivo en el que se realizará la modificación. En este caso, se asume que el archivo `mvnw` está
      en el directorio actual (`./` que es equivalente al `WORKDIR /app`).

  > Este comando es útil cuando los archivos se han creado o editado en un sistema Windows o en un entorno que
  > utiliza retornos de carro, y se deben utilizar en un entorno Linux o Unix donde se espera el carácter de nueva
  > línea para indicar el final de una línea. Al eliminar los caracteres de retorno de carro, se asegura que el
  > archivo sea compatible con el sistema en el que se está utilizando.

- `./mvnw clean package -DskipTests`, este comando ejecuta `Maven` (a través del wrapper `mvnw`) para compilar y
  empaquetar el proyecto. Este comando se ejecuta en la raíz del directorio de trabajo `WORKDIR /app`.


- `EXPOSE 8001`, la instrucción `EXPOSE` en un `Dockerfile` tiene como propósito informar que un `contenedor` utiliza un
  puerto específico para recibir conexiones. Es una especie de `documentación` dentro del Dockerfile que indica a otros
  usuarios qué `puerto expone tu aplicación dentro del contenedor`. En nuestro caso la aplicación de Spring Boot tiene
  configurado el puerto `server.port=8001`, eso significa que la aplicación estará escuchando en el puerto `8001` dentro
  del contenedor. En este caso, debemos `exponer` ese mismo puerto en el `Dockerfile`. Esto asegura que el puerto `8001`
  esté documentado y visible en el contenedor para quien necesite mapearlo o conectarse.
  > Al final de este README hablaré un poco más sobre el EXPOSE definido en el Dockerfile y la opción `-P` o
  > `--publish-all`.


- `CMD ["java", "-jar", "./target/user-service-0.0.1-SNAPSHOT.jar"]`, este comando es usado cuando se levanta el
  contenedor.

Del punto anterior, es muy importante colocar el nombre de archivo `jar` generado en la compilación.
Por defecto, el nombre del jar para ese microservicio es `user-service-0.0.1-SNAPSHOT.jar`. Ahora, notar que
estamos iniciando con `./target/...`, eso significa que cuando se compiló el `jar` dentro del `WORKDIR /app`, se creó
el directorio `/target` y dentro de él se generó el  `jar`.

En la sección anterior tuvimos que posicionarnos, mediante la línea de comando, en la raíz del microservicio
`user-service` para ejecutar el comando de construcción de la imagen, dado que en dicha raíz se encuentra el archivo
`Dockefile`.

En esta oportunidad, para variar la manera de construir la imagen, nos posicionaremos en la raíz del proyecto general,
en ese sentido, debemos especificar la ruta del contexto de construcción de la imagen, es decir, especificarle dónde
se encuentra el `Dockerfile`.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-7)                            
$ docker image build -t user-service .\business-domain\user-service -f .\business-domain\user-service\Dockerfile                      
[+] Building 49.0s (10/10) FINISHED                                                                                                   
 => [internal] load build definition from Dockerfile                                                                                  
 => => transferring dockerfile: 249B                                                                                                  
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                      
 => [auth] library/eclipse-temurin:pull token for registry-1.docker.io                                                                
 => [internal] load .dockerignore                                                                                                     
 => => transferring context: 214B                                                                                                     
 => [1/4] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => => resolve docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => => sha256:370873e386b22025c28fa9279cae3a1cd222ac243a221679834774d0620fa7f3 157.86MB / 157.86MB                                    
 => => extracting sha256:370873e386b22025c28fa9279cae3a1cd222ac243a221679834774d0620fa7f3                                             
 => => extracting sha256:5bb1def311668c63d0555cfb562a2dc952ee1c071f75d5f1805f7e6383c36365                                             
 => => extracting sha256:aa49a465cc24db7df330480bc605cd2f13f785972d1645eeff0397c467e58380                                             
 => [internal] load build context                                                                                                     
 => => transferring context: 2.98kB                                                                                                   
 => [2/4] WORKDIR /app                                                                                                                
 => [3/4] COPY ./ ./                                                                                                                  
 => [4/4] RUN sed -i -e 's/\r$//' ./mvnw  && ./mvnw clean package -DskipTests                                                         
 => exporting to image                                                                                                                
 => => exporting layers                                                                                                               
 => => exporting manifest sha256:aebca6e49a35052f8039e4681a67e692fbd9567eb5924a5398ba1da4b2077d78                                     
 => => exporting config sha256:f62b07b0ab581c7264270827d418c7cc574f55ea1672a1b1b81831ce00c53b92                                       
 => => exporting attestation manifest sha256:359311e86811c939e57f0a5b4f28fca3b033b0dc74a2d23c4ee28a733b443f3e                         
 => => exporting manifest list sha256:7596f97fa89b5e95a5d1bfc3506b8912fb66462c616657fdc2b46f50880a0cf2                                
 => => naming to docker.io/library/user-service:latest                                                                                
 => => unpacking to docker.io/library/user-service:latest                                                                             
                                                                                                                                      
View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/u9145epeyakn1ve6sqhekac8h                                                             
````

**Dónde**

- `.\business-domain\user-service`: El contexto de construcción es la carpeta `user-service`, donde está el código
  fuente del proyecto al que queremos generar su imagen.
- `-f .\business-domain\user-service\Dockerfile`: Le dices a `Docker` que el `Dockerfile` está en la carpeta
  `/user-service`.

**Importante**
> Si al construir la imagen de nuestro proyecto, nos ubicamos exactamente en el directorio raíz del microservicio
> `user-service` usando la CMD, entonces el comando sería de la siguiente manera.
>
> `docker image build -t user-service .`
>
> Es decir, con el punto `.` indicamos que el contexto de construcción de la imagen es la ruta actual y que por defecto
> el `Dockerfile` también se encuentra en la ruta actual.

Podemos ver que el tamaño de la imagen generada es de `906MB`, es demasiado grande. Eso era de esperarse, dado que
copiamos todo el código fuente, descargamos dentro del contenedor las dependencias y allí mismo empaquetamos la
aplicación.

````bash
$ docker image ls
REPOSITORY        TAG             IMAGE ID       CREATED         SIZE
user-service      latest          0faa43cd1793   6 minutes ago   906MB
````

> Más adelante veremos cómo optimizar (reducir) más el tamaño de la imagen.

Para probar que nuestra imagen es funcional, construiremos un contenedor a partir de ella.

````bash
$ docker container run -d -p 8001:8001 user-service
319e9ea67f10db4702d1e1797959a27f4fbec5ae5e5226231125408fe446470b
````

Si listamos los contenedores, veremos que el que acabamos de crear está en ejecución con status `UP`.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                    NAMES
319e9ea67f10   user-service   "/__cacert_entrypoin…"   21 seconds ago   Up 20 seconds   0.0.0.0:8001->8001/tcp   compassionate_elgamal
````

Realizamos una petición hacia el microservicio `user-service` que ahora mismo está corriendo dentro del contenedor
creado.

````bash
$ curl -v http://localhost:8001/api/v1/users/1 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 22 May 2025 04:56:38 GMT
<
{
  "id": 1,
  "name": "Martin",
  "email": "martin@gmail.com",
  "password": "123456"
}
````

## Optimizando Dockerfile - Añadiendo Nuevas Capas

En el apartado anterior modificamos el `Dockerfile` para que en automático se genere el `jar` de nuestra aplicación, de
esa manera evitamos estar generándolo manualmente cada vez que hagamos un cambio en el código fuente. Pero aún tenemos
un problema, cada vez que modifiquemos el código fuente, si bien es cierto, el `Dockerfile` generará automáticamente
el `jar`, pero antes de eso, cuando la instrucción llegue hasta ese `COPY ./ ./`, `Docker` sabe que hay un archivo
dentro del código fuente que ha cambiado, pero no sabe cuál es, así que copiará nuevamente todo el contenido a la
imagen de `Docker`, eso incluye, obviamente, el archivo `pom.xml`.

Entonces, a partir de la línea `COPY ./ ./` hacia abajo, `Docker` empezará a ejecutar todas las instrucciones que
encuentre como si fuera la primera vez, es por eso que cuando llega al `RUN`, esa instrucción hace que se vuelva a
descargar todas las dependencias del proyecto. No debería descargar nuevamente las dependencias, dado que solo
modificamos el código fuente y además, las dependencias ya las teníamos descargadas. `¿Cómo solucionarlo?`.

Para eso, debemos realizar las siguientes modificaciones en el `Dockerfile` que consistirán básicamente en:

1. Copiamos archivos y directorios que contienen los detalles de las dependencias a descargar.
2. Descargamos las dependencias.
3. Copiamos el código fuente a la imagen.
4. Generar el `jar` de nuestra aplicación.

A continuación se muestra las nuevas modificaciones realizadas al `Dockerfile`.

````dockerfile
FROM eclipse-temurin:21-jdk-alpine
WORKDIR /app
COPY ./mvnw ./
COPY ./.mvn ./.mvn
COPY ./pom.xml ./
RUN sed -i -e 's/\r$//' ./mvnw  && ./mvnw dependency:go-offline
COPY ./src ./src
RUN ./mvnw clean package -DskipTests
EXPOSE 8001
CMD ["java", "-jar", "./target/user-service-0.0.1-SNAPSHOT.jar"]
````

**Donde**

- Los tres primeros `COPY` copian el script `mvnw`, el directorio `.mvn` y el archivo `pom.xml` dentro del directorio de
  trabajo `/app`. Estos tres elementos son importantes para poder descargar las dependencias con maven.


- `RUN sed -i -e 's/\r$//' ./mvnw`, este comando lo vimos anteriormente, es utilizado antes de ejecutar el
  archivo `.mvnw`, para que elimine los caracteres de retorno de carro de dicho archivo y no haya errores cuando se
  ejecute con el `RUN`.


- `RUN ./mvnw dependency:go-offline`, con este comando iniciamos la descarga de las dependencias de maven.


- `COPY ./src ./src`, copiamos solo el código fuente que está ubicado en el directorio `./src` de nuestra máquina local.
  Lo copiamos dentro de un directorio `./src` pero que estará dentro del `WORKDIR /app`.


- `RUN ./mvnw clean package -DskipTests`, iniciamos la creación del `jar`, pero esta vez, ya no volverá a descargar las
  dependencias, ya las tenemos descargadas en las capas anteriores.

Con esas modificaciones realizadas a nuestro `Dockerfile`, cada vez que cambiemos algo en el código fuente,
las dependencias ya no volverán a descargarse, porque lo que modificamos fue el código fuente y no las dependencias,
por lo tanto, **la velocidad de creación de la imagen será más rápida.**

**Nota 01**
> En el segundo `COPY` estamos copiando el directorio `.mvn` y su contenido a la imagen de Docker, pero,
> `¿qué es ese directorio?`.
>
> El directorio `.mvn` en una aplicación de `Spring Boot` es un directorio especial que se utiliza para alojar archivos
> relacionados con la construcción y configuración del proyecto. En particular, el directorio `.mvn` **se utiliza para
> personalizar la construcción del proyecto utilizando el mecanismo de "wrapper" de Maven.**
>
> El `Maven Wrapper (o simplemente "wrapper")` **es una forma de garantizar que un proyecto se construya con una versión
> específica de Maven**, independientemente de la versión de Maven instalada en el sistema del desarrollador. Esto puede
> ser útil para garantizar que todos los miembros del equipo utilicen la misma versión de Maven y para simplificar la
> configuración del entorno de construcción.
>
> Dentro del directorio `.mvn`, normalmente encontrarás dos archivos clave:
>
> - `wrapper/ (subdirectorio):` Este subdirectorio contiene los archivos necesarios para el `Maven Wrapper`.
> - `maven-wrapper.properties` especifica la versión de Maven que se utilizará y cómo se descargará si no está presente.
> - `maven-wrapper.jar` es una biblioteca que permite ejecutar Maven sin tenerlo instalado localmente.

**Nota 02**
> `RUN ./mvnw dependency:go-offline`:<br>
> - `dependency:go-offline`, objetivo (goal) que resuelve todas las dependencias del proyecto, incluyendo plugins e
    informes y sus dependencias. Después de ejecutar este objetivo, podemos trabajar con seguridad en modo offline.
> - El objetivo `dependency:go-offline` descarga todas las dependencias del proyecto y las almacena en el repositorio
    local de Maven en la imagen de Docker.
> - Esto es útil para garantizar que todas las dependencias estén disponibles sin necesidad de una conexión a Internet
    durante la construcción de la imagen de Docker.
> - Esta instrucción no construye el proyecto ni empaqueta la aplicación Spring Boot.
>
> `Conclusión`: utilizamos esa instrucción, ya que solo deseamos descargar las dependencias y preparar el entorno de
> `Maven` para una construcción posterior.

Probemos los cambios realizados. Ejecutemos por primera vez la imagen y veamos cuánto tiempo se demora en crearla:

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-7)                            
$ docker image build -t user-service .\business-domain\user-service -f .\business-domain\user-service\Dockerfile                      
[+] Building 56.6s (14/14) FINISHED                                                                                                   
 => [internal] load build definition from Dockerfile                                                                                  
 => => transferring dockerfile: 344B                                                                                                  
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                      
 => [internal] load .dockerignore                                                                                                     
 => => transferring context: 214B                                                                                                     
 => [1/8] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => => resolve docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => [internal] load build context                                                                                                     
 => => transferring context: 2.98kB                                                                                                   
 => [auth] library/eclipse-temurin:pull token for registry-1.docker.io                                                                
 => CACHED [2/8] WORKDIR /app                                                                                                         
 => [3/8] COPY ./mvnw ./                                                                                                              
 => [4/8] COPY ./.mvn ./.mvn                                                                                                          
 => [5/8] COPY ./pom.xml ./                                                                                                           
 => [6/8] RUN sed -i -e 's/\r$//' ./mvnw  && ./mvnw dependency:go-offline                                                             
 => [7/8] COPY ./src ./src                                                                                                            
 => [8/8] RUN ./mvnw clean package -DskipTests                                                                                        
 => exporting to image                                                                                                                
 => => exporting layers                                                                                                               
 => => exporting manifest sha256:c5ce784d8277e13a62eb5a17eadf24c0e029874d4f17d5686efe51c4e3e0131b                                     
 => => exporting config sha256:f86198ee0280dee89489653bb9f850b1822fc58a3e50d94d53e9838140eca1e2                                       
 => => exporting attestation manifest sha256:9f0c8710fb9b56bc008fb82e248d3a11fa74c964f49db73b5dff8c16bd068e59                         
 => => exporting manifest list sha256:8ed76839ed6e1d556d63d1a8659e4b8b636f0bb09e422bdab05c3d5292ca53ba                                
 => => naming to docker.io/library/user-service:latest                                                                                
 => => unpacking to docker.io/library/user-service:latest                                                                             
                                                                                                                                      
View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/xsre4nta4wjyl8u3aw2at861a                            
````

Se demoró 56.6 segundos. Ahora listemos la imagen generada.

````bash
$ docker image ls
REPOSITORY        TAG             IMAGE ID       CREATED              SIZE
user-service      latest          8ed76839ed6e   About a minute ago   1.04GB
````

A continuación realicemos un cambio en el código fuente y volvamos a generar la imagen por segunda vez.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-7)                            
$ docker image build -t user-service .\business-domain\user-service -f .\business-domain\user-service\Dockerfile                      
[+] Building 13.2s (13/13) FINISHED                                                                                                   
 => [internal] load build definition from Dockerfile                                                                                  
 => => transferring dockerfile: 344B                                                                                                  
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                      
 => [internal] load .dockerignore                                                                                                     
 => => transferring context: 214B                                                                                                     
 => [internal] load build context                                                                                                     
 => => transferring context: 5.26kB                                                                                                   
 => [1/8] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => => resolve docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => CACHED [2/8] WORKDIR /app                                                                                                         
 => CACHED [3/8] COPY ./mvnw ./                                                                                                       
 => CACHED [4/8] COPY ./.mvn ./.mvn                                                                                                   
 => CACHED [5/8] COPY ./pom.xml ./                                                                                                    
 => CACHED [6/8] RUN sed -i -e 's/\r$//' ./mvnw  && ./mvnw dependency:go-offline                                                      
 => [7/8] COPY ./src ./src                                                                                                            
 => [8/8] RUN ./mvnw clean package -DskipTests                                                                                        
 => exporting to image                                                                                                                
 => => exporting layers                                                                                                               
 => => exporting manifest sha256:017285229fc31414cdf3c15c8ff12d3cf4e8eced3db96ac3480b9a6f841f0a0d                                     
 => => exporting config sha256:36d34d132eeb48a8741e02d4a9375c9021e8de1468e8348d50ef326cf4576910                                       
 => => exporting attestation manifest sha256:104c6ac49b68f522a8c5a3d0aae79272427968903f6958379a3aa01ae54b5998                         
 => => exporting manifest list sha256:de2b755c7826d498af9b920231806f118da2f5c074ad1f5df055b21d17bdb469                                
 => => naming to docker.io/library/user-service:latest                                                                                
 => => unpacking to docker.io/library/user-service:latest                                                                             
                                                                                                                                      
View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/x9xodyavj1zhoz5u6eia1ogdf                            
````

Esta vez le tomó tan solo 13.2 segundos, esto significa que nuestra configuración está funcionando. Ahora, generemos un
contenedor de la imagen anterior y probemos que todo sigue funcionando como antes.

````bash
$ docker container run -d -p 8001:8001 user-service
5285380bde621e5c35c38c24837c6bcd582459875503983b0f58d12ca216c252
````

Listamos los contenedores para ver el que acabamos de crear.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                    NAMES
5285380bde62   user-service   "/__cacert_entrypoin…"   32 seconds ago   Up 32 seconds   0.0.0.0:8001->8001/tcp   funny_spence
````

Comprobamos que nuestra aplicación alojada dentro del contenedor, se está ejecutando correctamente.

````bash
$ curl -v http://localhost:8001/api/v1/users/1 | jq
>
< HTTP/1.1 200
< 
{
  "id": 1,
  "name": "Milagros",
  "email": "milagros@gmail.com",
  "password": "123456"
}
````
