# Sección 07: Docker - Optimizando Dockerfile

---

## Crea archivo .dockerignore

````dockerignore
# Ignora todos los archivos y directorios del contexto de construcción
*
# Los siguientes directorios y archivos no deben ser ignorados
!src/
!pom.xml
!.mvn/
!mvnw
````

El archivo `.dockerignore` es un archivo de texto que especifica qué archivos y directorios deben ser ignorados al
construir una imagen de `Docker`. Funciona de manera similar a un archivo `.gitignore` en `Git`, ayudando a excluir
ciertos archivos innecesarios del contexto de construcción (es decir, el conjunto de archivos que `Docker` envía al
daemon de `Docker` para crear una imagen).

Cuando `Docker` construye una imagen, toma todo lo que está en el contexto de construcción y lo envía al daemon para
procesarlo. Sin embargo, algunos archivos no son necesarios para la imagen (como archivos temporales, archivos de
configuración específicos del desarrollador, o incluso código fuente que no es relevante para la construcción de la
imagen). El archivo `.dockerignore` te permite especificar esos archivos o carpetas para reducir el tamaño de la imagen
y mejorar la eficiencia.

## Optimizando Dockerfile

Hasta ahora lo que estamos haciendo para generar la imagen de nuestro proyecto de `Spring Boot` es:

1. Generar manualmente el archivo `jar`.
2. Utilizar ese empaquetado para generar la imagen.

Sin embargo, `¡podemos automatizar ese proceso!`; para eso tenemos que realizar modificaciones en nuestro `Dockerfile`.

````dockerfile
FROM eclipse-temurin:21-jdk-alpine
WORKDIR /app
COPY ./ ./
RUN sed -i -e 's/\r$//' ./mvnw  && ./mvnw clean package -DskipTests
EXPOSE 8001
CMD ["java", "-jar", "./target/user-service-0.0.1-SNAPSHOT.jar"]
````

**Dónde**

- `COPY ./ ./` copia todos los archivos y directorios no ignorados del directorio actual (primer `./`) al directorio de
  trabajo dentro del contenedor (segundo `./` es equivalente a `/app`).
- `RUN sed -i -e 's/\r$//' ./mvnw && ./mvnw clean package -DskipTests`, aquí hay dos bloques separados por el `&&`,
  podría haber colocado cada bloque en una línea cada una con el `RUN`, pero `SonarLint` marca un warning y dice que lo
  coloque en una sola línea separada por `&&`.

**Desglose del comando:**

- `sed -i -e 's/\r$//' ./mvnw`:
    - `Descripción`: El comando `sed` se utiliza para eliminar los caracteres de retorno de carro (`\r`, que son típicos
      en sistemas Windows) del archivo `mvnw`.
    - `Propósito`: Evitar problemas de compatibilidad en sistemas basados en `Unix/Linux` (como `Alpine`) cuando se
      ejecuta el script `mvnw`.
    - `-i`: Es una opción que le indica a sed que realice cambios en el archivo en su lugar, es decir, modificará el
      archivo `mvnw` directamente.
    - `-e`: Indica que se proporcionará una expresión de script a `sed`.
    - `'s/\r$//'`: Es la expresión de script que busca y reemplaza el retorno de carro (`\r`) al final de cada línea
      del archivo por una cadena vacía, es decir, lo elimina.
    - `./mvnw`: Es el archivo en el que se realizará la modificación. En este caso, se asume que el archivo `mvnw` está
      en el directorio actual (`./` que es equivalente al `WORKDIR /app`).

  > Este comando es útil cuando los archivos se han creado o editado en un sistema Windows o en un entorno que
  > utiliza retornos de carro, y se deben utilizar en un entorno Linux o Unix donde se espera el carácter de nueva
  > línea para indicar el final de una línea. Al eliminar los caracteres de retorno de carro, se asegura que el
  > archivo sea compatible con el sistema en el que se está utilizando.

- `./mvnw clean package -DskipTests`, este comando ejecuta `Maven` (a través del wrapper `mvnw`) para compilar y
  empaquetar el proyecto. Este comando se ejecuta en la raíz del directorio de trabajo `WORKDIR /app`.


- `EXPOSE 8001`, la instrucción `EXPOSE` en un `Dockerfile` tiene como propósito informar que un `contenedor` utiliza un
  puerto específico para recibir conexiones. Es una especie de `documentación` dentro del Dockerfile que indica a otros
  usuarios qué `puerto expone tu aplicación dentro del contenedor`. En nuestro caso la aplicación de Spring Boot tiene
  configurado el puerto `server.port=8001`, eso significa que la aplicación estará escuchando en el puerto `8001` dentro
  del contenedor. En este caso, debemos `exponer` ese mismo puerto en el `Dockerfile`. Esto asegura que el puerto `8001`
  esté documentado y visible en el contenedor para quien necesite mapearlo o conectarse.
  > Al final de este README hablaré un poco más sobre el EXPOSE definido en el Dockerfile y la opción `-P` o
  > `--publish-all`.


- `CMD ["java", "-jar", "./target/user-service-0.0.1-SNAPSHOT.jar"]`, este comando es usado cuando se levanta el
  contenedor.

Del punto anterior, es muy importante colocar el nombre de archivo `jar` generado en la compilación.
Por defecto, el nombre del jar para ese microservicio es `user-service-0.0.1-SNAPSHOT.jar`. Ahora, notar que
estamos iniciando con `./target/...`, eso significa que cuando se compiló el `jar` dentro del `WORKDIR /app`, se creó
el directorio `/target` y dentro de él se generó el  `jar`.

En la sección anterior tuvimos que posicionarnos, mediante la línea de comando, en la raíz del microservicio
`user-service` para ejecutar el comando de construcción de la imagen, dado que en dicha raíz se encuentra el archivo
`Dockefile`.

En esta oportunidad, para variar la manera de construir la imagen, nos posicionaremos en la raíz del proyecto general,
en ese sentido, debemos especificar la ruta del contexto de construcción de la imagen, es decir, especificarle dónde
se encuentra el `Dockerfile`.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-7)                            
$ docker image build -t user-service .\business-domain\user-service -f .\business-domain\user-service\Dockerfile                      
[+] Building 49.0s (10/10) FINISHED                                                                                                   
 => [internal] load build definition from Dockerfile                                                                                  
 => => transferring dockerfile: 249B                                                                                                  
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                      
 => [auth] library/eclipse-temurin:pull token for registry-1.docker.io                                                                
 => [internal] load .dockerignore                                                                                                     
 => => transferring context: 214B                                                                                                     
 => [1/4] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => => resolve docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => => sha256:370873e386b22025c28fa9279cae3a1cd222ac243a221679834774d0620fa7f3 157.86MB / 157.86MB                                    
 => => extracting sha256:370873e386b22025c28fa9279cae3a1cd222ac243a221679834774d0620fa7f3                                             
 => => extracting sha256:5bb1def311668c63d0555cfb562a2dc952ee1c071f75d5f1805f7e6383c36365                                             
 => => extracting sha256:aa49a465cc24db7df330480bc605cd2f13f785972d1645eeff0397c467e58380                                             
 => [internal] load build context                                                                                                     
 => => transferring context: 2.98kB                                                                                                   
 => [2/4] WORKDIR /app                                                                                                                
 => [3/4] COPY ./ ./                                                                                                                  
 => [4/4] RUN sed -i -e 's/\r$//' ./mvnw  && ./mvnw clean package -DskipTests                                                         
 => exporting to image                                                                                                                
 => => exporting layers                                                                                                               
 => => exporting manifest sha256:aebca6e49a35052f8039e4681a67e692fbd9567eb5924a5398ba1da4b2077d78                                     
 => => exporting config sha256:f62b07b0ab581c7264270827d418c7cc574f55ea1672a1b1b81831ce00c53b92                                       
 => => exporting attestation manifest sha256:359311e86811c939e57f0a5b4f28fca3b033b0dc74a2d23c4ee28a733b443f3e                         
 => => exporting manifest list sha256:7596f97fa89b5e95a5d1bfc3506b8912fb66462c616657fdc2b46f50880a0cf2                                
 => => naming to docker.io/library/user-service:latest                                                                                
 => => unpacking to docker.io/library/user-service:latest                                                                             
                                                                                                                                      
View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/u9145epeyakn1ve6sqhekac8h                                                             
````

**Dónde**

- `.\business-domain\user-service`: El contexto de construcción es la carpeta `user-service`, donde está el código
  fuente del proyecto al que queremos generar su imagen.
- `-f .\business-domain\user-service\Dockerfile`: Le dices a `Docker` que el `Dockerfile` está en la carpeta
  `/user-service`.

**Importante**
> Si al construir la imagen de nuestro proyecto, nos ubicamos exactamente en el directorio raíz del microservicio
> `user-service` usando la CMD, entonces el comando sería de la siguiente manera.
>
> `docker image build -t user-service .`
>
> Es decir, con el punto `.` indicamos que el contexto de construcción de la imagen es la ruta actual y que por defecto
> el `Dockerfile` también se encuentra en la ruta actual.

Podemos ver que el tamaño de la imagen generada es de `906MB`, es demasiado grande. Eso era de esperarse, dado que
copiamos todo el código fuente, descargamos dentro del contenedor las dependencias y allí mismo empaquetamos la
aplicación.

````bash
$ docker image ls
REPOSITORY        TAG             IMAGE ID       CREATED         SIZE
user-service      latest          0faa43cd1793   6 minutes ago   906MB
````

> Más adelante veremos cómo optimizar (reducir) más el tamaño de la imagen.

Para probar que nuestra imagen es funcional, construiremos un contenedor a partir de ella.

````bash
$ docker container run -d -p 8001:8001 user-service
319e9ea67f10db4702d1e1797959a27f4fbec5ae5e5226231125408fe446470b
````

Si listamos los contenedores, veremos que el que acabamos de crear está en ejecución con status `UP`.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                    NAMES
319e9ea67f10   user-service   "/__cacert_entrypoin…"   21 seconds ago   Up 20 seconds   0.0.0.0:8001->8001/tcp   compassionate_elgamal
````

Realizamos una petición hacia el microservicio `user-service` que ahora mismo está corriendo dentro del contenedor
creado.

````bash
$ curl -v http://localhost:8001/api/v1/users/1 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 22 May 2025 04:56:38 GMT
<
{
  "id": 1,
  "name": "Martin",
  "email": "martin@gmail.com",
  "password": "123456"
}
````

## Optimizando Dockerfile - Añadiendo Nuevas Capas

En el apartado anterior modificamos el `Dockerfile` para que en automático se genere el `jar` de nuestra aplicación, de
esa manera evitamos estar generándolo manualmente cada vez que hagamos un cambio en el código fuente. Pero aún tenemos
un problema, cada vez que modifiquemos el código fuente, si bien es cierto, el `Dockerfile` generará automáticamente
el `jar`, pero antes de eso, cuando la instrucción llegue hasta ese `COPY ./ ./`, `Docker` sabe que hay un archivo
dentro del código fuente que ha cambiado, pero no sabe cuál es, así que copiará nuevamente todo el contenido a la
imagen de `Docker`, eso incluye, obviamente, el archivo `pom.xml`.

Entonces, a partir de la línea `COPY ./ ./` hacia abajo, `Docker` empezará a ejecutar todas las instrucciones que
encuentre como si fuera la primera vez, es por eso que cuando llega al `RUN`, esa instrucción hace que se vuelva a
descargar todas las dependencias del proyecto. No debería descargar nuevamente las dependencias, dado que solo
modificamos el código fuente y además, las dependencias ya las teníamos descargadas. `¿Cómo solucionarlo?`.

Para eso, debemos realizar las siguientes modificaciones en el `Dockerfile` que consistirán básicamente en:

1. Copiamos archivos y directorios que contienen los detalles de las dependencias a descargar.
2. Descargamos las dependencias.
3. Copiamos el código fuente a la imagen.
4. Generar el `jar` de nuestra aplicación.

A continuación se muestra las nuevas modificaciones realizadas al `Dockerfile`.

````dockerfile
FROM eclipse-temurin:21-jdk-alpine
WORKDIR /app
COPY ./mvnw ./
COPY ./.mvn ./.mvn
COPY ./pom.xml ./
RUN sed -i -e 's/\r$//' ./mvnw  && ./mvnw dependency:go-offline
COPY ./src ./src
RUN ./mvnw clean package -DskipTests
EXPOSE 8001
CMD ["java", "-jar", "./target/user-service-0.0.1-SNAPSHOT.jar"]
````

**Donde**

- Los tres primeros `COPY` copian el script `mvnw`, el directorio `.mvn` y el archivo `pom.xml` dentro del directorio de
  trabajo `/app`. Estos tres elementos son importantes para poder descargar las dependencias con maven.


- `RUN sed -i -e 's/\r$//' ./mvnw`, este comando lo vimos anteriormente, es utilizado antes de ejecutar el
  archivo `.mvnw`, para que elimine los caracteres de retorno de carro de dicho archivo y no haya errores cuando se
  ejecute con el `RUN`.


- `RUN ./mvnw dependency:go-offline`, con este comando iniciamos la descarga de las dependencias de maven.


- `COPY ./src ./src`, copiamos solo el código fuente que está ubicado en el directorio `./src` de nuestra máquina local.
  Lo copiamos dentro de un directorio `./src` pero que estará dentro del `WORKDIR /app`.


- `RUN ./mvnw clean package -DskipTests`, iniciamos la creación del `jar`, pero esta vez, ya no volverá a descargar las
  dependencias, ya las tenemos descargadas en las capas anteriores.

Con esas modificaciones realizadas a nuestro `Dockerfile`, cada vez que cambiemos algo en el código fuente,
las dependencias ya no volverán a descargarse, porque lo que modificamos fue el código fuente y no las dependencias,
por lo tanto, **la velocidad de creación de la imagen será más rápida.**

**Nota 01**
> En el segundo `COPY` estamos copiando el directorio `.mvn` y su contenido a la imagen de Docker, pero,
> `¿qué es ese directorio?`.
>
> El directorio `.mvn` en una aplicación de `Spring Boot` es un directorio especial que se utiliza para alojar archivos
> relacionados con la construcción y configuración del proyecto. En particular, el directorio `.mvn` **se utiliza para
> personalizar la construcción del proyecto utilizando el mecanismo de "wrapper" de Maven.**
>
> El `Maven Wrapper (o simplemente "wrapper")` **es una forma de garantizar que un proyecto se construya con una versión
> específica de Maven**, independientemente de la versión de Maven instalada en el sistema del desarrollador. Esto puede
> ser útil para garantizar que todos los miembros del equipo utilicen la misma versión de Maven y para simplificar la
> configuración del entorno de construcción.
>
> Dentro del directorio `.mvn`, normalmente encontrarás dos archivos clave:
>
> - `wrapper/ (subdirectorio):` Este subdirectorio contiene los archivos necesarios para el `Maven Wrapper`.
> - `maven-wrapper.properties` especifica la versión de Maven que se utilizará y cómo se descargará si no está presente.
> - `maven-wrapper.jar` es una biblioteca que permite ejecutar Maven sin tenerlo instalado localmente.

**Nota 02**
> `RUN ./mvnw dependency:go-offline`:<br>
> - `dependency:go-offline`, objetivo (goal) que resuelve todas las dependencias del proyecto, incluyendo plugins e
    informes y sus dependencias. Después de ejecutar este objetivo, podemos trabajar con seguridad en modo offline.
> - El objetivo `dependency:go-offline` descarga todas las dependencias del proyecto y las almacena en el repositorio
    local de Maven en la imagen de Docker.
> - Esto es útil para garantizar que todas las dependencias estén disponibles sin necesidad de una conexión a Internet
    durante la construcción de la imagen de Docker.
> - Esta instrucción no construye el proyecto ni empaqueta la aplicación Spring Boot.
>
> `Conclusión`: utilizamos esa instrucción, ya que solo deseamos descargar las dependencias y preparar el entorno de
> `Maven` para una construcción posterior.

Probemos los cambios realizados. Ejecutemos por primera vez la imagen y veamos cuánto tiempo se demora en crearla:

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-7)                            
$ docker image build -t user-service .\business-domain\user-service -f .\business-domain\user-service\Dockerfile                      
[+] Building 56.6s (14/14) FINISHED                                                                                                   
 => [internal] load build definition from Dockerfile                                                                                  
 => => transferring dockerfile: 344B                                                                                                  
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                      
 => [internal] load .dockerignore                                                                                                     
 => => transferring context: 214B                                                                                                     
 => [1/8] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => => resolve docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => [internal] load build context                                                                                                     
 => => transferring context: 2.98kB                                                                                                   
 => [auth] library/eclipse-temurin:pull token for registry-1.docker.io                                                                
 => CACHED [2/8] WORKDIR /app                                                                                                         
 => [3/8] COPY ./mvnw ./                                                                                                              
 => [4/8] COPY ./.mvn ./.mvn                                                                                                          
 => [5/8] COPY ./pom.xml ./                                                                                                           
 => [6/8] RUN sed -i -e 's/\r$//' ./mvnw  && ./mvnw dependency:go-offline                                                             
 => [7/8] COPY ./src ./src                                                                                                            
 => [8/8] RUN ./mvnw clean package -DskipTests                                                                                        
 => exporting to image                                                                                                                
 => => exporting layers                                                                                                               
 => => exporting manifest sha256:c5ce784d8277e13a62eb5a17eadf24c0e029874d4f17d5686efe51c4e3e0131b                                     
 => => exporting config sha256:f86198ee0280dee89489653bb9f850b1822fc58a3e50d94d53e9838140eca1e2                                       
 => => exporting attestation manifest sha256:9f0c8710fb9b56bc008fb82e248d3a11fa74c964f49db73b5dff8c16bd068e59                         
 => => exporting manifest list sha256:8ed76839ed6e1d556d63d1a8659e4b8b636f0bb09e422bdab05c3d5292ca53ba                                
 => => naming to docker.io/library/user-service:latest                                                                                
 => => unpacking to docker.io/library/user-service:latest                                                                             
                                                                                                                                      
View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/xsre4nta4wjyl8u3aw2at861a                            
````

Se demoró 56.6 segundos. Ahora listemos la imagen generada.

````bash
$ docker image ls
REPOSITORY        TAG             IMAGE ID       CREATED              SIZE
user-service      latest          8ed76839ed6e   About a minute ago   1.04GB
````

A continuación realicemos un cambio en el código fuente y volvamos a generar la imagen por segunda vez.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-7)                            
$ docker image build -t user-service .\business-domain\user-service -f .\business-domain\user-service\Dockerfile                      
[+] Building 13.2s (13/13) FINISHED                                                                                                   
 => [internal] load build definition from Dockerfile                                                                                  
 => => transferring dockerfile: 344B                                                                                                  
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                      
 => [internal] load .dockerignore                                                                                                     
 => => transferring context: 214B                                                                                                     
 => [internal] load build context                                                                                                     
 => => transferring context: 5.26kB                                                                                                   
 => [1/8] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => => resolve docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => CACHED [2/8] WORKDIR /app                                                                                                         
 => CACHED [3/8] COPY ./mvnw ./                                                                                                       
 => CACHED [4/8] COPY ./.mvn ./.mvn                                                                                                   
 => CACHED [5/8] COPY ./pom.xml ./                                                                                                    
 => CACHED [6/8] RUN sed -i -e 's/\r$//' ./mvnw  && ./mvnw dependency:go-offline                                                      
 => [7/8] COPY ./src ./src                                                                                                            
 => [8/8] RUN ./mvnw clean package -DskipTests                                                                                        
 => exporting to image                                                                                                                
 => => exporting layers                                                                                                               
 => => exporting manifest sha256:017285229fc31414cdf3c15c8ff12d3cf4e8eced3db96ac3480b9a6f841f0a0d                                     
 => => exporting config sha256:36d34d132eeb48a8741e02d4a9375c9021e8de1468e8348d50ef326cf4576910                                       
 => => exporting attestation manifest sha256:104c6ac49b68f522a8c5a3d0aae79272427968903f6958379a3aa01ae54b5998                         
 => => exporting manifest list sha256:de2b755c7826d498af9b920231806f118da2f5c074ad1f5df055b21d17bdb469                                
 => => naming to docker.io/library/user-service:latest                                                                                
 => => unpacking to docker.io/library/user-service:latest                                                                             
                                                                                                                                      
View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/x9xodyavj1zhoz5u6eia1ogdf                            
````

Esta vez le tomó tan solo 13.2 segundos, esto significa que nuestra configuración está funcionando. Ahora, generemos un
contenedor de la imagen anterior y probemos que todo sigue funcionando como antes.

````bash
$ docker container run -d -p 8001:8001 user-service
5285380bde621e5c35c38c24837c6bcd582459875503983b0f58d12ca216c252
````

Listamos los contenedores para ver el que acabamos de crear.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                    NAMES
5285380bde62   user-service   "/__cacert_entrypoin…"   32 seconds ago   Up 32 seconds   0.0.0.0:8001->8001/tcp   funny_spence
````

Comprobamos que nuestra aplicación alojada dentro del contenedor, se está ejecutando correctamente.

````bash
$ curl -v http://localhost:8001/api/v1/users/1 | jq
>
< HTTP/1.1 200
< 
{
  "id": 1,
  "name": "Milagros",
  "email": "milagros@gmail.com",
  "password": "123456"
}
````

## Optimizando Dockerfile - Compilaciones de varias etapas o Multi-Stage Builds

En el apartado anterior vimos que la creación de la imagen fue más rápida, pero aun el tamaño de la imagen generada es
muy grande, esto ocurre porque la imagen generada contiene el código fuente y otros archivos que solo los requerimos
para poder realizar la compilación. Entonces, para crear una imagen de `Docker optimizada` utilizaremos la función de
capas.

> Para tener mayor detalle sobre la `creación de una imagen de docker eficiente` visitar mi repositorio
> https://github.com/magadiflo/spring-microservices-in-action-2021/blob/main/04.welcome-to-docker.md

### [Multi-stage builds](https://docs.docker.com/build/building/multi-stage/)

Las compilaciones multietapa son útiles para cualquiera que haya luchado por optimizar los archivos `Docker` sin que
dejen de ser fáciles de leer y mantener.

### Usa compilaciones multi-stage

Con las compilaciones multietapa, `utilizas múltiples instrucciones FROM en tu Dockerfile`. Cada instrucción `FROM`
puede utilizar una base diferente, y cada una de ellas inicia una nueva etapa de la compilación. **Puede copiar
artefactos de forma selectiva de una etapa a otra, dejando atrás todo lo que no desee en la imagen final.**

A continuación se muestra la modificación realizada al `Dockerfile` que ahora es `Multi-stage`:

````dockerfile
FROM eclipse-temurin:21-jdk-alpine AS dependencies
WORKDIR /app
COPY ./mvnw ./
COPY ./.mvn ./.mvn
COPY ./pom.xml ./
RUN sed -i -e 's/\r$//' ./mvnw
RUN ./mvnw dependency:go-offline
COPY ./src ./src
RUN ./mvnw clean package -DskipTests

FROM eclipse-temurin:21-jre-alpine AS builder
WORKDIR /app
COPY --from=dependencies /app/target/*.jar ./app.jar
RUN java -Djarmode=layertools -jar app.jar extract

FROM eclipse-temurin:21-jre-alpine AS runner
WORKDIR /app
COPY --from=builder /app/dependencies ./
COPY --from=builder /app/spring-boot-loader ./
COPY --from=builder /app/snapshot-dependencies ./
COPY --from=builder /app/application ./
CMD ["java", "org.springframework.boot.loader.launch.JarLauncher"]
````

`Para comprobar `que la construcción de una imagen `mejora` con el uso de `Multi-stage`, necesitamos partir de cero,
es decir, anteriormente ya habíamos ejecutado el `Dockerfile` para construir la imagen de esta aplicación, por lo que
`Docker` ya lo tiene guardado en caché. Para asegurarnos de que la construcción de la imagen se realizará sin tomar
datos de la caché, podemos elegir una de las siguientes opciones.

1. `Eliminar toda la caché de construcción de Docker`. El siguiente comando no elimina las imágenes, contenedores o
   volúmenes en sí, solo la caché asociada con la construcción de imágenes (es decir, los archivos temporales generados
   durante el proceso de construcción).

    ````bash
    $ docker builder prune
    ````

2. `Forzar la reconstrucción de una imagen específica (sin eliminar caché globalmente)`. Si solo deseas reconstruir una
   imagen específica y forzar `que Docker ignore la caché` para esa construcción en particular, puedes agregar el flag
   `--no-cache` al comando `docker image build`. Por ejemplo:

    ````bash
    $ docker image build --no-cache -t user-service .
    ````

3. `Eliminar todo y empezar desde cero`, en este caso podemos ejecutar el siguiente para tener nuestra plataforma
   `Docker` completamente limpio, como si recién la hubiéramos instalado.
    ````bash
    $ docker system prune -a
    ````

> En mi caso ejecuté la tercera opción.

Ahora sí, una vez que ya tenemos limpio todo, vamos a construir la imagen de nuestra aplicación.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-7)                                         
$ docker image build -t user-service .\business-domain\user-service -f .\business-domain\user-service\Dockerfile                                   
[+] Building 98.5s (24/24) FINISHED                                                                                                                
 => [internal] load build definition from Dockerfile                                                                                               
 => => transferring dockerfile: 763B                                                                                                               
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jre-alpine                                                                   
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                                   
 => [auth] library/eclipse-temurin:pull token for registry-1.docker.io                                                                             
 => [internal] load .dockerignore                                                                                                                  
 => => transferring context: 214B                                                                                                                  
 => [builder 1/4] FROM docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd     
 => => resolve docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd             
 => => sha256:cda86626eeb372589c3378d030f4522ba1b0c78ec58b1db87960fa4e5fcd3e34 2.28kB / 2.28kB                                                     
 => => sha256:e6744199aa66ab985e37e72924f1568a6751afa2c508c42a1b3b945f3a8850a7 126B / 126B                                                         
 => => sha256:f6cd406c8d97cafcb893e824126c17fa19907b2bbc8d759931089e1be1e75750 16.18MB / 16.18MB                                                   
 => => sha256:74f6a226ed936757680facf9b217f62a2af16b663a69df8e4b3ece925e27ed2a 53.06MB / 53.06MB                                                   
 => => extracting sha256:f6cd406c8d97cafcb893e824126c17fa19907b2bbc8d759931089e1be1e75750                                                          
 => => extracting sha256:74f6a226ed936757680facf9b217f62a2af16b663a69df8e4b3ece925e27ed2a                                                          
 => => extracting sha256:e6744199aa66ab985e37e72924f1568a6751afa2c508c42a1b3b945f3a8850a7                                                          
 => => extracting sha256:cda86626eeb372589c3378d030f4522ba1b0c78ec58b1db87960fa4e5fcd3e34                                                          
 => [dependencies 1/9] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => => resolve docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0             
 => => sha256:aa49a465cc24db7df330480bc605cd2f13f785972d1645eeff0397c467e58380 2.28kB / 2.28kB                                                     
 => => sha256:5bb1def311668c63d0555cfb562a2dc952ee1c071f75d5f1805f7e6383c36365 130B / 130B                                                         
 => => sha256:370873e386b22025c28fa9279cae3a1cd222ac243a221679834774d0620fa7f3 157.86MB / 157.86MB                                                 
 => => sha256:d29b21f5b2c17ebc06e9a99b3cfcd3cfc8e8a3fed872fff81641100e99586c42 20.95MB / 20.95MB                                                   
 => => sha256:f18232174bc91741fdf3da96d85011092101a032a93a388b79e99e69c2d5c870 3.64MB / 3.64MB                                                     
 => => extracting sha256:f18232174bc91741fdf3da96d85011092101a032a93a388b79e99e69c2d5c870                                                          
 => => extracting sha256:d29b21f5b2c17ebc06e9a99b3cfcd3cfc8e8a3fed872fff81641100e99586c42                                                          
 => => extracting sha256:370873e386b22025c28fa9279cae3a1cd222ac243a221679834774d0620fa7f3                                                          
 => => extracting sha256:5bb1def311668c63d0555cfb562a2dc952ee1c071f75d5f1805f7e6383c36365                                                          
 => => extracting sha256:aa49a465cc24db7df330480bc605cd2f13f785972d1645eeff0397c467e58380                                                          
 => [internal] load build context                                                                                                                  
 => => transferring context: 37.50kB                                                                                                               
 => [builder 2/4] WORKDIR /app                                                                                                                     
 => [dependencies 2/9] WORKDIR /app                                                                                                                
 => [dependencies 3/9] COPY ./mvnw ./                                                                                                              
 => [dependencies 4/9] COPY ./.mvn ./.mvn                                                                                                          
 => [dependencies 5/9] COPY ./pom.xml ./                                                                                                           
 => [dependencies 6/9] RUN sed -i -e 's/\r$//' ./mvnw                                                                                              
 => [dependencies 7/9] RUN ./mvnw dependency:go-offline                                                                                            
 => [dependencies 8/9] COPY ./src ./src                                                                                                            
 => [dependencies 9/9] RUN ./mvnw clean package -DskipTests                                                                                        
 => [builder 3/4] COPY --from=dependencies /app/target/*.jar ./app.jar                                                                             
 => [builder 4/4] RUN java -Djarmode=layertools -jar app.jar extract                                                                               
 => [runner 3/6] COPY --from=builder /app/dependencies ./                                                                                          
 => [runner 4/6] COPY --from=builder /app/spring-boot-loader ./                                                                                    
 => [runner 5/6] COPY --from=builder /app/snapshot-dependencies ./                                                                                 
 => [runner 6/6] COPY --from=builder /app/application ./                                                                                           
 => exporting to image                                                                                                                             
 => => exporting layers                                                                                                                            
 => => exporting manifest sha256:618012b6461a0740d7a6e4f1ac537d30c211ad014d174c88394e37f28e506831                                                  
 => => exporting config sha256:853f3d482cf453545a7252e0dd01d9a0dd9959c7911dcba20f02e0ccf70d741c                                                    
 => => exporting attestation manifest sha256:d6df5734fcd283d6e9c83d7b07c5a2fedcb309b3921842234c47fc8a361a75fa                                      
 => => exporting manifest list sha256:d5f38d99d3a6089010d61f419a52e75563ecd0c5acd7e499321528ea39217aa1                                             
 => => naming to docker.io/library/user-service:latest                                                                                             
 => => unpacking to docker.io/library/user-service:latest                                                                                          
                                                                                                                                                   
View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/mgt5fjb326g5t85umqlfd6zkc                                         
````

Vemos que le tomó un tiempo de `98.5 segundos` en construir la imagen y todo lo hizo desde cero.

Ahora, procedemos a listar las imágenes y ver que ahora la imagen `user-service` pesa `407MB`. Como es evidente, el peso
se ha reducido considerablemente.

````bash
$ docker image ls
REPOSITORY     TAG       IMAGE ID       CREATED         SIZE
user-service   latest    d5f38d99d3a6   2 minutes ago   407MB
````

A continuación modificamos algo en el código fuente y volvemos a crear la imagen. En esta oportunidad el tiempo que le
tomó a `Docker` crear la imagen fue de `15.9s`. Notar que algunas capas las tomó de la `CACHED` de `Docker`.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-7)                                         
$ docker image build -t user-service .\business-domain\user-service -f .\business-domain\user-service\Dockerfile                                   
[+] Building 15.9s (24/24) FINISHED                                                                                                                
 => [internal] load build definition from Dockerfile                                                                                               
 => => transferring dockerfile: 763B                                                                                                               
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jre-alpine                                                                   
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                                   
 => [auth] library/eclipse-temurin:pull token for registry-1.docker.io                                                                             
 => [internal] load .dockerignore                                                                                                                  
 => => transferring context: 214B                                                                                                                  
 => [dependencies 1/9] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => => resolve docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0             
 => [builder 1/4] FROM docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd     
 => => resolve docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd             
 => [internal] load build context                                                                                                                  
 => => transferring context: 5.26kB                                                                                                                
 => CACHED [dependencies 2/9] WORKDIR /app                                                                                                         
 => CACHED [dependencies 3/9] COPY ./mvnw ./                                                                                                       
 => CACHED [dependencies 4/9] COPY ./.mvn ./.mvn                                                                                                   
 => CACHED [dependencies 5/9] COPY ./pom.xml ./                                                                                                    
 => CACHED [dependencies 6/9] RUN sed -i -e 's/\r$//' ./mvnw                                                                                       
 => CACHED [dependencies 7/9] RUN ./mvnw dependency:go-offline                                                                                     
 => [dependencies 8/9] COPY ./src ./src                                                                                                            
 => [dependencies 9/9] RUN ./mvnw clean package -DskipTests                                                                                        
 => CACHED [builder 2/4] WORKDIR /app                                                                                                              
 => [builder 3/4] COPY --from=dependencies /app/target/*.jar ./app.jar                                                                             
 => [builder 4/4] RUN java -Djarmode=layertools -jar app.jar extract                                                                               
 => CACHED [runner 3/6] COPY --from=builder /app/dependencies ./                                                                                   
 => CACHED [runner 4/6] COPY --from=builder /app/spring-boot-loader ./                                                                             
 => CACHED [runner 5/6] COPY --from=builder /app/snapshot-dependencies ./                                                                          
 => [runner 6/6] COPY --from=builder /app/application ./                                                                                           
 => exporting to image                                                                                                                             
 => => exporting layers                                                                                                                            
 => => exporting manifest sha256:600b959193fae2acde9f9e9f0e27f7f08e5bc13fef2a54abb4cc9a9042d4f738                                                  
 => => exporting config sha256:e3627962cb03cf0a74d6ec2465da164fb0ce36488162c649a5e91f8040d1cfa9                                                    
 => => exporting attestation manifest sha256:5b8ed5033ebc7f45d0eda930bdc5b8842598c5f6b7b865a16d0914ca39f33ccf                                      
 => => exporting manifest list sha256:33000042025057ef15a233d149a8b8675cf62ef05971b4776d3532a33726f42a                                             
 => => naming to docker.io/library/user-service:latest                                                                                             
 => => unpacking to docker.io/library/user-service:latest                                                                                          
                                                                                                                                                   
View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/1f6dz88la3amejp5xcos58slk                                         
````

Creamos un contenedor a partir de la imagen anterior.

````bash
$ docker container run -d -p 8001:8001 user-service
6d8855a794e1e147018843b75c13ac47b80a6625876111a4d8848637e4532718
````

Listamos los contenedores para ver el que acabamos de crear.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                    NAMES
6d8855a794e1   user-service   "/__cacert_entrypoin…"   35 seconds ago   Up 34 seconds   0.0.0.0:8001->8001/tcp   silly_blackwell
````

Finalmente, verificamos que nuestra aplicación de `Spring Boot` se esté ejecutando correctamente dentro del contenedor.

````bash
$ curl -v http://localhost:8001/api/v1/users/1 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Fri, 23 May 2025 04:48:12 GMT
<
{
  "id": 1,
  "name": "Martin",
  "email": "martin@gmail.com",
  "password": "123456"
}
````

## Sobre la instrucción EXPOSE del Dockerfile

En Docker, el comando `EXPOSE` se utiliza para indicar qué puertos serán expuestos por el contenedor cuando se ejecute.
Sin embargo, **es importante destacar que `EXPOSE` no publica realmente los puertos. Lo que hace es documentar los
puertos en los que una aplicación dentro del contenedor escuchará conexiones.**

Por ejemplo, si tu `aplicación Spring Boot escucha en el puerto 8001 (configurado con el server.port)` tu archivo
`Dockerfile` podría tener una línea como esta:

````dockerfile
EXPOSE 8001
````

Esto significa que la aplicación dentro del contenedor estará escuchando en el puerto 8001 para las conexiones
entrantes. Indica que el contenedor expone el puerto 8001 para ser accesible desde otros contenedores en la misma red
de Docker. Pero para acceder a ese puerto desde fuera del contenedor, deberías mapearlo al puerto de tu host cuando
ejecutes el contenedor:

````bash
$ docker container run -p <HOST_PORT>:<CONTAINER_PORT> <nombre_de_la_imagen>
````

Donde `HOST_PORT` es el puerto de tu máquina local y `CONTAINER_PORT` es el puerto expuesto por tu aplicación Spring
Boot dentro del contenedor (`server.port`).

En resumen, la instrucción `EXPOSE` de tu `Dockerfile` debería usar el puerto interno de tu contenedor (usualmente el
puerto en el que tu aplicación Spring Boot está escuchando). Luego, al ejecutar el contenedor, especificas cómo deseas
que los puertos del host se relacionen con los puertos expuestos del contenedor.

Más adelante parametrizaremos los valores de nuestro `Dockerfile`, así que cuando lleguemos a la instrucción del
`EXPOSE` lo crearemos de la siguiente manera.

````dockerfile
EXPOSE ${CONTAINER_PORT}
````

---

# Libro: Aprender Docker

## Opción -P, --publish-all

Recordemos que cuando creamos un `Dockerfile` podemos definir una instrucción llamada `EXPOSE`, que según la
documentación oficial de Docker, es usado simplemente como documentación, pero si creamos un contenedor con la
opción `-P` (mayúscula) podemos hacer uso de ella.

Con la opción `-P` (en mayúscula) publicamos todos los puertos que se hayan expuesto en la imagen que se ha utilizado
para crear el contenedor, en puertos aleatorios del `host`.

En este caso, no tenemos que indicar el puerto local, sino que **será seleccionado aleatoriamente** entre los puertos
que estén libres. El puerto del contenedor con el que se hace la redirección estará definido en el `Dockerfile`
con el que se ha creado la imagen del contenedor (usando la instrucción `EXPOSE`). Tenga en cuenta que, en el archivo
`Dockerfile`, se pueden exponer varios puertos a la vez.

**Importante**

> El siguiente ejemplo no es parte del proyecto, simplemente es para ver el funcionamiento de la opción
> `-P (mayúscula)` y la instrucción `EXPOSE`.

`Supongamos` que mi aplicación de Spring Boot se llama `products` y está usando el puerto `8085`:

````yaml
server:
  port: 8085

spring:
  application:
    name: products
````

Eso significa que el puerto que usará internamente el contenedor debe ser el `8085`.

Una vez construido el `jar` generamos la imagen de la aplicación utilizando el siguiente `Dockerfile`:

````dockerfile
FROM eclipse-temurin:21-jdk-alpine AS builder
WORKDIR /app
COPY ./target/*.jar ./app.jar
ARG CONTAINER_PORT=8085
EXPOSE ${CONTAINER_PORT}
CMD ["java", "-jar", "app.jar"]
````

Este `Dockerfile` define el puerto `CONTAINER_PORT`, que representa el puerto en el cual se ejecutará nuestra aplicación
Spring Boot dentro del contenedor. En este caso, el valor por defecto es `8085`.

A continuación, construimos una imagen a partir del `Dockerfile` anterior.

````bash
$ docker image build -t products .
````

Luego, creamos un contenedor utilizando la imagen recién generada.

````bash
$ docker container run -d -P --name c_products products
````

Es importante notar que estamos utilizando la opción `-P (mayúscula)`. Esta opción le indica a `Docker` que asigne
automáticamente un puerto aleatorio disponible en el host y lo redirija al puerto `8085` expuesto por el contenedor.

Listamos los contenedores para ver el que acabamos de crear:

````bash
$ docker container ls -a
CONTAINER ID   IMAGE                  COMMAND                  CREATED         STATUS             PORTS                              NAMES
b787f2484e07   products               "/__cacert_entrypoin…"   6 seconds ago   Up 4 seconds       0.0.0.0:32775->8085/tcp            c_products
````

Comprobamos que **el puerto aleatorio que se ha seleccionado para nuestro host Docker (pc local)** es el puerto `32775`
que está siendo enlazado al puerto `8085` dentro del contenedor.

Comprobamos que podemos acceder al contenido del contenedor usando la terminal con el comando curl:

````bash
$ curl -v http://localhost:32775/api/v1/products/1 | jq
>
< HTTP/1.1 200 OK
< Content-Type: application/json
< Content-Length: 79
<
{
  "id": 1,
  "name": "Teclado Logitech",
  "price": 75.8,
  "image": "keyboard-logitech.png"
}
````
