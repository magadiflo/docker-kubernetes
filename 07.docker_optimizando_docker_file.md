# Sección 07: Docker - Optimizando Dockerfile

---

## Crea archivo .dockerignore

````dockerignore
# Ignora todos los archivos y directorios del contexto de construcción
*
# Los siguientes directorios y archivos no deben ser ignorados
!src/
!pom.xml
!.mvn/
!mvnw
````

El archivo `.dockerignore` es un archivo de texto que especifica qué archivos y directorios deben ser ignorados al
construir una imagen de `Docker`. Funciona de manera similar a un archivo `.gitignore` en `Git`, ayudando a excluir
ciertos archivos innecesarios del contexto de construcción (es decir, el conjunto de archivos que `Docker` envía al
daemon de `Docker` para crear una imagen).

Cuando `Docker` construye una imagen, toma todo lo que está en el contexto de construcción y lo envía al daemon para
procesarlo. Sin embargo, algunos archivos no son necesarios para la imagen (como archivos temporales, archivos de
configuración específicos del desarrollador, o incluso código fuente que no es relevante para la construcción de la
imagen). El archivo `.dockerignore` te permite especificar esos archivos o carpetas para reducir el tamaño de la imagen
y mejorar la eficiencia.

## Optimizando Dockerfile

Hasta ahora lo que estamos haciendo para generar la imagen de nuestro proyecto de `Spring Boot` es:

1. Generar manualmente el archivo `jar`.
2. Utilizar ese empaquetado para generar la imagen.

Sin embargo, `¡podemos automatizar ese proceso!`; para eso tenemos que realizar modificaciones en nuestro `Dockerfile`.

````dockerfile
FROM eclipse-temurin:21-jdk-alpine
WORKDIR /app
COPY ./ ./
RUN sed -i -e 's/\r$//' ./mvnw  && ./mvnw clean package -DskipTests
EXPOSE 8001
CMD ["java", "-jar", "./target/user-service-0.0.1-SNAPSHOT.jar"]
````

**Dónde**

- `COPY ./ ./` copia todos los archivos y directorios no ignorados del directorio actual (primer `./`) al directorio de
  trabajo dentro del contenedor (segundo `./` es equivalente a `/app`).
- `RUN sed -i -e 's/\r$//' ./mvnw && ./mvnw clean package -DskipTests`, aquí hay dos bloques separados por el `&&`,
  podría haber colocado cada bloque en una línea cada una con el `RUN`, pero `SonarLint` marca un warning y dice que lo
  coloque en una sola línea separada por `&&`.

**Desglose del comando:**

- `sed -i -e 's/\r$//' ./mvnw`:
    - `Descripción`: El comando `sed` se utiliza para eliminar los caracteres de retorno de carro (`\r`, que son típicos
      en sistemas Windows) del archivo `mvnw`.
    - `Propósito`: Evitar problemas de compatibilidad en sistemas basados en `Unix/Linux` (como `Alpine`) cuando se
      ejecuta el script `mvnw`.
    - `-i`: Es una opción que le indica a sed que realice cambios en el archivo en su lugar, es decir, modificará el
      archivo `mvnw` directamente.
    - `-e`: Indica que se proporcionará una expresión de script a `sed`.
    - `'s/\r$//'`: Es la expresión de script que busca y reemplaza el retorno de carro (`\r`) al final de cada línea
      del archivo por una cadena vacía, es decir, lo elimina.
    - `./mvnw`: Es el archivo en el que se realizará la modificación. En este caso, se asume que el archivo `mvnw` está
      en el directorio actual (`./` que es equivalente al `WORKDIR /app`).

  > Este comando es útil cuando los archivos se han creado o editado en un sistema Windows o en un entorno que
  > utiliza retornos de carro, y se deben utilizar en un entorno Linux o Unix donde se espera el carácter de nueva
  > línea para indicar el final de una línea. Al eliminar los caracteres de retorno de carro, se asegura que el
  > archivo sea compatible con el sistema en el que se está utilizando.

- `./mvnw clean package -DskipTests`, este comando ejecuta `Maven` (a través del wrapper `mvnw`) para compilar y
  empaquetar el proyecto. Este comando se ejecuta en la raíz del directorio de trabajo `WORKDIR /app`.


- `EXPOSE 8001`, la instrucción `EXPOSE` en un `Dockerfile` tiene como propósito informar que un `contenedor` utiliza un
  puerto específico para recibir conexiones. Es una especie de `documentación` dentro del Dockerfile que indica a otros
  usuarios qué `puerto expone tu aplicación dentro del contenedor`. En nuestro caso la aplicación de Spring Boot tiene
  configurado el puerto `server.port=8001`, eso significa que la aplicación estará escuchando en el puerto `8001` dentro
  del contenedor. En este caso, debemos `exponer` ese mismo puerto en el `Dockerfile`. Esto asegura que el puerto `8001`
  esté documentado y visible en el contenedor para quien necesite mapearlo o conectarse.
  > Al final de este README hablaré un poco más sobre el EXPOSE definido en el Dockerfile y la opción `-P` o
  > `--publish-all`.


- `CMD ["java", "-jar", "./target/user-service-0.0.1-SNAPSHOT.jar"]`, este comando es usado cuando se levanta el
  contenedor.

Del punto anterior, es muy importante colocar el nombre de archivo `jar` generado en la compilación.
Por defecto, el nombre del jar para ese microservicio es `user-service-0.0.1-SNAPSHOT.jar`. Ahora, notar que
estamos iniciando con `./target/...`, eso significa que cuando se compiló el `jar` dentro del `WORKDIR /app`, se creó
el directorio `/target` y dentro de él se generó el  `jar`.

En la sección anterior tuvimos que posicionarnos, mediante la línea de comando, en la raíz del microservicio
`user-service` para ejecutar el comando de construcción de la imagen, dado que en dicha raíz se encuentra el archivo
`Dockefile`.

En esta oportunidad, para variar la manera de construir la imagen, nos posicionaremos en la raíz del proyecto general,
en ese sentido, debemos especificar la ruta del contexto de construcción de la imagen, es decir, especificarle dónde
se encuentra el `Dockerfile`.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-7)                            
$ docker image build -t user-service .\business-domain\user-service -f .\business-domain\user-service\Dockerfile                      
[+] Building 49.0s (10/10) FINISHED                                                                                                   
 => [internal] load build definition from Dockerfile                                                                                  
 => => transferring dockerfile: 249B                                                                                                  
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                      
 => [auth] library/eclipse-temurin:pull token for registry-1.docker.io                                                                
 => [internal] load .dockerignore                                                                                                     
 => => transferring context: 214B                                                                                                     
 => [1/4] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => => resolve docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => => sha256:370873e386b22025c28fa9279cae3a1cd222ac243a221679834774d0620fa7f3 157.86MB / 157.86MB                                    
 => => extracting sha256:370873e386b22025c28fa9279cae3a1cd222ac243a221679834774d0620fa7f3                                             
 => => extracting sha256:5bb1def311668c63d0555cfb562a2dc952ee1c071f75d5f1805f7e6383c36365                                             
 => => extracting sha256:aa49a465cc24db7df330480bc605cd2f13f785972d1645eeff0397c467e58380                                             
 => [internal] load build context                                                                                                     
 => => transferring context: 2.98kB                                                                                                   
 => [2/4] WORKDIR /app                                                                                                                
 => [3/4] COPY ./ ./                                                                                                                  
 => [4/4] RUN sed -i -e 's/\r$//' ./mvnw  && ./mvnw clean package -DskipTests                                                         
 => exporting to image                                                                                                                
 => => exporting layers                                                                                                               
 => => exporting manifest sha256:aebca6e49a35052f8039e4681a67e692fbd9567eb5924a5398ba1da4b2077d78                                     
 => => exporting config sha256:f62b07b0ab581c7264270827d418c7cc574f55ea1672a1b1b81831ce00c53b92                                       
 => => exporting attestation manifest sha256:359311e86811c939e57f0a5b4f28fca3b033b0dc74a2d23c4ee28a733b443f3e                         
 => => exporting manifest list sha256:7596f97fa89b5e95a5d1bfc3506b8912fb66462c616657fdc2b46f50880a0cf2                                
 => => naming to docker.io/library/user-service:latest                                                                                
 => => unpacking to docker.io/library/user-service:latest                                                                             
                                                                                                                                      
View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/u9145epeyakn1ve6sqhekac8h                                                             
````

**Dónde**

- `.\business-domain\user-service`: El contexto de construcción es la carpeta `user-service`, donde está el código
  fuente del proyecto al que queremos generar su imagen.
- `-f .\business-domain\user-service\Dockerfile`: Le dices a `Docker` que el `Dockerfile` está en la carpeta
  `/user-service`.

**Importante**
> Si al construir la imagen de nuestro proyecto, nos ubicamos exactamente en el directorio raíz del microservicio
> `user-service` usando la CMD, entonces el comando sería de la siguiente manera.
>
> `docker image build -t user-service .`
>
> Es decir, con el punto `.` indicamos que el contexto de construcción de la imagen es la ruta actual y que por defecto
> el `Dockerfile` también se encuentra en la ruta actual.

Podemos ver que el tamaño de la imagen generada es de `906MB`, es demasiado grande. Eso era de esperarse, dado que
copiamos todo el código fuente, descargamos dentro del contenedor las dependencias y allí mismo empaquetamos la
aplicación.

````bash
$ docker image ls
REPOSITORY        TAG             IMAGE ID       CREATED         SIZE
user-service      latest          0faa43cd1793   6 minutes ago   906MB
````

> Más adelante veremos cómo optimizar (reducir) más el tamaño de la imagen.

Para probar que nuestra imagen es funcional, construiremos un contenedor a partir de ella.

````bash
$ docker container run -d -p 8001:8001 user-service
319e9ea67f10db4702d1e1797959a27f4fbec5ae5e5226231125408fe446470b
````

Si listamos los contenedores, veremos que el que acabamos de crear está en ejecución con status `UP`.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                    NAMES
319e9ea67f10   user-service   "/__cacert_entrypoin…"   21 seconds ago   Up 20 seconds   0.0.0.0:8001->8001/tcp   compassionate_elgamal
````

Realizamos una petición hacia el microservicio `user-service` que ahora mismo está corriendo dentro del contenedor
creado.

````bash
$ curl -v http://localhost:8001/api/v1/users/1 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 22 May 2025 04:56:38 GMT
<
{
  "id": 1,
  "name": "Martin",
  "email": "martin@gmail.com",
  "password": "123456"
}
````
