# Sección 15: Kubernetes: Volúmenes

---

## [📦 Introducción a los Volúmenes en Kubernetes](https://kubernetes.io/docs/concepts/storage/volumes/)

En Kubernetes, `los archivos almacenados dentro de un contenedor son efímeros`, lo que representa ciertos desafíos para
aplicaciones que requieren persistencia de datos o almacenamiento compartido.

### 🧨 Problemas comunes sin volúmenes

1. `Pérdida de datos al reiniciar el contenedor`: Si un contenedor se bloquea o se detiene, todos los archivos creados o
   modificados durante su ejecución se pierden, ya que el sistema de archivos del contenedor se reinicia con un estado
   limpio cuando el `kubelet` lo vuelve a lanzar.


2. `Dificultad para compartir datos entre contenedores del mismo Pod`: En situaciones donde múltiples contenedores
   comparten un Pod, puede ser complicado habilitar un sistema de archivos común entre ellos sin una solución adecuada.

### ✅ ¿Cómo lo resuelve Kubernetes?

Para abordar estos problemas, `Kubernetes introduce la abstracción de volumen`. Esta permite proporcionar
almacenamiento persistente o compartido a los contenedores dentro de un Pod.

> 📌 Un `volumen en Kubernetes` es básicamente un directorio accesible desde uno o varios contenedores del Pod, que
> puede estar respaldado por distintos medios de almacenamiento, según el tipo de volumen utilizado.

### 🧱 Tipos de volúmenes

Kubernetes soporta diversos tipos de volúmenes, y un Pod puede montar varios de ellos simultáneamente. Se clasifican, de
forma general, en:

- `Volúmenes efímeros`: Existen únicamente durante la vida del Pod. Cuando este se elimina, el volumen también se
  destruye.

- `Volúmenes persistentes`: Sobreviven incluso después de que el Pod se elimina. Su ciclo de vida es independiente del
  Pod, permitiendo que los datos se mantengan y puedan ser reutilizados por nuevos Pods.

> 🔁 Un volumen, sin importar su tipo, conserva sus datos durante los reinicios de los contenedores dentro del
> mismo Pod. Sin embargo, solo los volúmenes persistentes sobreviven a la eliminación del Pod completo.

### 💡 Ejemplo simple

Supón que tienes un Pod con un volumen `emptyDir` (el volumen se monta dentro del pod), y un contenedor escribe un
archivo ahí. Si el contenedor se reinicia por error interno, `el archivo sigue estando presente` en ese volumen cuando
el contenedor se vuelve a iniciar.

Sin embargo, si se elimina el `Pod` completo, entonces:

- Si era un `volumen efímero` (`emptyDir`), el contenido se borra.
- Si era un `volumen persistente` (como un `persistentVolumeClaim`), los datos se conservan, incluso después de
  eliminar el Pod.

## [Tipos de volúmenes](https://kubernetes.io/docs/concepts/storage/volumes/#volume-types)

Como vimos anteriormente, en Kubernetes existen dos grandes categorías de volúmenes:

- `Volúmenes efímeros`: viven mientras el Pod exista.
- `Volúmenes persistentes`: sobreviven incluso si el Pod es eliminado.

A continuación, exploramos algunos de los tipos más comunes.

### [🗂️ emptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir)

Este es uno de los volúmenes efímeros más utilizados.

- `El volumen emptyDir se monta dentro del Pod` y su ciclo de vida está ligado directamente al del Pod, no al de los
  contenedores individuales.
- Se crea `cuando el Pod es asignado a un nodo`, y como su nombre lo indica, `inicialmente está vacío`.
- Todos los contenedores del Pod pueden `leer y escribir archivos compartidos` en este volumen. Pueden montarlo en la
  misma ruta o en rutas distintas según se requiera.
- Cuando el `Pod se elimina`, el volumen `emptyDir` también se `destruye automáticamente`, junto con todos los datos
  almacenados en él. Por eso, se usa comúnmente para `almacenar datos temporales`.

📌 Importante:

> La `caída o reinicio de un contenedor` dentro del Pod `no elimina` el volumen `emptyDir`.
> Los datos almacenados permanecen disponibles mientras el `Pod siga activo en el nodo`.

![01.png](assets/section-15/01.png)

### [🗂️ hostPath](https://kubernetes.io/docs/concepts/storage/volumes/#hostpath)

El volumen `hostPath` permite montar directamente un archivo o directorio del sistema de archivos del nodo host
(el Worker Node) dentro del Pod.

- Es `externo al Pod`, pero `local al nodo` donde se ejecuta.
- Su uso está `limitado a escenarios donde se tiene control total del nodo`, y por lo general
  `solo es viable en clústeres con un solo nodo` o para tareas muy específicas.

📌 Se puede usar para casos como:

- Acceder a archivos del host que necesita la aplicación (por ejemplo, logs del sistema).
- Exponer sockets de Docker o herramientas de monitoreo.

![02.png](assets/section-15/02.png)

🚨 Advertencia de seguridad:

> El uso de `hostPath` conlleva `riesgos importantes de seguridad`, ya que permite al contenedor acceder directamente al
> sistema de archivos del nodo, lo que `puede comprometer el nodo completo` si no se tiene cuidado.
>
> `Si puedes evitar usar hostPath, deberías hacerlo.`
>
> En su lugar, se recomienda utilizar un `PersistentVolume local (local PV)` con las debidas restricciones y
> aislamiento.

📝 Nota:

> En los siguientes apartados usaremos el `hostPath` por ser más simple y directo en entornos de desarrollo o
> pruebas. Sin embargo, más adelante veremos cómo reemplazarlo por una alternativa más segura y desacoplada utilizando
> `PersistentVolume` y `PersistentVolumeClaim`.

### 🗂️[nfs](https://kubernetes.io/docs/concepts/storage/volumes/#nfs), [csi](https://kubernetes.io/docs/concepts/storage/volumes/#csi)

Tanto `nfs` como `csi` son tipos de volúmenes que permiten el acceso desde `varios Worker Nodes`, por lo que están
diseñados para funcionar correctamente en `clústeres multi-nodo`.

Veamos qué hace cada uno:

### 📁 nfs – Network File System

- Un volumen `nfs` permite montar un recurso compartido NFS existente en uno o varios Pods.
- A diferencia de `emptyDir`, `el contenido no se elimina cuando el Pod se borra`; simplemente se desmonta.
- Esto permite que el volumen:
    - `Esté pre-poblado con datos`.
    - `Comparta información entre múltiples Pods`, incluso si están en nodos distintos.
    - `Admite múltiples escritores simultáneamente`, lo cual es ideal para escenarios de acceso concurrente.

> 📌 Es importante contar con un servidor NFS configurado y accesible desde todos los nodos del clúster.

### 📦 csi – Container Storage Interface

- CSI define una `interfaz estándar` y extensible para integrar soluciones de almacenamiento externas con Kubernetes.
- Gracias a CSI, los proveedores de almacenamiento (como AWS EBS, GCP PD, Ceph, NetApp, etc.) pueden ofrecer volúmenes
  que Kubernetes puede montar automáticamente.
- Permite que Kubernetes `interactúe con cualquier sistema de almacenamiento compatible con CSI`, tanto para clústeres
  on-premise como en la nube.
- CSI reemplaza gradualmente a muchos controladores in-tree antiguos, y es el enfoque recomendado para nuevas
  implementaciones.

![03.png](assets/section-15/03.png)

