# SecciÃ³n 15: Kubernetes: VolÃºmenes

---

## [ğŸ“¦ IntroducciÃ³n a los VolÃºmenes en Kubernetes](https://kubernetes.io/docs/concepts/storage/volumes/)

En Kubernetes, `los archivos almacenados dentro de un contenedor son efÃ­meros`, lo que representa ciertos desafÃ­os para
aplicaciones que requieren persistencia de datos o almacenamiento compartido.

### ğŸ§¨ Problemas comunes sin volÃºmenes

1. `PÃ©rdida de datos al reiniciar el contenedor`: Si un contenedor se bloquea o se detiene, todos los archivos creados o
   modificados durante su ejecuciÃ³n se pierden, ya que el sistema de archivos del contenedor se reinicia con un estado
   limpio cuando el `kubelet` lo vuelve a lanzar.


2. `Dificultad para compartir datos entre contenedores del mismo Pod`: En situaciones donde mÃºltiples contenedores
   comparten un Pod, puede ser complicado habilitar un sistema de archivos comÃºn entre ellos sin una soluciÃ³n adecuada.

### âœ… Â¿CÃ³mo lo resuelve Kubernetes?

Para abordar estos problemas, `Kubernetes introduce la abstracciÃ³n de volumen`. Esta permite proporcionar
almacenamiento persistente o compartido a los contenedores dentro de un Pod.

> ğŸ“Œ Un `volumen en Kubernetes` es bÃ¡sicamente un directorio accesible desde uno o varios contenedores del Pod, que
> puede estar respaldado por distintos medios de almacenamiento, segÃºn el tipo de volumen utilizado.

### ğŸ§± Tipos de volÃºmenes

Kubernetes soporta diversos tipos de volÃºmenes, y un Pod puede montar varios de ellos simultÃ¡neamente. Se clasifican, de
forma general, en:

- `VolÃºmenes efÃ­meros`: Existen Ãºnicamente durante la vida del Pod. Cuando este se elimina, el volumen tambiÃ©n se
  destruye.

- `VolÃºmenes persistentes`: Sobreviven incluso despuÃ©s de que el Pod se elimina. Su ciclo de vida es independiente del
  Pod, permitiendo que los datos se mantengan y puedan ser reutilizados por nuevos Pods.

> ğŸ” Un volumen, sin importar su tipo, conserva sus datos durante los reinicios de los contenedores dentro del
> mismo Pod. Sin embargo, solo los volÃºmenes persistentes sobreviven a la eliminaciÃ³n del Pod completo.

### ğŸ’¡ Ejemplo simple

SupÃ³n que tienes un Pod con un volumen `emptyDir` (el volumen se monta dentro del pod), y un contenedor escribe un
archivo ahÃ­. Si el contenedor se reinicia por error interno, `el archivo sigue estando presente` en ese volumen cuando
el contenedor se vuelve a iniciar.

Sin embargo, si se elimina el `Pod` completo, entonces:

- Si era un `volumen efÃ­mero` (`emptyDir`), el contenido se borra.
- Si era un `volumen persistente` (como un `persistentVolumeClaim`), los datos se conservan, incluso despuÃ©s de
  eliminar el Pod.

## [Tipos de volÃºmenes](https://kubernetes.io/docs/concepts/storage/volumes/#volume-types)

Como vimos anteriormente, en Kubernetes existen dos grandes categorÃ­as de volÃºmenes:

- `VolÃºmenes efÃ­meros`: viven mientras el Pod exista.
- `VolÃºmenes persistentes`: sobreviven incluso si el Pod es eliminado.

A continuaciÃ³n, exploramos algunos de los tipos mÃ¡s comunes.

### [ğŸ—‚ï¸ emptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir)

Este es uno de los volÃºmenes efÃ­meros mÃ¡s utilizados.

- `El volumen emptyDir se monta dentro del Pod` y su ciclo de vida estÃ¡ ligado directamente al del Pod, no al de los
  contenedores individuales.
- Se crea `cuando el Pod es asignado a un nodo`, y como su nombre lo indica, `inicialmente estÃ¡ vacÃ­o`.
- Todos los contenedores del Pod pueden `leer y escribir archivos compartidos` en este volumen. Pueden montarlo en la
  misma ruta o en rutas distintas segÃºn se requiera.
- Cuando el `Pod se elimina`, el volumen `emptyDir` tambiÃ©n se `destruye automÃ¡ticamente`, junto con todos los datos
  almacenados en Ã©l. Por eso, se usa comÃºnmente para `almacenar datos temporales`.

ğŸ“Œ Importante:

> La `caÃ­da o reinicio de un contenedor` dentro del Pod `no elimina` el volumen `emptyDir`.
> Los datos almacenados permanecen disponibles mientras el `Pod siga activo en el nodo`.

![01.png](assets/section-15/01.png)

### [ğŸ—‚ï¸ hostPath](https://kubernetes.io/docs/concepts/storage/volumes/#hostpath)

El volumen `hostPath` permite montar directamente un archivo o directorio del sistema de archivos del nodo host
(el Worker Node) dentro del Pod.

- Es `externo al Pod`, pero `local al nodo` donde se ejecuta.
- Su uso estÃ¡ `limitado a escenarios donde se tiene control total del nodo`, y por lo general
  `solo es viable en clÃºsteres con un solo nodo` o para tareas muy especÃ­ficas.

ğŸ“Œ Se puede usar para casos como:

- Acceder a archivos del host que necesita la aplicaciÃ³n (por ejemplo, logs del sistema).
- Exponer sockets de Docker o herramientas de monitoreo.

![02.png](assets/section-15/02.png)

ğŸš¨ Advertencia de seguridad:

> El uso de `hostPath` conlleva `riesgos importantes de seguridad`, ya que permite al contenedor acceder directamente al
> sistema de archivos del nodo, lo que `puede comprometer el nodo completo` si no se tiene cuidado.
>
> `Si puedes evitar usar hostPath, deberÃ­as hacerlo.`
>
> En su lugar, se recomienda utilizar un `PersistentVolume local (local PV)` con las debidas restricciones y
> aislamiento.

ğŸ“ Nota:

> En los siguientes apartados usaremos el `hostPath` por ser mÃ¡s simple y directo en entornos de desarrollo o
> pruebas. Sin embargo, mÃ¡s adelante veremos cÃ³mo reemplazarlo por una alternativa mÃ¡s segura y desacoplada utilizando
> `PersistentVolume` y `PersistentVolumeClaim`.

### ğŸ—‚ï¸[nfs](https://kubernetes.io/docs/concepts/storage/volumes/#nfs), [csi](https://kubernetes.io/docs/concepts/storage/volumes/#csi)

Tanto `nfs` como `csi` son tipos de volÃºmenes que permiten el acceso desde `varios Worker Nodes`, por lo que estÃ¡n
diseÃ±ados para funcionar correctamente en `clÃºsteres multi-nodo`.

Veamos quÃ© hace cada uno:

### ğŸ“ nfs â€“ Network File System

- Un volumen `nfs` permite montar un recurso compartido NFS existente en uno o varios Pods.
- A diferencia de `emptyDir`, `el contenido no se elimina cuando el Pod se borra`; simplemente se desmonta.
- Esto permite que el volumen:
    - `EstÃ© pre-poblado con datos`.
    - `Comparta informaciÃ³n entre mÃºltiples Pods`, incluso si estÃ¡n en nodos distintos.
    - `Admite mÃºltiples escritores simultÃ¡neamente`, lo cual es ideal para escenarios de acceso concurrente.

> ğŸ“Œ Es importante contar con un servidor NFS configurado y accesible desde todos los nodos del clÃºster.

### ğŸ“¦ csi â€“ Container Storage Interface

- CSI define una `interfaz estÃ¡ndar` y extensible para integrar soluciones de almacenamiento externas con Kubernetes.
- Gracias a CSI, los proveedores de almacenamiento (como AWS EBS, GCP PD, Ceph, NetApp, etc.) pueden ofrecer volÃºmenes
  que Kubernetes puede montar automÃ¡ticamente.
- Permite que Kubernetes `interactÃºe con cualquier sistema de almacenamiento compatible con CSI`, tanto para clÃºsteres
  on-premise como en la nube.
- CSI reemplaza gradualmente a muchos controladores in-tree antiguos, y es el enfoque recomendado para nuevas
  implementaciones.

![03.png](assets/section-15/03.png)

