# SecciÃ³n 15: Kubernetes: VolÃºmenes

---

## [ğŸ“¦ IntroducciÃ³n a los VolÃºmenes en Kubernetes](https://kubernetes.io/docs/concepts/storage/volumes/)

En Kubernetes, `los archivos almacenados dentro de un contenedor son efÃ­meros`, lo que representa ciertos desafÃ­os para
aplicaciones que requieren persistencia de datos o almacenamiento compartido.

### ğŸ§¨ Problemas comunes sin volÃºmenes

1. `PÃ©rdida de datos al reiniciar el contenedor`: Si un contenedor se bloquea o se detiene, todos los archivos creados o
   modificados durante su ejecuciÃ³n se pierden, ya que el sistema de archivos del contenedor se reinicia con un estado
   limpio cuando el `kubelet` lo vuelve a lanzar.


2. `Dificultad para compartir datos entre contenedores del mismo Pod`: En situaciones donde mÃºltiples contenedores
   comparten un Pod, puede ser complicado habilitar un sistema de archivos comÃºn entre ellos sin una soluciÃ³n adecuada.

### âœ… Â¿CÃ³mo lo resuelve Kubernetes?

Para abordar estos problemas, `Kubernetes introduce la abstracciÃ³n de volumen`. Esta permite proporcionar
almacenamiento persistente o compartido a los contenedores dentro de un Pod.

> ğŸ“Œ Un `volumen en Kubernetes` es bÃ¡sicamente un directorio accesible desde uno o varios contenedores del Pod, que
> puede estar respaldado por distintos medios de almacenamiento, segÃºn el tipo de volumen utilizado.

### ğŸ§± Tipos de volÃºmenes

Kubernetes soporta diversos tipos de volÃºmenes, y un Pod puede montar varios de ellos simultÃ¡neamente. Se clasifican, de
forma general, en:

- `VolÃºmenes efÃ­meros`: Existen Ãºnicamente durante la vida del Pod. Cuando este se elimina, el volumen tambiÃ©n se
  destruye.

- `VolÃºmenes persistentes`: Sobreviven incluso despuÃ©s de que el Pod se elimina. Su ciclo de vida es independiente del
  Pod, permitiendo que los datos se mantengan y puedan ser reutilizados por nuevos Pods.

> ğŸ” Un volumen, sin importar su tipo, conserva sus datos durante los reinicios de los contenedores dentro del
> mismo Pod. Sin embargo, solo los volÃºmenes persistentes sobreviven a la eliminaciÃ³n del Pod completo.

### ğŸ’¡ Ejemplo simple

SupÃ³n que tienes un Pod con un volumen `emptyDir` (el volumen se monta dentro del pod), y un contenedor escribe un
archivo ahÃ­. Si el contenedor se reinicia por error interno, `el archivo sigue estando presente` en ese volumen cuando
el contenedor se vuelve a iniciar.

Sin embargo, si se elimina el `Pod` completo, entonces:

- Si era un `volumen efÃ­mero` (`emptyDir`), el contenido se borra.
- Si era un `volumen persistente` (como un `persistentVolumeClaim`), los datos se conservan, incluso despuÃ©s de
  eliminar el Pod.

## [Tipos de volÃºmenes](https://kubernetes.io/docs/concepts/storage/volumes/#volume-types)

Como vimos anteriormente, en Kubernetes existen dos grandes categorÃ­as de volÃºmenes:

- `VolÃºmenes efÃ­meros`: viven mientras el Pod exista.
- `VolÃºmenes persistentes`: sobreviven incluso si el Pod es eliminado.

A continuaciÃ³n, exploramos algunos de los tipos mÃ¡s comunes.

### [ğŸ—‚ï¸ emptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir)

Este es uno de los volÃºmenes efÃ­meros mÃ¡s utilizados.

- `El volumen emptyDir se monta dentro del Pod` y su ciclo de vida estÃ¡ ligado directamente al del Pod, no al de los
  contenedores individuales.
- Se crea `cuando el Pod es asignado a un nodo`, y como su nombre lo indica, `inicialmente estÃ¡ vacÃ­o`.
- Todos los contenedores del Pod pueden `leer y escribir archivos compartidos` en este volumen. Pueden montarlo en la
  misma ruta o en rutas distintas segÃºn se requiera.
- Cuando el `Pod se elimina`, el volumen `emptyDir` tambiÃ©n se `destruye automÃ¡ticamente`, junto con todos los datos
  almacenados en Ã©l. Por eso, se usa comÃºnmente para `almacenar datos temporales`.

ğŸ“Œ Importante:

> La `caÃ­da o reinicio de un contenedor` dentro del Pod `no elimina` el volumen `emptyDir`.
> Los datos almacenados permanecen disponibles mientras el `Pod siga activo en el nodo`.

![01.png](assets/section-15/01.png)

### [ğŸ—‚ï¸ hostPath](https://kubernetes.io/docs/concepts/storage/volumes/#hostpath)

El volumen `hostPath` permite montar directamente un archivo o directorio del sistema de archivos del nodo host
(el Worker Node) dentro del Pod.

- Es `externo al Pod`, pero `local al nodo` donde se ejecuta.
- Su uso estÃ¡ `limitado a escenarios donde se tiene control total del nodo`, y por lo general
  `solo es viable en clÃºsteres con un solo nodo` o para tareas muy especÃ­ficas.

ğŸ“Œ Se puede usar para casos como:

- Acceder a archivos del host que necesita la aplicaciÃ³n (por ejemplo, logs del sistema).
- Exponer sockets de Docker o herramientas de monitoreo.

![02.png](assets/section-15/02.png)

ğŸš¨ Advertencia de seguridad:

> El uso de `hostPath` conlleva `riesgos importantes de seguridad`, ya que permite al contenedor acceder directamente al
> sistema de archivos del nodo, lo que `puede comprometer el nodo completo` si no se tiene cuidado.
>
> `Si puedes evitar usar hostPath, deberÃ­as hacerlo.`
>
> En su lugar, se recomienda utilizar un `PersistentVolume local (local PV)` con las debidas restricciones y
> aislamiento.

ğŸ“ Nota:

> En los siguientes apartados usaremos el `hostPath` por ser mÃ¡s simple y directo en entornos de desarrollo o
> pruebas. Sin embargo, mÃ¡s adelante veremos cÃ³mo reemplazarlo por una alternativa mÃ¡s segura y desacoplada utilizando
> `PersistentVolume` y `PersistentVolumeClaim`.

### ğŸ—‚ï¸[nfs](https://kubernetes.io/docs/concepts/storage/volumes/#nfs), [csi](https://kubernetes.io/docs/concepts/storage/volumes/#csi)

Tanto `nfs` como `csi` son tipos de volÃºmenes que permiten el acceso desde `varios Worker Nodes`, por lo que estÃ¡n
diseÃ±ados para funcionar correctamente en `clÃºsteres multi-nodo`.

Veamos quÃ© hace cada uno:

### ğŸ“ nfs â€“ Network File System

- Un volumen `nfs` permite montar un recurso compartido NFS existente en uno o varios Pods.
- A diferencia de `emptyDir`, `el contenido no se elimina cuando el Pod se borra`; simplemente se desmonta.
- Esto permite que el volumen:
    - `EstÃ© pre-poblado con datos`.
    - `Comparta informaciÃ³n entre mÃºltiples Pods`, incluso si estÃ¡n en nodos distintos.
    - `Admite mÃºltiples escritores simultÃ¡neamente`, lo cual es ideal para escenarios de acceso concurrente.

> ğŸ“Œ Es importante contar con un servidor NFS configurado y accesible desde todos los nodos del clÃºster.

### ğŸ“¦ csi â€“ Container Storage Interface

- CSI define una `interfaz estÃ¡ndar` y extensible para integrar soluciones de almacenamiento externas con Kubernetes.
- Gracias a CSI, los proveedores de almacenamiento (como AWS EBS, GCP PD, Ceph, NetApp, etc.) pueden ofrecer volÃºmenes
  que Kubernetes puede montar automÃ¡ticamente.
- Permite que Kubernetes `interactÃºe con cualquier sistema de almacenamiento compatible con CSI`, tanto para clÃºsteres
  on-premise como en la nube.
- CSI reemplaza gradualmente a muchos controladores in-tree antiguos, y es el enfoque recomendado para nuevas
  implementaciones.

![03.png](assets/section-15/03.png)

## ğŸ› ï¸ Configurando un volumen hostPath para MySQL

Cuando trabajamos con contenedores en `Kubernetes`, los datos almacenados en el sistema de archivos del contenedor se
eliminan si el contenedor o el Pod se reinicia o destruye. Para evitar esta pÃ©rdida de datos, debemos montar un volumen
externo al contenedor que persista los datos, incluso si el Pod deja de existir.

### ğŸ” Â¿QuÃ© tipo de volumen usar?

En este escenario, usaremos el tipo de volumen `hostPath`, que permite montar un directorio local del nodo (el host)
dentro del contenedor. De este modo, aunque el Pod sea eliminado, los datos seguirÃ¡n existiendo en el sistema de
archivos del nodo.

> ğŸ’¡ MÃ¡s adelante aprenderemos a usar una opciÃ³n mÃ¡s segura y desacoplada: los `PersistentVolume` y
`PersistentVolumeClaim`.

### ğŸ“¦ Definiendo el volumen `hostPath` para MySQL

En este punto queremos configurar el volumen para la base de datos MySQL utilizada por el microservicio de usuarios.
Para ello, modificamos el archivo `deployment-mysql.yml` con la siguiente configuraciÃ³n:

````yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: d-mysql
spec:
  replicas: 1
  selector:
    matchLabels:
      app: d-mysql
  template:
    metadata:
      labels:
        app: d-mysql
    spec:
      containers:
        - image: mysql:8.0.41-debian
          name: c-mysql
          ports:
            - containerPort: 3306
          env:
            - name: MYSQL_ROOT_PASSWORD
              value: magadiflo
            - name: MYSQL_DATABASE
              value: db_user_service
            - name: MYSQL_USER
              value: admin
            - name: MYSQL_PASSWORD
              value: magadiflo
          volumeMounts:
            - name: mysql-data
              mountPath: /var/lib/mysql
      volumes:
        - name: mysql-data
          hostPath:
            path: /var/lib/mysql
            type: DirectoryOrCreate
````

### ğŸ§© Estructura de configuraciÃ³n

La definiciÃ³n del volumen consta de dos partes principales:

1. ConfiguraciÃ³n del volumen

````yaml
volumes:
  - name: mysql-data
    hostPath:
      path: /var/lib/mysql
      type: DirectoryOrCreate
````

Â¿QuÃ© significa esto?

- `name: mysql-data`: nombre del volumen, que usaremos como referencia en el contenedor.
- `hostPath.path: /var/lib/mysql`: ruta del sistema de archivos del nodo host donde se almacenarÃ¡n los datos.
  > Esta ruta no tiene que ser igual a la del contenedor, pero es comÃºn usar la misma por coherencia.
- `type: DirectoryOrCreate`: si el directorio ya existe en el nodo, lo reutiliza; si no, lo crea automÃ¡ticamente.

2. ConfiguraciÃ³n del `volumeMounts` en el contenedor

````yml
volumeMounts:
  - name: mysql-data
    mountPath: /var/lib/mysql
````

Â¿QuÃ© significa esto?

- `name: mysql-data`: nombre del volumen a montar, debe coincidir con el definido en volumes.
- `mountPath: /var/lib/mysql`: ruta dentro del contenedor MySQL donde se almacenarÃ¡n los datos.

> Es muy importante que esta ruta (`mountPath`) coincida exactamente con el directorio que MySQL usa internamente para
> almacenar sus datos. En el caso de la imagen oficial `mysql:8.0.41-debian`, ese directorio es `/var/lib/mysql`.

ğŸ“Œ Nota importante
> Aunque el directorio del host (`hostPath.path`) podrÃ­a ser diferente, se recomienda usar la misma ruta que el
> `mountPath` del contenedor para mantener la coherencia y facilitar el mantenimiento.
