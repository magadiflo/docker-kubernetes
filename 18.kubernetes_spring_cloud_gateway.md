# Secci√≥n 18: Kubernetes: Spring Cloud Gateway

---

## Introducci√≥n

En esta secci√≥n aprenderemos a crear y configurar un `API Gateway` utilizando `Spring Cloud Gateway` dentro de un
entorno `Kubernetes`.

El `API Gateway` cumple un rol fundamental en una arquitectura de microservicios, ya que act√∫a como un punto de entrada
√∫nico para todos los clientes. Entre sus funciones principales se encuentran:

- `Enrutamiento din√°mico`: redirige las solicitudes entrantes a los microservicios correspondientes.
- `Balanceo de carga`: distribuye las peticiones entre m√∫ltiples r√©plicas de un mismo servicio.
- `Cross-cutting concerns (Preocupaciones transversales)`: como autenticaci√≥n, autorizaci√≥n, logging, m√©tricas, etc.
- `Desacoplamiento`: los clientes no necesitan conocer la ubicaci√≥n real de cada microservicio, sino que solo
  interact√∫an con el `gateway`.

En este caso, nuestro `Spring Cloud Gateway` se integrar√° con `Kubernetes Service Discovery`, aprovechando el cliente
de `Kubernetes` para descubrir din√°micamente los servicios disponibles.

## Creando el servicio Spring Cloud Gateway

Generamos un nuevo proyecto desde `Spring Initializr`, seleccionando:

````xml
<!--Spring Boot 3.5.4-->
<!--Spring Cloud Version 2025.0.0-->
<!--Java 21-->

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway-server-webflux</artifactId>
    </dependency>

    <!--Agregados manualmente-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-kubernetes-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-kubernetes-client-loadbalancer</artifactId>
    </dependency>
    <!--/Agregados manualmente-->

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

## Configurando el servicio Spring Cloud Gateway

Para habilitar el descubrimiento de servicios en `Kubernetes`, a√±adimos la anotaci√≥n `@EnableDiscoveryClient` en la
clase principal de la aplicaci√≥n.

````java

@EnableDiscoveryClient
@SpringBootApplication
public class GatewayServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(GatewayServerApplication.class, args);
    }
}
````

De esta forma, nuestro `gateway-server` podr√° registrarse como cliente de Kubernetes y descubrir autom√°ticamente otros
servicios desplegados en el cl√∫ster.

En el archivo `application.yml`, configuramos:

- El puerto donde correr√° el contenedor (`8090` por defecto, configurable con `CONTAINER_PORT`).
- El nombre de la aplicaci√≥n, necesario para la integraci√≥n con `Kubernetes Service Discovery`.
- Configuraci√≥n de errores para incluir el mensaje en las respuestas (`include-message: always`).

````yml
server:
  port: ${CONTAINER_PORT:8090}
  error:
    include-message: always

spring:
  application:
    name: gateway-server
````

üëâ Con esto dejamos listo el esqueleto del `Gateway`, que luego iremos ampliando con rutas, balanceo de carga y pruebas.

## Configurando rutas de microservicios en Gateway

En el archivo `application.yml` del `gateway-server` agregamos la configuraci√≥n de las rutas. Estas definen c√≥mo el
gateway intercepta las solicitudes entrantes y las redirige al microservicio correspondiente.

````yml
spring:
  application:
    name: gateway-server
  cloud:
    gateway:
      routes:
        - id: course-service-route
          uri: lb://s-course-service
          predicates:
            - Path=/api/v1/courses/**
        - id: user-service-route
          uri: lb://s-user-service
          predicates:
            - Path=/api/v1/users/**
````

**Explicaci√≥n de los par√°metros principales**

- `id`
    - Es el identificador √∫nico de la ruta dentro del Gateway. Sirve solo como referencia interna y para prop√≥sitos de
      administraci√≥n o debugging.
    - Ejemplo: `course-service-route`.

- `uri`
    - Define el destino al que `Gateway` redirigir√° la solicitud.
    - El prefijo `lb://` indica que se usar√° `Spring Cloud LoadBalancer` junto con `Kubernetes Service Discovery` para
      balancear las peticiones entre los pods disponibles del servicio.
    - El nombre que se coloca despu√©s de `lb://` debe `coincidir` con el `nombre del Service en Kubernetes`, ya que es
      este objeto el que expone los pods y permite resolverlos mediante DNS dentro del cluster.
    - Ejemplo: `lb://s-course-service` ‚Üí donde `s-course-service` corresponde al `Service` definido en `Kubernetes`.

- `predicates`
    - Son condiciones que debe cumplir la solicitud para que se aplique la ruta.
    - El m√°s com√∫n es `Path`, que filtra seg√∫n la URL solicitada. En este caso:
        - Todo lo que llegue a `/api/v1/courses/**` se enviar√° al `servicio de cursos`.
        - Todo lo que llegue a `/api/v1/users/**` se enviar√° al `servicio de usuarios`.

> ‚ö° Con esta configuraci√≥n, ya podemos acceder a nuestros microservicios a trav√©s del Gateway, en lugar de exponer cada
> uno individualmente.

## Creando la imagen Docker del gateway-server

Para poder desplegar nuestro `Spring Cloud Gateway` en `Kubernetes`, primero necesitamos `dockerizar` la aplicaci√≥n.

En este caso, aprovecharemos el mismo `Dockerfile` que ya usamos en los otros microservicios y lo adaptaremos a las
necesidades del `gateway-server`.

La √∫nica modificaci√≥n necesaria es definir el puerto de la aplicaci√≥n mediante la variable de entorno
`CONTAINER_PORT=8090`. El resto se mantiene igual.

````dockerfile
ARG JDK_VERSION=21-jdk-alpine
ARG JRE_VERSION=21-jre-alpine

FROM eclipse-temurin:${JDK_VERSION} AS dependencies
WORKDIR /app
COPY ./mvnw ./
COPY ./.mvn ./.mvn
COPY ./pom.xml ./
RUN sed -i -e 's/\r$//' ./mvnw
RUN ./mvnw dependency:go-offline
COPY ./src ./src
RUN ./mvnw clean package -DskipTests

FROM eclipse-temurin:${JRE_VERSION} AS builder
WORKDIR /app
COPY --from=dependencies /app/target/*.jar ./app.jar
RUN java -Djarmode=layertools -jar app.jar extract

FROM eclipse-temurin:${JRE_VERSION} AS runner
WORKDIR /app
RUN mkdir ./logs
COPY --from=builder /app/dependencies ./
COPY --from=builder /app/spring-boot-loader ./
COPY --from=builder /app/snapshot-dependencies ./
COPY --from=builder /app/application ./

ENV CONTAINER_PORT=8090
EXPOSE ${CONTAINER_PORT}
CMD ["java", "org.springframework.boot.loader.launch.JarLauncher"]
````

**Importante**
> Antes de construir la imagen con el `Dockerfile`, es necesario crear en `Docker Hub` un nuevo repositorio para alojar
> la imagen del `gateway-server`.

## Construcci√≥n y publicaci√≥n de la imagen del gateway-server

Con el `Dockerfile` listo, procedemos a construir la imagen de nuestro microservicio `gateway-server`. Para ello,
ejecutamos el siguiente comando desde la carpeta ra√≠z del proyecto:

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-18)                                        
$ docker image build -t magadiflo/gateway-server .\infrastructure\gateway-server                                                                   
[+] Building 43.3s (25/25) FINISHED                                                                                                                
 => [internal] load build definition from Dockerfile                                                                                               
 => => transferring dockerfile: 901B                                                                                                               
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jre-alpine                                                                   
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                                   
 => [auth] library/eclipse-temurin:pull token for registry-1.docker.io                                                                             
 => [internal] load .dockerignore                                                                                                                  
 => => transferring context: 2B                                                                                                                    
 => [dependencies 1/9] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:df8ce8302ed2ed1690ef490c633981b07e752b373b5fdf796960fb2eb0d640ea
 => [builder 1/4] FROM docker.io/library/eclipse-temurin:21-jre-alpine@sha256:4ca7eff3ab0ef9b41f5fefa35efaeda9ed8d26e161e1192473b24b3a6c348aef     
 => [internal] load build context                                                                                                                  
 => => transferring context: 17.48kB                                                                                                               
 => CACHED [dependencies 2/9] WORKDIR /app                                                                                                         
 => CACHED [dependencies 3/9] COPY ./mvnw ./                                                                                                       
 => [dependencies 4/9] COPY ./.mvn ./.mvn                                                                                                          
 => [dependencies 5/9] COPY ./pom.xml ./                                                                                                           
 => [dependencies 6/9] RUN sed -i -e 's/\r$//' ./mvnw                                                                                              
 => [dependencies 7/9] RUN ./mvnw dependency:go-offline                                                                                            
 => [dependencies 8/9] COPY ./src ./src                                                                                                            
 => [dependencies 9/9] RUN ./mvnw clean package -DskipTests                                                                                        
 => CACHED [builder 2/4] WORKDIR /app                                                                                                              
 => [builder 3/4] COPY --from=dependencies /app/target/*.jar ./app.jar                                                                             
 => [builder 4/4] RUN java -Djarmode=layertools -jar app.jar extract                                                                               
 => CACHED [runner 3/7] RUN mkdir ./logs                                                                                                           
 => [runner 4/7] COPY --from=builder /app/dependencies ./                                                                                          
 => [runner 5/7] COPY --from=builder /app/spring-boot-loader ./                                                                                    
 => [runner 6/7] COPY --from=builder /app/snapshot-dependencies ./                                                                                 
 => [runner 7/7] COPY --from=builder /app/application ./                                                                                           
 => exporting to image                                                                                                                             
 => => exporting layers                                                                                                                            
 => => writing image sha256:323ec8fd11edc768f7933a298df94d016276e96b2863e47e290f1926759e6813                                                       
 => => naming to docker.io/magadiflo/gateway-server                                                                                                
````

La salida muestra el proceso de construcci√≥n, y al finalizar, veremos que la imagen se cre√≥ correctamente con el nombre
`magadiflo/gateway-server`.

````bash
$ docker image ls
REPOSITORY                    TAG             IMAGE ID       CREATED          SIZE
magadiflo/gateway-server      latest          323ec8fd11ed   53 seconds ago   277MB
magadiflo/user-service        latest          b5402fbd8ed0   4 days ago       306MB
magadiflo/course-service      latest          d0a604620716   11 days ago      305MB
redis                         8.0.3-alpine    c25e2f66b829   6 weeks ago      60.5MB
postgres                      17-alpine       f40315d0e8a6   2 months ago     279MB
gcr.io/k8s-minikube/kicbase   v0.0.47         795ea6a69ce6   3 months ago     1.31GB
mysql                         8.0.41-debian   4340b8ad7a7c   7 months ago     610MB
````

Finalmente, subimos la imagen a nuestro repositorio en `Docker Hub` para que est√© disponible cuando despleguemos en
Kubernetes:

````bash
$ docker push magadiflo/gateway-server
````
