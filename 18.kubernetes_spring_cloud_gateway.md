# Secci√≥n 18: Kubernetes: Spring Cloud Gateway

---

## Introducci√≥n

En esta secci√≥n aprenderemos a crear y configurar un `API Gateway` utilizando `Spring Cloud Gateway` dentro de un
entorno `Kubernetes`.

El `API Gateway` cumple un rol fundamental en una arquitectura de microservicios, ya que act√∫a como un punto de entrada
√∫nico para todos los clientes. Entre sus funciones principales se encuentran:

- `Enrutamiento din√°mico`: redirige las solicitudes entrantes a los microservicios correspondientes.
- `Balanceo de carga`: distribuye las peticiones entre m√∫ltiples r√©plicas de un mismo servicio.
- `Cross-cutting concerns (Preocupaciones transversales)`: como autenticaci√≥n, autorizaci√≥n, logging, m√©tricas, etc.
- `Desacoplamiento`: los clientes no necesitan conocer la ubicaci√≥n real de cada microservicio, sino que solo
  interact√∫an con el `gateway`.

En este caso, nuestro `Spring Cloud Gateway` se integrar√° con `Kubernetes Service Discovery`, aprovechando el cliente
de `Kubernetes` para descubrir din√°micamente los servicios disponibles.

## Creando el servicio Spring Cloud Gateway

Generamos un nuevo proyecto desde `Spring Initializr`, seleccionando:

````xml
<!--Spring Boot 3.5.4-->
<!--Spring Cloud Version 2025.0.0-->
<!--Java 21-->

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway-server-webflux</artifactId>
    </dependency>

    <!--Agregados manualmente-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-kubernetes-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-kubernetes-client-loadbalancer</artifactId>
    </dependency>
    <!--/Agregados manualmente-->

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

## Configurando el servicio Spring Cloud Gateway

Para habilitar el descubrimiento de servicios en `Kubernetes`, a√±adimos la anotaci√≥n `@EnableDiscoveryClient` en la
clase principal de la aplicaci√≥n.

````java

@EnableDiscoveryClient
@SpringBootApplication
public class GatewayServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(GatewayServerApplication.class, args);
    }
}
````

De esta forma, nuestro `gateway-server` podr√° registrarse como cliente de Kubernetes y descubrir autom√°ticamente otros
servicios desplegados en el cl√∫ster.

En el archivo `application.yml`, configuramos:

- El puerto donde correr√° el contenedor (`8090` por defecto, configurable con `CONTAINER_PORT`).
- El nombre de la aplicaci√≥n, necesario para la integraci√≥n con `Kubernetes Service Discovery`.
- Configuraci√≥n de errores para incluir el mensaje en las respuestas (`include-message: always`).

````yml
server:
  port: ${CONTAINER_PORT:8090}
  error:
    include-message: always

spring:
  application:
    name: gateway-server
````

üëâ Con esto dejamos listo el esqueleto del `Gateway`, que luego iremos ampliando con rutas, balanceo de carga y pruebas.

## Configurando rutas de microservicios en Gateway

En el archivo `application.yml` del `gateway-server` agregamos la configuraci√≥n de las rutas. Estas definen c√≥mo el
gateway intercepta las solicitudes entrantes y las redirige al microservicio correspondiente.

````yml
spring:
  application:
    name: gateway-server
  cloud:
    gateway:
      routes:
        - id: course-service-route
          uri: lb://s-course-service
          predicates:
            - Path=/api/v1/courses/**
        - id: user-service-route
          uri: lb://s-user-service
          predicates:
            - Path=/api/v1/users/**
````

**Explicaci√≥n de los par√°metros principales**

- `id`
    - Es el identificador √∫nico de la ruta dentro del Gateway. Sirve solo como referencia interna y para prop√≥sitos de
      administraci√≥n o debugging.
    - Ejemplo: `course-service-route`.

- `uri`
    - Define el destino al que `Gateway` redirigir√° la solicitud.
    - El prefijo `lb://` indica que se usar√° `Spring Cloud LoadBalancer` junto con `Kubernetes Service Discovery` para
      balancear las peticiones entre los pods disponibles del servicio.
    - El nombre que se coloca despu√©s de `lb://` debe `coincidir` con el `nombre del Service en Kubernetes`, ya que es
      este objeto el que expone los pods y permite resolverlos mediante DNS dentro del cluster.
    - Ejemplo: `lb://s-course-service` ‚Üí donde `s-course-service` corresponde al `Service` definido en `Kubernetes`.

- `predicates`
    - Son condiciones que debe cumplir la solicitud para que se aplique la ruta.
    - El m√°s com√∫n es `Path`, que filtra seg√∫n la URL solicitada. En este caso:
        - Todo lo que llegue a `/api/v1/courses/**` se enviar√° al `servicio de cursos`.
        - Todo lo que llegue a `/api/v1/users/**` se enviar√° al `servicio de usuarios`.

> ‚ö° Con esta configuraci√≥n, ya podemos acceder a nuestros microservicios a trav√©s del Gateway, en lugar de exponer cada
> uno individualmente.

## Creando la imagen Docker del gateway-server

Para poder desplegar nuestro `Spring Cloud Gateway` en `Kubernetes`, primero necesitamos `dockerizar` la aplicaci√≥n.

En este caso, aprovecharemos el mismo `Dockerfile` que ya usamos en los otros microservicios y lo adaptaremos a las
necesidades del `gateway-server`.

La √∫nica modificaci√≥n necesaria es definir el puerto de la aplicaci√≥n mediante la variable de entorno
`CONTAINER_PORT=8090`. El resto se mantiene igual.

````dockerfile
ARG JDK_VERSION=21-jdk-alpine
ARG JRE_VERSION=21-jre-alpine

FROM eclipse-temurin:${JDK_VERSION} AS dependencies
WORKDIR /app
COPY ./mvnw ./
COPY ./.mvn ./.mvn
COPY ./pom.xml ./
RUN sed -i -e 's/\r$//' ./mvnw
RUN ./mvnw dependency:go-offline
COPY ./src ./src
RUN ./mvnw clean package -DskipTests

FROM eclipse-temurin:${JRE_VERSION} AS builder
WORKDIR /app
COPY --from=dependencies /app/target/*.jar ./app.jar
RUN java -Djarmode=layertools -jar app.jar extract

FROM eclipse-temurin:${JRE_VERSION} AS runner
WORKDIR /app
RUN mkdir ./logs
COPY --from=builder /app/dependencies ./
COPY --from=builder /app/spring-boot-loader ./
COPY --from=builder /app/snapshot-dependencies ./
COPY --from=builder /app/application ./

ENV CONTAINER_PORT=8090
EXPOSE ${CONTAINER_PORT}
CMD ["java", "org.springframework.boot.loader.launch.JarLauncher"]
````

**Importante**
> Antes de construir la imagen con el `Dockerfile`, es necesario crear en `Docker Hub` un nuevo repositorio para alojar
> la imagen del `gateway-server`.

## Construcci√≥n y publicaci√≥n de la imagen del gateway-server

Con el `Dockerfile` listo, procedemos a construir la imagen de nuestro microservicio `gateway-server`. Para ello,
ejecutamos el siguiente comando desde la carpeta ra√≠z del proyecto:

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-18)                                        
$ docker image build -t magadiflo/gateway-server .\infrastructure\gateway-server                                                                   
[+] Building 43.3s (25/25) FINISHED                                                                                                                
 => [internal] load build definition from Dockerfile                                                                                               
 => => transferring dockerfile: 901B                                                                                                               
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jre-alpine                                                                   
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                                   
 => [auth] library/eclipse-temurin:pull token for registry-1.docker.io                                                                             
 => [internal] load .dockerignore                                                                                                                  
 => => transferring context: 2B                                                                                                                    
 => [dependencies 1/9] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:df8ce8302ed2ed1690ef490c633981b07e752b373b5fdf796960fb2eb0d640ea
 => [builder 1/4] FROM docker.io/library/eclipse-temurin:21-jre-alpine@sha256:4ca7eff3ab0ef9b41f5fefa35efaeda9ed8d26e161e1192473b24b3a6c348aef     
 => [internal] load build context                                                                                                                  
 => => transferring context: 17.48kB                                                                                                               
 => CACHED [dependencies 2/9] WORKDIR /app                                                                                                         
 => CACHED [dependencies 3/9] COPY ./mvnw ./                                                                                                       
 => [dependencies 4/9] COPY ./.mvn ./.mvn                                                                                                          
 => [dependencies 5/9] COPY ./pom.xml ./                                                                                                           
 => [dependencies 6/9] RUN sed -i -e 's/\r$//' ./mvnw                                                                                              
 => [dependencies 7/9] RUN ./mvnw dependency:go-offline                                                                                            
 => [dependencies 8/9] COPY ./src ./src                                                                                                            
 => [dependencies 9/9] RUN ./mvnw clean package -DskipTests                                                                                        
 => CACHED [builder 2/4] WORKDIR /app                                                                                                              
 => [builder 3/4] COPY --from=dependencies /app/target/*.jar ./app.jar                                                                             
 => [builder 4/4] RUN java -Djarmode=layertools -jar app.jar extract                                                                               
 => CACHED [runner 3/7] RUN mkdir ./logs                                                                                                           
 => [runner 4/7] COPY --from=builder /app/dependencies ./                                                                                          
 => [runner 5/7] COPY --from=builder /app/spring-boot-loader ./                                                                                    
 => [runner 6/7] COPY --from=builder /app/snapshot-dependencies ./                                                                                 
 => [runner 7/7] COPY --from=builder /app/application ./                                                                                           
 => exporting to image                                                                                                                             
 => => exporting layers                                                                                                                            
 => => writing image sha256:323ec8fd11edc768f7933a298df94d016276e96b2863e47e290f1926759e6813                                                       
 => => naming to docker.io/magadiflo/gateway-server                                                                                                
````

La salida muestra el proceso de construcci√≥n, y al finalizar, veremos que la imagen se cre√≥ correctamente con el nombre
`magadiflo/gateway-server`.

````bash
$ docker image ls
REPOSITORY                    TAG             IMAGE ID       CREATED          SIZE
magadiflo/gateway-server      latest          323ec8fd11ed   53 seconds ago   277MB
magadiflo/user-service        latest          b5402fbd8ed0   4 days ago       306MB
magadiflo/course-service      latest          d0a604620716   11 days ago      305MB
redis                         8.0.3-alpine    c25e2f66b829   6 weeks ago      60.5MB
postgres                      17-alpine       f40315d0e8a6   2 months ago     279MB
gcr.io/k8s-minikube/kicbase   v0.0.47         795ea6a69ce6   3 months ago     1.31GB
mysql                         8.0.41-debian   4340b8ad7a7c   7 months ago     610MB
````

Finalmente, subimos la imagen a nuestro repositorio en `Docker Hub` para que est√© disponible cuando despleguemos en
Kubernetes:

````bash
$ docker push magadiflo/gateway-server
````

## Escribiendo deployment y service del gateway-server

Para desplegar nuestro microservicio `gateway-server` en Kubernetes, necesitamos definir tanto el `Deployment` como el
`Service`.

### Deployment del gateway-server

Creamos el archivo `deployment-gateway.yml` con la siguiente configuraci√≥n:

````yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: d-gateway-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: d-gateway-server
  template:
    metadata:
      labels:
        app: d-gateway-server
    spec:
      containers:
        - image: magadiflo/gateway-server:latest
          name: c-gateway-server
          ports:
            - containerPort: 8090
          env:
            - name: CONTAINER_PORT
              value: '8090'
````

üìå Explicaci√≥n:

- `replicas`: N√∫mero de r√©plicas del `pod`. En este caso, una sola.
- `containers.image`: Imagen de Docker previamente construida y subida a `Docker Hub`.
- `containerPort`: Puerto expuesto dentro del contenedor.
- `env`: Variable de entorno que define el puerto del contenedor (`CONTAINER_PORT=8090`).

### Service del gateway-server

Luego, creamos el archivo `service-gateway.yml` que expone nuestro `Deployment` hacia otros servicios o hacia el
exterior:

````yml
apiVersion: v1
kind: Service
metadata:
  name: s-gateway-server
spec:
  ports:
    - port: 8090
      protocol: TCP
      targetPort: 8090
  selector:
    app: d-gateway-server
  type: LoadBalancer
````

üìå Explicaci√≥n:

- `selector`: Vincula el servicio con los pods que tengan la etiqueta `app: d-gateway-server`.
- `ports`:
    - `port`: Puerto por el que el servicio ser√° accesible dentro del cluster.
    - `targetPort`: Puerto expuesto por el contenedor (`8090`).
- `type: LoadBalancer`: Permite exponer el servicio hacia fuera del cluster (√∫til en nubes p√∫blicas; en `Minikube` se
  traduce en un `NodePort`).

> ‚úÖ Con estos dos manifiestos (`deployment-gateway.yml` y `service-gateway.yml`) ya tenemos listo el despliegue de
> nuestro `API Gateway` dentro de `Kubernetes`.

## Aplicando deployment y service del gateway-server

Una vez creados los archivos `deployment-gateway.yml` y `service-gateway.yml`, aplicamos ambos recursos en Kubernetes:

````bash
$ kubectl apply -f .\kubernetes\deployments\deployment-gateway.yml -f .\kubernetes\services\service-gateway.yml
deployment.apps/d-gateway-server created
service/s-gateway-server created
````

### Verificando el servicio

Comprobamos que el servicio `s-gateway-server` ha sido creado correctamente:

````bash
$ kubectl get service
NAME               TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
kubernetes         ClusterIP      10.96.0.1        <none>        443/TCP          35d
s-course-service   LoadBalancer   10.101.6.84      <pending>     8002:31033/TCP   34d
s-gateway-server   LoadBalancer   10.110.30.131    <pending>     8090:31371/TCP   65s
s-mysql            ClusterIP      10.98.162.202    <none>        3306/TCP         34d
s-postgres         ClusterIP      10.110.100.114   <none>        5432/TCP         34d
s-user-service     LoadBalancer   10.103.167.107   <pending>     8001:31956/TCP   34d
````

‚úÖ Vemos que el servicio `s-gateway-server` est√° expuesto en el puerto `8090`.

### Verificando el deployment

Luego revisamos que el deployment `d-gateway-server` se haya creado:

````bash
$ kubectl get deployments
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
d-course-service   1/1     1            1           10d
d-gateway-server   1/1     1            1           94s
d-mysql            1/1     1            1           28d
d-postgres         1/1     1            1           27d
d-user-service     3/3     3            3           2d23h
````

‚úÖ Confirmamos que `d-gateway-server` est√° en estado `READY` con 1 r√©plica disponible.

### Verificando el pod

Finalmente, comprobamos que el pod correspondiente al deployment se est√© ejecutando:

````bash
$ kubectl get pods
NAME                               READY   STATUS    RESTARTS       AGE
d-course-service-986cc5555-2wxvh   1/1     Running   12 (17m ago)   10d
d-gateway-server-b5855f846-29q52   1/1     Running   0              106s
d-mysql-5ffd47dd8-ctmt8            1/1     Running   20 (17m ago)   18d
d-postgres-67b99b466d-c27wb        1/1     Running   21 (17m ago)   18d
d-user-service-7f97954958-kxr66    1/1     Running   3 (17m ago)    2d23h
d-user-service-7f97954958-wqq8q    1/1     Running   3 (17m ago)    2d23h
d-user-service-7f97954958-zp9t6    1/1     Running   3 (17m ago)    2d23h
````

‚úÖ El pod `d-gateway-server-b5855f846-29q52` est√° en estado `Running`, confirmando que la aplicaci√≥n fue desplegada
exitosamente en el cl√∫ster.

## Verificamos el funcionamiento del gateway-server

En este punto, ya contamos con el `gateway-server` desplegado en `Kubernetes` y funcionando como √∫nico punto de
entrada a trav√©s del cual se canalizan todas las peticiones hacia los microservicios de usuarios y cursos. Este es
precisamente el objetivo de incorporar un `API Gateway` en la arquitectura.

Obtenemos la URL del servicio `s-gateway-server`:

````bash
$ minikube service s-gateway-server --url
http://127.0.0.1:57541
! Because you are using a Docker driver on windows, the terminal needs to be open to run it.
````

### Probando acceso al microservicio de cursos

Ejecutamos una petici√≥n hacia el endpoint de cursos a trav√©s del `gateway-server`. El microservicio de cursos,
internamente, realiza una llamada al microservicio de usuarios para obtener los usuarios relacionados a cada curso.

````bash
$ curl -v -G --data "loadRelations=true" http://127.0.0.1:57541/api/v1/courses | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Sat, 23 Aug 2025 04:37:49 GMT
<
[
  {
    "id": 1,
    "name": "Spring Boot 3",
    "users": [
      {
        "id": 2,
        "name": "Milagros",
        "email": "milagros@gmail.com",
        "password": "123456"
      }
    ]
  },
  {
    "id": 2,
    "name": "Spring WebFlux",
    "users": [
      {
        "id": 1,
        "name": "Martin",
        "email": "martin@gmail.com",
        "password": "12345"
      }
    ]
  },
  {
    "id": 3,
    "name": "Reactive Programming",
    "users": []
  },
  {
    "id": 4,
    "name": "Docker",
    "users": []
  },
  {
    "id": 5,
    "name": "Kubernetes",
    "users": []
  }
]
````

Esto demuestra que el flujo de comunicaci√≥n funciona correctamente: la petici√≥n pasa por el:
> Gateway ‚Üí llega al microservicio de cursos ‚Üí este se comunica con usuarios ‚Üí y se retorna la respuesta unificada.

### Probando acceso al microservicio de usuarios

Ahora hacemos una petici√≥n hacia el endpoint de usuarios utilizando la misma URL del `gateway-server`.

````bash
$ curl -v http://127.0.0.1:57541/api/v1/users/info | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Sat, 23 Aug 2025 04:40:03 GMT
<
{
  "POD_NAME": "d-user-service-7f97954958-wqq8q",
  "users": [
    {
      "id": 1,
      "name": "Martin",
      "email": "martin@gmail.com",
      "password": "12345"
    },
    {
      "id": 2,
      "name": "Milagros",
      "email": "milagros@gmail.com",
      "password": "123456"
    }
  ],
  "POD_IP": "10.244.1.84",
  "config_text": "Configuraciones del perfil activo [dev] desde [configmap-user.yml]"
}
````

Adem√°s de los datos de usuarios, se incluye informaci√≥n adicional del pod que respondi√≥ la petici√≥n (`POD_NAME` y
`POD_IP`).

Si repetimos esta misma consulta varias veces, deber√≠amos ver que la respuesta proviene de diferentes pods del
deployment de usuarios, confirmando que el `Load Balancer` est√° distribuyendo correctamente las solicitudes.

‚úÖ Con esto validamos que el `gateway-server` funciona como punto de entrada √∫nico a los microservicios y que el
balanceo de carga est√° operativo.
