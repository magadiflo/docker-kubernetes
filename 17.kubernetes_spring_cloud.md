# Secci√≥n 17: Kubernetes: Spring Cloud Kubernetes

---

## ¬øPor qu√© usar Spring Cloud Kubernetes si Kubernetes ya ofrece todo?

Una de las dudas m√°s comunes al comenzar a trabajar con `Spring Boot` en `Kubernetes` es entender si realmente
necesitamos integrar herramientas como `Spring Cloud Kubernetes`, considerando que el propio `Kubernetes` ya
proporciona muchas funcionalidades esenciales de forma nativa, como:

- `Service discovery` mediante `DNS` interno (por ejemplo, `http://orders-service`).
- `Balanceo de carga` a `nivel de red` a trav√©s de los `Services` de tipo `ClusterIP`, `NodePort` o `LoadBalancer`.
- `Configuraci√≥n externa` utilizando `ConfigMaps` y `Secrets`.

Entonces, ¬øpara qu√© agregar una dependencia adicional como `spring-cloud-starter-kubernetes`?

### ‚úÖ Qu√© aporta Spring Cloud Kubernetes

`Spring Cloud Kubernetes` no reemplaza lo que ya hace `Kubernetes`, sino que integra esas capacidades de forma
idiom√°tica dentro del ecosistema `Spring`, facilitando la vida del desarrollador cuando:

1. Queremos mapear `ConfigMaps` y `Secrets` directamente como propiedades de Spring Boot. Con `Spring Cloud Kubernetes`,
   los valores definidos en un `ConfigMap` pueden inyectarse directamente en nuestros componentes con `@Value` o
   `@ConfigurationProperties`, sin necesidad de leer archivos o definir variables de entorno. Por ejemplo.
    ````yml
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: app-config
    data:
      greeting.message: "Hola desde ConfigMap"
    ````
   ````java
   @Value("${greeting.message}")
   private String message;
   ````
   Sin tener que preocuparte por c√≥mo llegar al `ConfigMap`, Spring lo inyecta.


2. Queremos seguir usando patrones de `Spring Cloud` como `DiscoveryClient`. `Kubernetes` ya ofrece `DNS` para descubrir
   servicios. Sin embargo, si venimos de una arquitectura basada en `Spring Cloud Eureka`, es probable que tengamos
   c√≥digo que usa `DiscoveryClient`. `Spring Cloud Kubernetes` implementa esta interfaz usando la `API de Kubernetes`,
   lo que permite mantener ese c√≥digo sin cambios.


3. Queremos usar `balanceo de carga` del `lado cliente` (`Client-Side Load Balancer`). `Kubernetes` balancea a nivel de
   red, pero `Spring Cloud Kubernetes` permite usar `@LoadBalanced` `RestTemplate` o `WebClient` junto con estrategias
   de balanceo definidas por el cliente (√∫til si queremos reglas m√°s complejas o personalizadas).
   > Cuando hablamos de `load balancing` del `lado del cliente` (`client-side`) nos referimos a que la l√≥gica de elegir
   > a cu√°l instancia de un servicio enviar la solicitud est√° `implementada en el propio cliente` (es decir, en el
   > microservicio que hace la llamada).
   >
   > Esto es diferente al `server-side load balancing`, que es lo que hace `Kubernetes` con sus `Service`, donde el
   > balanceo ocurre de forma transparente a `nivel de red`.


4. Queremos migrar una arquitectura `Spring Cloud` a `Kubernetes`. En proyectos donde ya se usan herramientas como
   `Config Server`, `Eureka` o `Ribbon`, `Spring Cloud Kubernetes` ofrece un puente para migrar sin tener que reescribir
   toda la l√≥gica de integraci√≥n de servicios y configuraci√≥n.

### üîé Entonces, ¬ølo necesito?

No, si...

- Tu aplicaci√≥n es nueva y desarrollada espec√≠ficamente para `Kubernetes`.
- No usas `DiscoveryClient`, `Spring Config Server`, ni necesitas hacer `balanceo de carga` desde el propio
  microservicio (`client-side load balancing`), ya que conf√≠as en que `Kubernetes` manejar√° esto autom√°ticamente a
  nivel de red.
- Est√°s conforme con acceder a configuraci√≥n v√≠a variables de entorno o archivos montados.

S√≠ puede ayudarte, si...

- Est√°s `migrando` desde un stack `Spring Cloud tradicional`.
- Quieres aprovechar las facilidades que ofrece `Spring` para inyectar configuraci√≥n.
- Deseas mantener una `arquitectura desacoplada` de `Kubernetes` en ciertos aspectos.

### üìå En resumen

> Aunque `Spring Cloud Kubernetes no es obligatorio`, s√≠ puede `simplificar la integraci√≥n` entre el mundo de
> `Kubernetes` y el ecosistema `Spring`, especialmente cuando ya est√°s aprovechando otras herramientas de
`Spring Cloud`.

## Introducci√≥n a Spring Cloud Kubernetes

### ¬øQu√© es Spring Cloud Kubernetes?

`Spring Cloud Kubernetes` proporciona una integraci√≥n entre el ecosistema de `Spring Cloud` y el entorno de
`Kubernetes`, permitiendo a los desarrolladores ejecutar aplicaciones `Spring Cloud` de forma nativa sobre una
infraestructura orquestada por `Kubernetes`.

Esta integraci√≥n facilita tareas comunes como `descubrimiento de servicios`, `balanceo de carga`,
`configuraci√≥n externa` y `enrutamiento`, utilizando componentes que ya existen en `Kubernetes`, pero alineados al
estilo de desarrollo de Spring.

### Principales caracter√≠sticas

- `DiscoveryClient`. Permite registrar autom√°ticamente todos los servicios definidos en
  `Kubernetes (hostname y puerto)`, obteniendo una lista completa de los pods asociados a cada uno. A partir de este
  registro, los microservicios pueden comunicarse entre s√≠ usando solo el `nombre del servicio` (como
  `course-service`), desacopl√°ndose de detalles como `IPs` o `puertos`. Este nombre suele configurarse en el archivo
  `application.yml` con la propiedad `spring.application.name`.


- `Spring Cloud Config`. Permite cargar configuraciones externas directamente desde `ConfigMaps` y `Secrets` de
  `Kubernetes`, integr√°ndolos al entorno de propiedades de `Spring Boot`.


- `Spring Cloud LoadBalancer`. Proporciona una implementaci√≥n de balanceo de carga del lado del cliente (`client-side`),
  utilizando como base los servicios y pods registrados en Kubernetes. Esto permite aplicar estrategias de balanceo m√°s
  flexibles que las ofrecidas por defecto por `Kubernetes`.


- `Spring Cloud Gateway`. Funciona como una puerta de enlace √∫nica para acceder a los distintos microservicios. Cada
  ruta configurada en el `gateway` puede dirigir el tr√°fico al servicio correspondiente, simplificando el acceso desde
  el exterior.

### Arquitectura general

![01.png](assets/section-17/01.png)

- `Cliente`: Se comunica con los distintos microservicios, los cuales a su vez est√°n respaldados por varios pods que
  representan las distintas instancias en ejecuci√≥n.


- `Spring Cloud Service Registry`: Es el componente que act√∫a como `DiscoveryClient`. Registra cada servicio de
  Kubernetes junto con la `lista completa de sus pods` (`IP y puerto`). Esta informaci√≥n se asocia a un `nombre l√≥gico`,
  que luego es usado por los microservicios para comunicarse entre s√≠ sin necesidad de conocer detalles de red.


- `Balanceador`: Cada microservicio puede usar `Spring Cloud LoadBalancer` para seleccionar de forma inteligente a cu√°l
  `pod` llamar, bas√°ndose en la lista registrada por el `DiscoveryClient`.


- `Spring Cloud Config`: Administra la configuraci√≥n de cada microservicio aprovechando los recursos nativos de
  `Kubernetes (ConfigMaps y Secrets)`, integr√°ndolos al sistema de propiedades de `Spring Boot`.

> Esta arquitectura permite desacoplar a√∫n m√°s la l√≥gica del negocio de la infraestructura, aprovechando lo mejor de
> ambos mundos: `el poder de orquestaci√≥n de Kubernetes` y la `flexibilidad del ecosistema Spring`.

## üöÄ Configuraci√≥n de Microservicios con Spring Cloud Kubernetes

Para habilitar la integraci√≥n de nuestros microservicios con `Kubernetes` usando `Spring Cloud`, es necesario incluir
un conjunto de dependencias que permiten:

- `Descubrimiento de servicios` mediante el `cliente de Kubernetes`.
- `Carga de configuraci√≥n externa` desde `ConfigMaps` o `Secrets`.
- `Balanceo de carga` entre pods de un mismo servicio.

Estas dependencias deben agregarse en el archivo `pom.xml` de cada microservicio involucrado, como es el caso de:
`courser-service` y `user-service`.

````xml

<dependencies>
    <!-- Cliente de Kubernetes para descubrimiento de servicios -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-kubernetes-client</artifactId>
    </dependency>
    <!-- Integraci√≥n con ConfigMaps y Secrets para configuraci√≥n externa -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-kubernetes-client-config</artifactId>
    </dependency>
    <!-- Balanceador de carga basado en el cliente de Kubernetes -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-kubernetes-client-loadbalancer</artifactId>
    </dependency>
</dependencies>
````

#### ¬øQu√© hace cada dependencia?

- `spring-cloud-starter-kubernetes-client`. Esta dependencia permite que tu aplicaci√≥n Spring Boot se comunique
  directamente con el `API de Kubernetes`. Gracias a ella, los microservicios pueden descubrir otros servicios dentro
  del cl√∫ster utilizando el `nombre del recurso` `Service` `definido en Kubernetes`, en lugar de una IP fija o un puerto
  espec√≠fico.


- `spring-cloud-starter-kubernetes-client-config`. Habilita la carga autom√°tica de configuraci√≥n desde recursos de
  `Kubernetes` como `ConfigMaps` y `Secrets`. Esto permite desacoplar la configuraci√≥n del c√≥digo fuente, facilitando
  ajustes din√°micos sin necesidad de recompilar ni redeployar la aplicaci√≥n.


- `spring-cloud-starter-kubernetes-client-loadbalancer`. Proporciona un mecanismo de balanceo de carga entre los pods
  de un mismo servicio. `Utiliza el Service de Kubernetes como punto de entrada`, distribuyendo las peticiones entre
  las instancias disponibles de forma transparente para el consumidor.

#### Notas importantes

- Estas dependencias est√°n dise√±adas para trabajar con el cliente oficial de Kubernetes, no con el antiguo fabric8.
- `Spring Cloud` abstrae el descubrimiento de servicios, permitiendo que los microservicios se comuniquen
  `usando el nombre l√≥gico del servicio definido en Kubernetes (Service)`, sin necesidad de conocer la IP o el puerto.
- El `balanceador de carga` se integra con el `Service de Kubernetes` para distribuir las peticiones entre los pods
  disponibles.

### üîç Habilitando el Descubrimiento de Servicios

Para que nuestros microservicios puedan participar en el mecanismo de descubrimiento de servicios proporcionado por
`Spring Cloud Kubernetes`, es necesario agregar la anotaci√≥n `@EnableDiscoveryClient` en la clase principal de cada uno.

Esta anotaci√≥n le indica a `Spring Boot` que debe registrar el microservicio como `cliente de descubrimiento`,
permiti√©ndole resolver otros servicios dentro del cl√∫ster mediante el nombre del `Service` de `Kubernetes`.

A continuaci√≥n se muestra un ejemplo aplicado al microservicio `user-service`:

````java

@EnableDiscoveryClient
@SpringBootApplication
public class UserServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}
````

De forma equivalente, se debe aplicar la misma anotaci√≥n en el microservicio `course-service`.

#### ¬øPor qu√© es necesaria esta anotaci√≥n?

- Aunque `Spring Cloud Kubernetes` puede funcionar sin `@EnableDiscoveryClient` en versiones recientes, agregarla
  expl√≠citamente garantiza compatibilidad y deja claro que el servicio est√° preparado para participar en el
  descubrimiento.
- Es especialmente √∫til cuando se trabaja con m√∫ltiples entornos o configuraciones mixtas (por ejemplo,
  `Eureka + Kubernetes`), ya que permite que el comportamiento sea expl√≠cito.
