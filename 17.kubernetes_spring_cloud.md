# Secci√≥n 17: Kubernetes: Spring Cloud Kubernetes

---

## ¬øPor qu√© usar Spring Cloud Kubernetes si Kubernetes ya ofrece todo?

Una de las dudas m√°s comunes al comenzar a trabajar con `Spring Boot` en `Kubernetes` es entender si realmente
necesitamos integrar herramientas como `Spring Cloud Kubernetes`, considerando que el propio `Kubernetes` ya
proporciona muchas funcionalidades esenciales de forma nativa, como:

- `Service discovery` mediante `DNS` interno (por ejemplo, `http://orders-service`).
- `Balanceo de carga` a `nivel de red` a trav√©s de los `Services` de tipo `ClusterIP`, `NodePort` o `LoadBalancer`.
- `Configuraci√≥n externa` utilizando `ConfigMaps` y `Secrets`.

Entonces, ¬øpara qu√© agregar una dependencia adicional como `spring-cloud-starter-kubernetes`?

### ‚úÖ Qu√© aporta Spring Cloud Kubernetes

`Spring Cloud Kubernetes` no reemplaza lo que ya hace `Kubernetes`, sino que integra esas capacidades de forma
idiom√°tica dentro del ecosistema `Spring`, facilitando la vida del desarrollador cuando:

1. Queremos mapear `ConfigMaps` y `Secrets` directamente como propiedades de Spring Boot. Con `Spring Cloud Kubernetes`,
   los valores definidos en un `ConfigMap` pueden inyectarse directamente en nuestros componentes con `@Value` o
   `@ConfigurationProperties`, sin necesidad de leer archivos o definir variables de entorno. Por ejemplo.
    ````yml
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: app-config
    data:
      greeting.message: "Hola desde ConfigMap"
    ````
   ````java
   @Value("${greeting.message}")
   private String message;
   ````
   Sin tener que preocuparte por c√≥mo llegar al `ConfigMap`, Spring lo inyecta.


2. Queremos seguir usando patrones de `Spring Cloud` como `DiscoveryClient`. `Kubernetes` ya ofrece `DNS` para descubrir
   servicios. Sin embargo, si venimos de una arquitectura basada en `Spring Cloud Eureka`, es probable que tengamos
   c√≥digo que usa `DiscoveryClient`. `Spring Cloud Kubernetes` implementa esta interfaz usando la `API de Kubernetes`,
   lo que permite mantener ese c√≥digo sin cambios.


3. Queremos usar `balanceo de carga` del `lado cliente` (`Client-Side Load Balancer`). `Kubernetes` balancea a nivel de
   red, pero `Spring Cloud Kubernetes` permite usar `@LoadBalanced` `RestTemplate` o `WebClient` junto con estrategias
   de balanceo definidas por el cliente (√∫til si queremos reglas m√°s complejas o personalizadas).
   > Cuando hablamos de `load balancing` del `lado del cliente` (`client-side`) nos referimos a que la l√≥gica de elegir
   > a cu√°l instancia de un servicio enviar la solicitud est√° `implementada en el propio cliente` (es decir, en el
   > microservicio que hace la llamada).
   >
   > Esto es diferente al `server-side load balancing`, que es lo que hace `Kubernetes` con sus `Service`, donde el
   > balanceo ocurre de forma transparente a `nivel de red`.


4. Queremos migrar una arquitectura `Spring Cloud` a `Kubernetes`. En proyectos donde ya se usan herramientas como
   `Config Server`, `Eureka` o `Ribbon`, `Spring Cloud Kubernetes` ofrece un puente para migrar sin tener que reescribir
   toda la l√≥gica de integraci√≥n de servicios y configuraci√≥n.

### üîé Entonces, ¬ølo necesito?

No, si...

- Tu aplicaci√≥n es nueva y desarrollada espec√≠ficamente para `Kubernetes`.
- No usas `DiscoveryClient`, `Spring Config Server`, ni necesitas hacer `balanceo de carga` desde el propio
  microservicio (`client-side load balancing`), ya que conf√≠as en que `Kubernetes` manejar√° esto autom√°ticamente a
  nivel de red.
- Est√°s conforme con acceder a configuraci√≥n v√≠a variables de entorno o archivos montados.

S√≠ puede ayudarte, si...

- Est√°s `migrando` desde un stack `Spring Cloud tradicional`.
- Quieres aprovechar las facilidades que ofrece `Spring` para inyectar configuraci√≥n.
- Deseas mantener una `arquitectura desacoplada` de `Kubernetes` en ciertos aspectos.

### üìå En resumen

> Aunque `Spring Cloud Kubernetes no es obligatorio`, s√≠ puede `simplificar la integraci√≥n` entre el mundo de
> `Kubernetes` y el ecosistema `Spring`, especialmente cuando ya est√°s aprovechando otras herramientas de
`Spring Cloud`.

## Introducci√≥n a Spring Cloud Kubernetes

### ¬øQu√© es Spring Cloud Kubernetes?

`Spring Cloud Kubernetes` proporciona una integraci√≥n entre el ecosistema de `Spring Cloud` y el entorno de
`Kubernetes`, permitiendo a los desarrolladores ejecutar aplicaciones `Spring Cloud` de forma nativa sobre una
infraestructura orquestada por `Kubernetes`.

Esta integraci√≥n facilita tareas comunes como `descubrimiento de servicios`, `balanceo de carga`,
`configuraci√≥n externa` y `enrutamiento`, utilizando componentes que ya existen en `Kubernetes`, pero alineados al
estilo de desarrollo de Spring.

### Principales caracter√≠sticas

- `DiscoveryClient`. Permite registrar autom√°ticamente todos los servicios definidos en
  `Kubernetes (hostname y puerto)`, obteniendo una lista completa de los pods asociados a cada uno. A partir de este
  registro, los microservicios pueden comunicarse entre s√≠ usando solo el `nombre del servicio` (como
  `course-service`), desacopl√°ndose de detalles como `IPs` o `puertos`. Este nombre suele configurarse en el archivo
  `application.yml` con la propiedad `spring.application.name`.


- `Spring Cloud Config`. Permite cargar configuraciones externas directamente desde `ConfigMaps` y `Secrets` de
  `Kubernetes`, integr√°ndolos al entorno de propiedades de `Spring Boot`.


- `Spring Cloud LoadBalancer`. Proporciona una implementaci√≥n de balanceo de carga del lado del cliente (`client-side`),
  utilizando como base los servicios y pods registrados en Kubernetes. Esto permite aplicar estrategias de balanceo m√°s
  flexibles que las ofrecidas por defecto por `Kubernetes`.


- `Spring Cloud Gateway`. Funciona como una puerta de enlace √∫nica para acceder a los distintos microservicios. Cada
  ruta configurada en el `gateway` puede dirigir el tr√°fico al servicio correspondiente, simplificando el acceso desde
  el exterior.

### Arquitectura general

![01.png](assets/section-17/01.png)

- `Cliente`: Se comunica con los distintos microservicios, los cuales a su vez est√°n respaldados por varios pods que
  representan las distintas instancias en ejecuci√≥n.


- `Spring Cloud Service Registry`: Es el componente que act√∫a como `DiscoveryClient`. Registra cada servicio de
  Kubernetes junto con la `lista completa de sus pods` (`IP y puerto`). Esta informaci√≥n se asocia a un `nombre l√≥gico`,
  que luego es usado por los microservicios para comunicarse entre s√≠ sin necesidad de conocer detalles de red.


- `Balanceador`: Cada microservicio puede usar `Spring Cloud LoadBalancer` para seleccionar de forma inteligente a cu√°l
  `pod` llamar, bas√°ndose en la lista registrada por el `DiscoveryClient`.


- `Spring Cloud Config`: Administra la configuraci√≥n de cada microservicio aprovechando los recursos nativos de
  `Kubernetes (ConfigMaps y Secrets)`, integr√°ndolos al sistema de propiedades de `Spring Boot`.

> Esta arquitectura permite desacoplar a√∫n m√°s la l√≥gica del negocio de la infraestructura, aprovechando lo mejor de
> ambos mundos: `el poder de orquestaci√≥n de Kubernetes` y la `flexibilidad del ecosistema Spring`.

## üöÄ Configuraci√≥n de Microservicios con Spring Cloud Kubernetes

Para habilitar la integraci√≥n de nuestros microservicios con `Kubernetes` usando `Spring Cloud`, es necesario incluir
un conjunto de dependencias que permiten:

- `Descubrimiento de servicios` mediante el `cliente de Kubernetes`.
- `Carga de configuraci√≥n externa` desde `ConfigMaps` o `Secrets`.
- `Balanceo de carga` entre pods de un mismo servicio.

Estas dependencias deben agregarse en el archivo `pom.xml` de cada microservicio involucrado, como es el caso de:
`courser-service` y `user-service`.

````xml

<dependencies>
    <!-- Cliente de Kubernetes para descubrimiento de servicios -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-kubernetes-client</artifactId>
    </dependency>
    <!-- Integraci√≥n con ConfigMaps y Secrets para configuraci√≥n externa -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-kubernetes-client-config</artifactId>
    </dependency>
    <!-- Balanceador de carga basado en el cliente de Kubernetes -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-kubernetes-client-loadbalancer</artifactId>
    </dependency>
</dependencies>
````

#### ¬øQu√© hace cada dependencia?

- `spring-cloud-starter-kubernetes-client`. Esta dependencia permite que tu aplicaci√≥n Spring Boot se comunique
  directamente con el `API de Kubernetes`. Gracias a ella, los microservicios pueden descubrir otros servicios dentro
  del cl√∫ster utilizando el `nombre del recurso` `Service` `definido en Kubernetes`, en lugar de una IP fija o un puerto
  espec√≠fico.


- `spring-cloud-starter-kubernetes-client-config`. Habilita la carga autom√°tica de configuraci√≥n desde recursos de
  `Kubernetes` como `ConfigMaps` y `Secrets`. Esto permite desacoplar la configuraci√≥n del c√≥digo fuente, facilitando
  ajustes din√°micos sin necesidad de recompilar ni redeployar la aplicaci√≥n.


- `spring-cloud-starter-kubernetes-client-loadbalancer`. Proporciona un mecanismo de balanceo de carga entre los pods
  de un mismo servicio. `Utiliza el Service de Kubernetes como punto de entrada`, distribuyendo las peticiones entre
  las instancias disponibles de forma transparente para el consumidor.

#### Notas importantes

- Estas dependencias est√°n dise√±adas para trabajar con el cliente oficial de Kubernetes, no con el antiguo fabric8.
- `Spring Cloud` abstrae el descubrimiento de servicios, permitiendo que los microservicios se comuniquen
  `usando el nombre l√≥gico del servicio definido en Kubernetes (Service)`, sin necesidad de conocer la IP o el puerto.
- El `balanceador de carga` se integra con el `Service de Kubernetes` para distribuir las peticiones entre los pods
  disponibles.

### üîç Habilitando el Descubrimiento de Servicios

Para que nuestros microservicios puedan participar en el mecanismo de descubrimiento de servicios proporcionado por
`Spring Cloud Kubernetes`, es necesario agregar la anotaci√≥n `@EnableDiscoveryClient` en la clase principal de cada uno.

Esta anotaci√≥n le indica a `Spring Boot` que debe registrar el microservicio como `cliente de descubrimiento`,
permiti√©ndole resolver otros servicios dentro del cl√∫ster mediante el nombre del `Service` de `Kubernetes`.

A continuaci√≥n se muestra un ejemplo aplicado al microservicio `user-service`:

````java

@EnableDiscoveryClient
@SpringBootApplication
public class UserServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}
````

De forma equivalente, se debe aplicar la misma anotaci√≥n en el microservicio `course-service`.

#### ¬øPor qu√© es necesaria esta anotaci√≥n?

- Aunque `Spring Cloud Kubernetes` puede funcionar sin `@EnableDiscoveryClient` en versiones recientes, agregarla
  expl√≠citamente garantiza compatibilidad y deja claro que el servicio est√° preparado para participar en el
  descubrimiento.
- Es especialmente √∫til cuando se trabaja con m√∫ltiples entornos o configuraciones mixtas (por ejemplo,
  `Eureka + Kubernetes`), ya que permite que el comportamiento sea expl√≠cito.

### üîß Configuraci√≥n del `RestClient` en el microservicio `user-service`

Para permitir la comunicaci√≥n entre microservicios dentro del cl√∫ster de Kubernetes, configuramos un cliente HTTP
usando `RestClient`, introducido en `Spring Framework 6`.

Este cliente ser√° capaz de resolver el nombre del `servicio` destino (`s-course-service`) y aplicar balanceo de carga
entre sus r√©plicas.

#### üõ†Ô∏è Clase de configuraci√≥n: `RestClientConfig`

````java

@Configuration
public class RestClientConfig {

    @Value("${custom.course-service.base-url}")
    private String courseServiceBaseUrl;

    /**
     * Builder anotado con @LoadBalanced para que Spring Cloud Kubernetes
     * pueda interceptar el nombre l√≥gico del servicio y aplicar balanceo.
     */
    @Bean
    @LoadBalanced
    public RestClient.Builder restClientBuilder(List<RestClientCustomizer> customizers) {
        RestClient.Builder builder = RestClient.builder();
        customizers.forEach(customizer -> customizer.customize(builder));
        return builder;
    }

    @Bean(name = "courseRestClient")
    public RestClient courseServiceRestClient(@Qualifier("restClientBuilder") RestClient.Builder builder) {
        return builder
                .baseUrl(this.courseServiceBaseUrl)
                .build();
    }
}
````

üìå Puntos importantes

1. `baseUrl` solo debe contener la base del servicio. Debe apuntar √∫nicamente al `nombre del Service de Kubernetes`,
   por ejemplo: `http://s-course-service`.
    - `No` incluyas el puerto si `est√°s trabajando` con `Spring Cloud Kubernetes`, ya que el `@LoadBalanced` necesita
      resolver solo el nombre l√≥gico del servicio. `Si no usas Spring Cloud Kubernetes`, entonces
      `s√≠ puedes incluir el puerto`.
    - `No` incluyas rutas como `/api/v1/...` en el `baseUrl`. El `baseUrl` debe contener solo el `nombre del servicio`,
      por ejemplo: `http://s-course-service`.
    - Esto es fundamental, ya que el `@LoadBalanced` necesita que el host sea el nombre l√≥gico del servicio para
      resolverlo correctamente.


2. El bean `RestClient.Builder` est√° anotado con `@LoadBalanced`, lo que permite que `Spring Cloud Kubernetes`:
    - Intercepte el nombre del servicio.
    - Consulte el cl√∫ster para encontrar sus r√©plicas.
    - Distribuya las peticiones autom√°ticamente.

#### üõ† Clase cliente: `CourseServiceClient`

Encapsulamos las llamadas al microservicio `course-service` en una clase dedicada, manteniendo la configuraci√≥n y la
l√≥gica desacopladas.

````java

@Slf4j
@Component
public class CourseServiceClient {

    private static final String COURSE_URI = "/api/v1/courses";
    private final RestClient restClient;

    public CourseServiceClient(@Qualifier("courseRestClient") RestClient restClient) {
        this.restClient = restClient;
    }

    /**
     * Realiza una llamada DELETE al microservicio de cursos para desasociar
     * un usuario de cualquier curso en el que est√© registrado.
     */
    public void unassignUserFromAssociatedCourse(Long userId) {
        log.info("Llamando al servicio course-service para des-asignar de alg√∫n curso al usuario con id {}", userId);
        this.restClient
                .delete()
                .uri(COURSE_URI.concat("/users/{userId}"), userId)
                .retrieve()
                .toBodilessEntity();
        log.info("Fin de la llamada al servicio course-service para des-asignar de alg√∫n curso al usuario con id {}", userId);
    }
}
````

‚úÖ Buenas pr√°cticas aplicadas

- Uso de `@Qualifier` para evitar conflictos en la inyecci√≥n cuando hay m√∫ltiples `RestClient` registrados.
- Separaci√≥n de responsabilidades:
    - `RestClientConfig`: configuraci√≥n e inyecci√≥n del cliente HTTP.
    - `CourseServiceClient`: encapsulaci√≥n de la l√≥gica de llamadas al servicio externo.
- `Logging informativo` antes y despu√©s de la llamada para facilitar la trazabilidad.
- `Constantes para URIs`, lo que reduce errores y facilita cambios futuros.

### üõ† Configuraci√≥n de Spring Cloud Kubernetes en `user-service`

En el archivo `application.yml` del microservicio `user-service`, agregamos las configuraciones necesarias para
habilitar la integraci√≥n con `Spring Cloud Kubernetes`.

````yml
spring:
  application:
    name: user-service
  cloud:
    kubernetes:
      secrets:
        enable-api: true
      discovery:
        all-namespaces: true

custom:
  course-service:
    base-url: http://${K8S_COURSE_SERVICE_NAME}
````

**D√≥nde**

- `spring.cloud.kubernetes.secrets.enable-api`, permite leer `Secrets` usando la `API de Kubernetes`, adem√°s de
  vol√∫menes montados.
- `spring.cloud.kubernetes.discovery.all-namespaces`, permite descubrir servicios en todos los namespaces del cluster.
- `spring.cloud.kubernetes.secrets.enabled`, aunque no lo mencionaste expl√≠citamente, es importante saber que esta
  propiedad (por defecto en true) permite que `Spring Cloud Kubernetes` cargue secretos como una fuente de propiedades
  (`PropertySource`). Esto complementa `enable-api`, permitiendo leer secretos tanto desde `vol√∫menes` montados como
  desde la API si lo configuras.

Observemos que, adem√°s, hemos modificado el valor de `base-url` que ten√≠a como valor
`http://${COURSE_SERVICE_HOST}:${COURSE_SERVICE_PORT}/api/v1/courses` y lo reemplazamos por
`http://${K8S_COURSE_SERVICE_NAME}`.

Este cambio se debe a que, al incorporar la dependencia de `Spring Cloud Kubernetes`, ya no es necesario especificar
manualmente el `puerto` ni la `IP` del servicio. Spring se encarga de resolver autom√°ticamente la direcci√≥n del
servicio a partir de su nombre, utilizando el `DNS` interno de `Kubernetes`.

**üìå Nota t√©cnica**
> Cuando trabajamos con `Kubernetes puro (sin Spring Cloud Kubernetes)`, es obligatorio definir tanto el nombre del
> servicio como su puerto, por ejemplo: `${COURSE_SERVICE_HOST}:${COURSE_SERVICE_PORT}`.
>
> En cambio, con `Spring Cloud Kubernetes`, basta con el nombre del servicio (`K8S_COURSE_SERVICE_NAME`), ya que el
> framework realiza el descubrimiento din√°mico y transparente.

‚ö†Ô∏è Advertencia
> Si defines accidentalmente `base-url` con host y puerto cuando usas `Spring Cloud Kubernetes`, el balanceo de carga
> no se aplicar√° correctamente y perder√°s la capacidad de resoluci√≥n autom√°tica de endpoints que ofrece el
> DNS de Kubernetes.

### üîß Configuraci√≥n del `RestClient` en el microservicio `course-service`

Realizamos los mismos cambios que vimos en el apartado anterior.

````java

@Configuration
public class RestClientConfig {

    @Value("${custom.user-service.base-url}")
    private String userServiceBaseUrl;

    @Bean
    @LoadBalanced
    public RestClient.Builder restClientBuilder(List<RestClientCustomizer> customizers) {
        RestClient.Builder builder = RestClient.builder();
        customizers.forEach(customizer -> customizer.customize(builder));
        return builder;
    }

    @Bean(name = "userRestClient")
    public RestClient userServiceRestClient(@Qualifier("restClientBuilder") RestClient.Builder builder) {
        return builder
                .baseUrl(this.userServiceBaseUrl)
                .build();
    }
}
````

````java

@Slf4j
@Component
public class UserServiceClient {

    private static final String USER_URI = "/api/v1/users";
    private final RestClient restClient;

    public UserServiceClient(@Qualifier("userRestClient") RestClient userRestClient) {
        this.restClient = userRestClient;
    }

    public UserResponse getUserFromUserService(Long userId) {
        log.info("Consultando al servicio user-service por el usuario con id {}", userId);
        UserResponse userResponse = this.restClient
                .get()
                .uri(USER_URI.concat("/{userId}"), userId)
                .exchange((clientRequest, clientResponse) -> {
                    HttpStatusCode statusCode = clientResponse.getStatusCode();
                    if (statusCode == HttpStatus.OK) {
                        return clientResponse.bodyTo(UserResponse.class);
                    }

                    if (statusCode == HttpStatus.NOT_FOUND) {
                        throw new RemoteUserNotFoundException(userId);
                    }

                    ErrorResponse errorResponse = clientResponse.bodyTo(ErrorResponse.class);
                    String message = Optional.ofNullable(errorResponse)
                            .map(ErrorResponse::error)
                            .orElseGet(() -> "Error desconocido al consultar el user-service");

                    log.info("Mensaje de error desde el user-service: {}", message);
                    throw new CommunicationException(message);
                });
        log.info("El servicio user-service encontr√≥ al usuario buscado: {}", userResponse);
        return userResponse;
    }

    public UserResponse createUserInUserService(UserRequest userRequest) {
        log.info("Registrando usuario en el user-service: {}", userRequest);
        UserResponse userResponse = this.restClient
                .post()
                .uri(USER_URI)
                .body(userRequest)
                .retrieve()
                .body(UserResponse.class);
        log.info("Usuario registrado con √©xito en el user-service: {}", userResponse);
        return userResponse;
    }

    public List<UserResponse> getUsersByIdsFromUserService(List<Long> userIds) {
        log.info("Consultando al servicio user-service por los usuarios con id: {}", userIds);
        List<UserResponse> userResponseList = this.restClient
                .get()
                .uri(uriBuilder -> uriBuilder
                        .path(USER_URI.concat("/by-ids"))
                        .queryParam("userIds", userIds)
                        .build())
                .retrieve()
                .body(new ParameterizedTypeReference<>() {
                });
        log.info("El servicio user-service encontr√≥ a los usuarios: {}", userResponseList);
        return userResponseList;
    }
}
````

````yml
spring:
  application:
    name: course-service
  cloud:
    kubernetes:
      secrets:
        enable-api: true
      discovery:
        all-namespaces: true

custom:
  user-service:
    base-url: http://${K8S_USER_SERVICE_NAME}
````

### üîç FeignClient vs RestClient - Diferencias clave

En el curso, el tutor utiliza `FeignClient` como cliente HTTP, mientras que en mi implementaci√≥n opt√© por `RestClient`.

Ambos permiten la comunicaci√≥n entre microservicios, pero presentan diferencias importantes en cuanto a configuraci√≥n y
comportamiento.

1. Uso con `FeignClient (tutor)`

````bash
@FeignClient(name = "dk-ms-courses", path = "/api/v1/courses")
````

- ‚úÖ `@LoadBalanced` `impl√≠cito`: No es necesario declararlo, `Feign` lo configura internamente para hacer balanceo de
  carga usando el `service discovery`.
- ‚úÖ `name`: Equivale al `.baseUrl()` de `RestClient`; corresponde al nombre del servicio registrado en `Kubernetes` o
  `Eureka`.
- ‚úÖ `path`: Ruta base com√∫n para todos los endpoints (opcional).

2. Mi caso con `RestClient`

````bash
@LoadBalanced  //<-- Debe ser expl√≠cito
@Bean
public RestClient.Builder restClientBuilder() { ... }

.baseUrl("http://s-course-service")  // <-- Equivale al "name" de FeignClient
.uri("/api/v1/courses/specific-endpoint")  // <-- Path se construye donde se usa
````

- ‚ö† `@LoadBalanced`, debe declararse expl√≠citamente en un `RestClient.Builder`.
- `.baseUrl()`, define el servicio de destino (equivalente a `name` en `Feign`).
- `.uri()`, se indica en cada invocaci√≥n, construyendo la ruta final.

üéØ La equivalencia exacta:

| FeignClient                | RestClient                         |
|----------------------------|------------------------------------|
| `name = "dk-ms-courses"`   | `.baseUrl("http://dk-ms-courses")` |
| `path = "/api/v1/courses"` | `.uri("/api/v1/courses/...")`      |
| Load balancing autom√°tico  | `@LoadBalanced` expl√≠cito          |

üí° Conclusi√≥n t√©cnica:
> `FeignClient` abstrae muchas configuraciones (balanceo, resoluci√≥n de nombre de servicio, composici√≥n de URL base)
> que con `RestClient` deben configurarse manualmente. Esto hace que `Feign` sea m√°s declarativo y simple de mantener,
> aunque `RestClient` ofrece mayor flexibilidad para personalizar llamadas en tiempo de ejecuci√≥n.

### üì¶ Construcci√≥n y publicaci√≥n de im√°genes Docker

Ahora que hemos realizado los cambios necesarios en nuestros microservicios, procederemos a construir y publicar las
nuevas im√°genes en `Docker Hub` para que puedan ser desplegadas en `Kubernetes`.

1. Construir imagen de `course-service`
    ````bash
    $ docker image build -t magadiflo/course-service .\business-domain\course-service
    ````
    - `-t magadiflo/course-service`, asigna el nombre de la imagen en el formato `usuario/nombre-imagen`. Es importante
      que el nombre de usuario coincida con el de tu cuenta en `Docker Hub`, ya que as√≠ el repositorio lo aceptar√° al
      momento del push.
    - Ruta `.\business-domain\course-service`, indica el directorio donde se encuentra el `Dockerfile`.
   > üí° Nota: si no se especifica una etiqueta `(:tag)`, `Docker` asignar√° autom√°ticamente la etiqueta `latest`.

2. Construir imagen de `user-service`
    ````bash
    $ docker image build -t magadiflo/user-service .\business-domain\user-service
    ````
   La l√≥gica es la misma que en el paso anterior, solo que aqu√≠ construimos la imagen correspondiente al microservicio
   `user-service`.


3. Publicar las im√°genes en Docker Hub
    ````bash
    $ docker push magadiflo/course-service
    ````
    ````bash
    $ docker push magadiflo/user-service
    ````

## Aplicando Cambios en Kubernetes y Probando

En el apartado anterior finalizamos enviando las im√°genes actualizadas de los microservicios `course-service` y
`user-service` a `Docker Hub`. Ahora, vamos a actualizar los deployments de cada microservicio para que usen estas
nuevas im√°genes.

### üîÑ Cambios en el Deployment y ConfigMap de `user-service`

Antes de aplicar los cambios, recordemos que en la secci√≥n `env` de los deployments se defin√≠an variables de entorno
espec√≠ficas para cada microservicio.

Por ejemplo, en el archivo `deployment-user.yml` ten√≠amos estas variables de entorno para configurar la comunicaci√≥n
con el microservicio de cursos:

````yml
- name: COURSE_SERVICE_HOST
  valueFrom:
    configMapKeyRef:
      name: cm-user-service
      key: course_service_host
- name: COURSE_SERVICE_PORT
  valueFrom:
    configMapKeyRef:
      name: cm-user-service
      key: course_service_port
````

Ahora, como hemos incorporado la integraci√≥n con `Spring Cloud Kubernetes` y resolvemos la direcci√≥n del servicio
v√≠a su nombre en `Kubernetes`, estas variables se reemplazan por una √∫nica variable que representa el
`nombre del servicio en Kubernetes`:

````yml
- name: K8S_COURSE_SERVICE_NAME
  valueFrom:
    configMapKeyRef:
      name: cm-user-service
      key: k8s_course_service_name
````

Esto implica que tambi√©n debemos modificar el `ConfigMap` asociado al `user-service` para reflejar este cambio:

````yml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cm-user-service
data:
  container_port: '8001'
  db_host: s-mysql
  db_port: '3306'
  db_name: db_user_service
  k8s_course_service_name: s-course-service
````

Observa que el valor de `k8s_course_service_name` es `s-course-service`, que corresponde exactamente al
`nombre del servicio definido en Kubernetes`, y ser√° usado por `Spring Cloud Kubernetes` para descubrir y balancear las
peticiones hacia el microservicio de cursos.

### üîÑ Cambios en el Deployment y ConfigMap de `course-service`

De forma an√°loga al caso de `user-service`, debemos actualizar el `deployment` y el `ConfigMap` del microservicio
`course-service` para usar la nueva variable de entorno que apunta al `nombre del servicio Kubernetes` del
microservicio `user-service`.

Actualizamos el contenido del deployment `deployment-course.yml` agregando la variable de entorno
`K8S_USER_SERVICE_NAME`, que obtiene su valor desde el `ConfigMap` correspondiente:

````yml
- name: K8S_USER_SERVICE_NAME
  valueFrom:
    configMapKeyRef:
      name: cm-course-service
      key: k8s_user_service_name
````

El `ConfigMap` queda configurado con el `nombre del servicio Kubernetes` del `user-service`, es decir con:
`s-user-service`.

````yml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cm-course-service
data:
  container_port: '8002'
  db_host: s-postgres
  db_port: '5432'
  db_name: db_course_service
  k8s_user_service_name: s-user-service
````

### Aplicando los cambios en Kubernetes

Primero aplicamos los `ConfigMap` modificados.

````bash
$ kubectl apply -f .\kubernetes\configmaps\configmap-course.yml -f .\kubernetes\configmaps\configmap-user.yml
configmap/cm-course-service configured
configmap/cm-user-service configured
````

Luego eliminamos los deployments actuales para recrearlos con las nuevas im√°genes.

````bash
$ kubectl delete -f .\kubernetes\deployments\deployment-course.yml -f .\kubernetes\deployments\deployment-user.yml
deployment.apps "d-course-service" deleted
deployment.apps "d-user-service" deleted
````

Finalmente volvemos a aplicar los deployments.

````bash
$ kubectl apply -f .\kubernetes\deployments\deployment-user.yml -f .\kubernetes\deployments\deployment-course.yml
deployment.apps/d-user-service created
deployment.apps/d-course-service created
````

### Verificaci√≥n de despliegue

Listamos los deployments para confirmar que se han creado: `d-course-service` y `d-user-service`.

````bash
$ kubectl get deployments
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
d-course-service   1/1     1            1           17s
d-mysql            1/1     1            1           17d
d-postgres         1/1     1            1           16d
d-user-service     1/1     1            1           17s
````

Listamos los pods y vemos que todos se est√°n ejecutando correctamente. Los pods correspondientes al de los
microservicios tambi√©n se est√°n ejecutando `aparentemente` de manera correcta.

````bash
$ kubectl get pods
NAME                               READY   STATUS    RESTARTS      AGE
d-course-service-986cc5555-fj5xm   1/1     Running   0             35s
d-mysql-5ffd47dd8-ctmt8            1/1     Running   8 (30m ago)   7d22h
d-postgres-67b99b466d-c27wb        1/1     Running   9 (30m ago)   7d22h
d-user-service-8dd5c844d-cmcq8     1/1     Running   0             35s
````

Pero, qu√© pasa si vemos alg√∫n log de alg√∫n pod que acabamos de crear, por ejemplo el de usuarios:

````bash
$ kubectl logs d-user-service-8dd5c844d-cmcq8
...
2025-08-10T05:17:10.417Z  INFO 1 --- [user-service] [s.V1Endpoints-1] i.k.c.informer.cache.ReflectorRunnable   : class io.kubernetes.client.openapi.models.V1Endpoints#Start listing and watching...
2025-08-10T05:17:10.419Z ERROR 1 --- [user-service] [s.V1Endpoints-1] i.k.c.informer.cache.ReflectorRunnable   : class io.kubernetes.client.openapi.models.V1Endpoints#Reflector loop failed unexpectedly

io.kubernetes.client.openapi.ApiException: class V1Status {
    apiVersion: v1
    code: 403
    details: class V1StatusDetails {
        causes: null
        group: null
        kind: endpoints
        name: null
        retryAfterSeconds: null
        uid: null
    }
    kind: Status
    message: endpoints is forbidden: User "system:serviceaccount:default:default" cannot list resource "endpoints" in API group "" at the cluster scope
    metadata: class V1ListMeta {
        _continue: null
        remainingItemCount: null
        resourceVersion: null
        selfLink: null
    }
    reason: Forbidden
    status: Failure
}
...
````

Este log nos est√° diciendo que nuestra aplicaci√≥n est√° intentando listar los recursos `endpoints` del cluster de
Kubernetes, pero no tenemos los permisos necesarios para hacerlo. El error clave es este:

````bash
$ 403 Forbidden User "system:serviceaccount:default:default" cannot list resource "endpoints" in API group "" at the cluster scope
````

Nuestra aplicaci√≥n est√° usando el cliente de Kubernetes (`io.kubernetes.client.openapi`) para interactuar con la API del
cluster. Esto es com√∫n en aplicaciones que usan `Spring Cloud Kubernetes`, por ejemplo, para descubrir servicios, leer
configuraciones, o reaccionar a cambios en el cluster.

Pero por defecto, cuando un Pod se crea en el namespace `default`, se le asigna el `ServiceAccount` llamado `default`,
que `no tiene permisos para acceder a recursos` como `endpoints`, `configmaps`, `secrets`, etc.

### ¬øC√≥mo solucionarlo?

> Ejecutaremos un comando para otorgar permisos. Lo veremos en un momento.

Como ya sabemos cu√°l es la soluci√≥n, volveremos a eliminar los deployments luego a ejecutar el comando de permismos
y finalmente volvemos a crear los deployments.

````bash
$ kubectl delete -f .\kubernetes\deployments\deployment-course.yml -f .\kubernetes\deployments\deployment-user.yml
deployment.apps "d-course-service" deleted
deployment.apps "d-user-service" deleted
````

Ahora creamos el recurso de autorizaci√≥n:

````bash
$ kubectl create clusterrolebinding admin --clusterrole=cluster-admin --serviceaccount=default:default
clusterrolebinding.rbac.authorization.k8s.io/admin created
````

- `clusterrolebinding`: Asocia un `ClusterRole` (permisos a nivel de cluster) con un `ServiceAccount`.
- `admin`: Es el nombre que le asignamos al recurso `ClusterRoleBinding`. Este nombre es arbitrario y sirve como
  identificador √∫nico dentro del cluster. Podr√≠amos haberle colocado cualquier otro nombre, como `dev-access-binding` o
  `full-permissions-sa`, seg√∫n el prop√≥sito o el contexto.
- `cluster-admin`: Es el rol m√°s poderoso en `Kubernetes`. Tiene acceso total a todos los recursos en todos los
  namespaces.
- `default:default`: Se refiere al `ServiceAccount` llamado `default` en el namespace `default`, que es el que usan los
  `Pods` si no se les asigna uno expl√≠cito.

Ahora s√≠, volvemos a aplicar los deployments de cursos y usuarios:

````bash
$ kubectl apply -f .\kubernetes\deployments\deployment-user.yml -f .\kubernetes\deployments\deployment-course.yml
deployment.apps/d-user-service created
deployment.apps/d-course-service created
````

Listamos los deployments

````bash
$ kubectl get deployments
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
d-course-service   1/1     1            1           11s
d-mysql            1/1     1            1           17d
d-postgres         1/1     1            1           16d
d-user-service     1/1     1            1           11s
````

Listamos los pods.

````bash
$ kubectl get pods
NAME                               READY   STATUS    RESTARTS      AGE
d-course-service-986cc5555-2wxvh   1/1     Running   0             24s
d-mysql-5ffd47dd8-ctmt8            1/1     Running   8 (42m ago)   7d22h
d-postgres-67b99b466d-c27wb        1/1     Running   9 (42m ago)   7d22h
d-user-service-8dd5c844d-28j9w     1/1     Running   0             24s
````

Ahora volvemos a ejecutar el comando para ver el log de los pods. Veremos que esta vez se est√°n ejecutando sin
problemas.

````bash
$ kubectl logs d-course-service-986cc5555-2wxvh

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.4.5)

2025-08-12T04:33:48.769Z  INFO 1 --- [course-service] [           main] d.m.course.app.CourseServiceApplication  : Starting CourseServiceApplication v0.0.1-SNAPSHOT using Java 21.0.8 with PID 1 (/app/BOOT-INF/classes started by root in /app)
2025-08-12T04:33:48.776Z DEBUG 1 --- [course-service] [           main] d.m.course.app.CourseServiceApplication  : Running with Spring Boot v3.4.5, Spring v6.2.6
2025-08-12T04:33:48.777Z  INFO 1 --- [course-service] [           main] d.m.course.app.CourseServiceApplication  : The following 1 profile is active: "kubernetes"
2025-08-12T04:33:54.690Z  INFO 1 --- [course-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-08-12T04:33:56.500Z  INFO 1 --- [course-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 1706 ms. Found 2 JPA repository interfaces.
2025-08-12T04:33:59.501Z  INFO 1 --- [course-service] [           main] o.s.cloud.context.scope.GenericScope     : BeanFactory id=b119fb80-e7ca-32c5-ae1d-4b8eec726650
2025-08-12T04:34:05.108Z  INFO 1 --- [course-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8002 (http)
2025-08-12T04:34:05.203Z  INFO 1 --- [course-service] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2025-08-12T04:34:05.282Z  INFO 1 --- [course-service] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.40]
...
2025-08-12T04:34:39.326Z  INFO 1 --- [course-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8002 (http) with context path '/'
2025-08-12T04:34:39.502Z  INFO 1 --- [course-service] [           main] d.m.course.app.CourseServiceApplication  : Started CourseServiceApplication in 57.03 seconds (process running for 60.813)
````

Tambi√©n verificamos el logs del pod de usuario.

````bash
$ kubectl logs d-user-service-8dd5c844d-28j9w

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.4.5)

2025-08-12T04:33:42.988Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Starting UserServiceApplication v0.0.1-SNAPSHOT using Java 21.0.8 with PID 1 (/app/BOOT-INF/classes started by root in /app) 2025-08-12T04:33:42.991Z DEBUG 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Running with Spring Boot v3.4.5, Spring v6.2.6
2025-08-12T04:33:42.993Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : The following 2 profiles are active: "kubernetes", "default"
2025-08-12T04:33:50.586Z  INFO 1 --- [user-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-08-12T04:33:51.296Z  INFO 1 --- [user-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 682 ms. Found 1 JPA repository interface.
2025-08-12T04:33:52.683Z  INFO 1 --- [user-service] [           main] o.s.cloud.context.scope.GenericScope     : BeanFactory id=298bd89a-e536-345a-a2ad-f3bc3a32e59f
2025-08-12T04:33:59.509Z  INFO 1 --- [user-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8001 (http)
2025-08-12T04:33:59.797Z  INFO 1 --- [user-service] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2025-08-12T04:33:59.798Z  INFO 1 --- [user-service] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.40]
...
2025-08-12T04:34:35.596Z  INFO 1 --- [user-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8001 (http) with context path '/'
2025-08-12T04:34:35.695Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Started UserServiceApplication in 55.36 seconds (process running for 58.162)
````

Listo, como observamos, los errores han desaparecido y vemos que los microservicios se est√°n ejecutando correctamente.
