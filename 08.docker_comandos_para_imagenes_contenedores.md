# Secci√≥n 08: Docker - Comandos para manejar im√°genes y contenedores

---

# Comandos para im√°genes

----

## Listar im√°genes

````bash
$ docker image ls
REPOSITORY     TAG       IMAGE ID       CREATED      SIZE
user-service   latest    9c6a6aca8d0c   2 days ago   407MB
````

## Elimina una imagen (sin especificar tag)

La siguiente instrucci√≥n elimina la imagen `user-service`. Como no especificamos una etiqueta en particular, por defecto
elimina el`(TAG)` `latest` que es el tag por defecto. Si la imagen tiene contenedores ejecut√°ndose mostrar√° mensajes de
error y no podr√° eliminarse.

````bash
$ docker image rm user-service
Untagged: user-service:latest
Deleted: sha256:9c6a6aca8d0c7412bf993e849978b3bb8866cf8918b5daf6bedab1b2e138ac82
````

## Elimina una imagen (especificando tag)

La siguiente instrucci√≥n elimina la imagen `user-service` con tag `v1`. Si la imagen tiene contenedores ejecut√°ndose
mostrar√° mensajes de error y no podr√° eliminarse.

Primero listamos las im√°genes para ver el que eliminaremos.

````bash
$ docker image ls
REPOSITORY     TAG       IMAGE ID       CREATED      SIZE
user-service   v1        00c060ecf18c   2 days ago   407MB
user-service   latest    48b66cc5368c   2 days ago   407MB
````

Ahora s√≠, eliminamos la imagen `user-service` con tag `v1`.

````bash
$ docker image rm user-service:v1
Untagged: user-service:v1
Deleted: sha256:00c060ecf18c504fd7d30c109e39741df8c341f8f4215520f5527d178d4eda69
````

## Elimina im√°genes no utilizadas

Elimina todas las im√°genes no usadas o inactivas (dangling images) de Docker. Las im√°genes inactivas son im√°genes que
no tienen etiquetas y no est√°n asociadas con contenedores en ejecuci√≥n o detenidos.

````bash
$ docker image prune
````

## Inspecciona imagen

El comando `inspect` muestra informaci√≥n detallada sobre la imagen de Docker. Este comando devuelve
un objeto en formato JSON con una serie de metadatos sobre la imagen, tales como:

- `Id`: El identificador √∫nico (ID) de la imagen, representado como un hash.
- `RepoTags`: Las etiquetas de repositorio, como user-service:latest, que identifican la imagen.
- `Created`: La fecha y hora en que la imagen fue creada.
- `ExposedPorts`: Los puertos expuestos en el contenedor, en este caso, 8001/tcp.
- `Env`: Variables de entorno configuradas dentro de la imagen (como la versi√≥n de Java).
- `Cmd`: El comando por defecto que se ejecuta cuando el contenedor se inicia (en tu caso, `java`
  `org.springframework.boot.loader.launch.JarLauncher`).
- `Layers`: Una lista de los hashes de las capas de la imagen, que indican c√≥mo se compone la imagen a nivel de sistema
  de archivos.
- `Size`: El tama√±o total de la imagen en bytes.
- `GraphDriver`: Informaci√≥n sobre el sistema de almacenamiento utilizado, como overlay2.

Este comando es √∫til cuando quieres revisar los detalles internos de la imagen, como sus capas, configuraci√≥n de
puertos, comandos, etc.

````bash
$ docker image inspect user-service
[
    {
        "Id": "sha256:3d6e1ac368580d0d5cae4942c9d5ff8247dedc944a5a17a771293ab1bd0cc944",
        "RepoTags": [
            "user-service:latest"
        ],
        "RepoDigests": [
            "user-service@sha256:3d6e1ac368580d0d5cae4942c9d5ff8247dedc944a5a17a771293ab1bd0cc944"
        ],
        "Parent": "",
        "Comment": "buildkit.dockerfile.v0",
        "Created": "2025-05-23T04:39:46.309349177Z",
        "DockerVersion": "",
        "Author": "",
        "Config": {
            "Hostname": "",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "ExposedPorts": {
                "8001/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/opt/java/openjdk/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "JAVA_HOME=/opt/java/openjdk",
                "LANG=en_US.UTF-8",
                "LANGUAGE=en_US:en",
                "LC_ALL=en_US.UTF-8",
                "JAVA_VERSION=jdk-21.0.7+6"
            ],
            "Cmd": [
                "java",
                "org.springframework.boot.loader.launch.JarLauncher"
            ],
            "ArgsEscaped": true,
            "Image": "",
            "Volumes": null,
            "WorkingDir": "/app",
            "Entrypoint": [
                "/__cacert_entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": null
        },
        "Architecture": "amd64",
        "Os": "linux",
        "Size": 131600847,
        "GraphDriver": {
            "Data": null,
            "Name": "overlayfs"
        },
        "RootFS": {
            "Type": "layers",
            "Layers": [
                "sha256:08000c18d16dadf9553d747a58cf44023423a9ab010aab96cf263d2216b8b350",
                "sha256:343c5fbeb913f2ca566e329bd1a1a82d1fa9bd4cd3b978600a4bd1f393abf2fd",
                "sha256:d34c6dad4fc84c4d92ab906ddd97ab0f39548bc002093c146705faca0740af73",
                "sha256:002d22842e01692f8f3acfd0d4015ef6340f14c694ea05dc0701328025c2ae7e",
                "sha256:5c70c8580947e31e01c006bf2c3c49d02b5a47019a549982c5040151816fe1ce",
                "sha256:9daa96500800074a04730109aa086bd9e7aa754621634efac81d535178c840de",
                "sha256:e4d29b9ba970f0eef832ee9afdf47739185df59c5b75736fe782a77f4d1b1a76",
                "sha256:6faa915d79865c583eead18a64b01851be4e31983a2b245c80789eb951c6dbb4",
                "sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef",
                "sha256:7a9687dadcf9b637da6b91d3d3899505a90add2870c2f3cd6e9793ff807269bc"
            ]
        },
        "Metadata": {
            "LastTagTime": "2025-05-25T18:10:53.432302378Z"
        },
        "Descriptor": {
            "mediaType": "application/vnd.oci.image.index.v1+json",
            "digest": "sha256:3d6e1ac368580d0d5cae4942c9d5ff8247dedc944a5a17a771293ab1bd0cc944",
            "size": 856
        }
    }
]
````

## Etiqueta imagen

Podemos crear una imagen asign√°ndole una etiqueta (`tag`). Si no le asignamos ninguna etiqueta, por defecto tomar√° el
valor `latest`. Hasta el momento ya tenemos creado la imagen `user-service` con la etiqueta `latest`, que es la
etiqueta por defecto.

````bash
$ ocker image ls
REPOSITORY     TAG       IMAGE ID       CREATED      SIZE
user-service   latest    3d6e1ac36858   2 days ago   407MB
````

Ahora, crearemos una nueva imagen con la etiqueta `v1`.

````bash
$ D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-8)                                                                            
$ docker image build -t user-service:v1 .\business-domain\user-service -f .\business-domain\user-service\Dockerfile                                                                   
[+] Building 1.3s (24/24) FINISHED                                                                                                                                docker:desktop-linux
 => [internal] load build definition from Dockerfile                                                                                                                              0.0s
 => => transferring dockerfile: 776B                                                                                                                                              0.0s
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jre-alpine                                                                                                  1.0s
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                                                                  1.0s
 => [auth] library/eclipse-temurin:pull token for registry-1.docker.io                                                                                                            0.0s
 => [internal] load .dockerignore                                                                                                                                                 0.0s
 => => transferring context: 214B                                                                                                                                                 0.0s
 => [dependencies 1/9] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0                               0.1s
 => => resolve docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0                                            0.0s
 => [internal] load build context                                                                                                                                                 0.0s
 => => transferring context: 2.98kB                                                                                                                                               0.0s
 => [builder 1/4] FROM docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd                                    0.1s
 => => resolve docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd                                            0.0s
 => CACHED [builder 2/4] WORKDIR /app                                                                                                                                             0.0s
 => CACHED [dependencies 2/9] WORKDIR /app                                                                                                                                        0.0s
 => CACHED [dependencies 3/9] COPY ./mvnw ./                                                                                                                                      0.0s
 => CACHED [dependencies 4/9] COPY ./.mvn ./.mvn                                                                                                                                  0.0s
 => CACHED [dependencies 5/9] COPY ./pom.xml ./                                                                                                                                   0.0s
 => CACHED [dependencies 6/9] RUN sed -i -e 's/\r$//' ./mvnw                                                                                                                      0.0s
 => CACHED [dependencies 7/9] RUN ./mvnw dependency:go-offline                                                                                                                    0.0s
 => CACHED [dependencies 8/9] COPY ./src ./src                                                                                                                                    0.0s
 => CACHED [dependencies 9/9] RUN ./mvnw clean package -DskipTests                                                                                                                0.0s
 => CACHED [builder 3/4] COPY --from=dependencies /app/target/*.jar ./app.jar                                                                                                     0.0s
 => CACHED [builder 4/4] RUN java -Djarmode=layertools -jar app.jar extract                                                                                                       0.0s
 => CACHED [runner 3/6] COPY --from=builder /app/dependencies ./                                                                                                                  0.0s
 => CACHED [runner 4/6] COPY --from=builder /app/spring-boot-loader ./                                                                                                            0.0s
 => CACHED [runner 5/6] COPY --from=builder /app/snapshot-dependencies ./                                                                                                         0.0s
 => CACHED [runner 6/6] COPY --from=builder /app/application ./                                                                                                                   0.0s
 => exporting to image                                                                                                                                                            0.1s
 => => exporting layers                                                                                                                                                           0.0s
 => => exporting manifest sha256:f8469b8029893ffb33a7c126ba7bed43af855044a9376ea4e9266c8452399dec                                                                                 0.0s
 => => exporting config sha256:31201a78d21650ee023e12e4e3a977910e595c45687666334f344bf327d0b476                                                                                   0.0s
 => => exporting attestation manifest sha256:1a2abc9aaf817736362547571e12cb99121ec21ff8bf41a1237771e8628d89ed                                                                     0.0s
 => => exporting manifest list sha256:3b3a3c4b45f5c4a24b4d2c0d9f39a15cb3a50b2cb8da6ed4d65581e2c267b637                                                                            0.0s
 => => naming to docker.io/library/user-service:v1                                                                                                                                0.0s
 => => unpacking to docker.io/library/user-service:v1                                                                                                                             0.0s
                                                                                                                                                                                      
View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/xffy50yhagfhtjzzwankr1rii
````

Si listamos las im√°genes veremos que ahora tenemos dos versiones, la imagen con etiqueta `latest` y `v1`.

````bash
$ docker image ls
REPOSITORY     TAG       IMAGE ID       CREATED      SIZE
user-service   latest    3d6e1ac36858   2 days ago   407MB
user-service   v1        3b3a3c4b45f5   2 days ago   407MB
````

## Renombra etiqueta de imagen

El comando para renombrar la etiqueta de una imagen en Docker es `docker image tag`. Este comando permite asignar una
nueva etiqueta (o `tag`) a una imagen existente, lo cual es equivalente a renombrarla.

Listamos para verificar las im√°genes y etiquetas que tenemos.

````bash
$ docker image ls
REPOSITORY     TAG       IMAGE ID       CREATED      SIZE
user-service   latest    3d6e1ac36858   2 days ago   407MB
user-service   v1        3b3a3c4b45f5   2 days ago   407MB
````

A continuaci√≥n, asignaremos una nueva etiqueta a la imagen `user-service:latest`, de forma que tambi√©n est√© disponible
como `magadiflo/user-service:v2`.

````bash
$ docker image tag user-service:latest magadiflo/user-service:v2
````

Despu√©s de ejecutar el comando anterior, listamos las im√°genes para comprobar la existencia de la nueva etiqueta.

````bash
$ docker image ls
REPOSITORY               TAG       IMAGE ID       CREATED      SIZE
user-service             latest    3d6e1ac36858   2 days ago   407MB
magadiflo/user-service   v2        3d6e1ac36858   2 days ago   407MB
user-service             v1        3b3a3c4b45f5   2 days ago   407MB
````

Como se puede observar, no se ha creado una nueva imagen, sino que se ha generado una nueva etiqueta
(`magadiflo/user-service:v2`) que apunta al mismo `ID de imagen` (`3d6e1ac36858`). Es decir, ahora la misma imagen
tiene m√∫ltiples nombres o etiquetas asociadas.

---

# Comandos para contenedores

---

## Crea contenedor (attach)

Si ejecutamos el siguiente comando sin la bandera `-d`, la terminal quedar√° enganchado, es decir veremos la ejecuci√≥n
del contenedor en primer plano sin tener control de la l√≠nea de comando.

````bash
$ docker container run -p 8085:8001 user-service

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.4.5)

2025-05-25T18:44:51.232Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Starting UserServiceApplication v0.0.1-SNAPSHOT using Java 21.0.7 with PID 1 (/app/BOOT-INF/classes started by root in /app) 2025-05-25T18:44:51.235Z DEBUG 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Running with Spring Boot v3.4.5, Spring v6.2.6
2025-05-25T18:44:51.237Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : No active profile set, falling back to 1 default profile: "default"
2025-05-25T18:44:52.469Z  INFO 1 --- [user-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-05-25T18:44:52.554Z  INFO 1 --- [user-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 61 ms. Found 1 JPA repository interface.
2025-05-25T18:44:52.759Z  INFO 1 --- [user-service] [           main] o.s.cloud.context.scope.GenericScope     : BeanFactory id=91540a6b-3294-3658-b380-dfb1c22ae3d2
2025-05-25T18:44:53.531Z  INFO 1 --- [user-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8001 (http)
2025-05-25T18:44:53.552Z  INFO 1 --- [user-service] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2025-05-25T18:44:53.553Z  INFO 1 --- [user-service] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.40]
2025-05-25T18:44:53.602Z  INFO 1 --- [user-service] [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2025-05-25T18:44:53.604Z  INFO 1 --- [user-service] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 2302 ms
2025-05-25T18:44:53.997Z  INFO 1 --- [user-service] [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2025-05-25T18:44:54.056Z  INFO 1 --- [user-service] [           main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 6.6.13.Final
2025-05-25T18:44:54.093Z  INFO 1 --- [user-service] [           main] o.h.c.internal.RegionFactoryInitiator    : HHH000026: Second-level cache disabled
2025-05-25T18:44:54.412Z  INFO 1 --- [user-service] [           main] o.s.o.j.p.SpringPersistenceUnitInfo      : No LoadTimeWeaver setup: ignoring JPA class transformer
2025-05-25T18:44:54.450Z  INFO 1 --- [user-service] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2025-05-25T18:44:54.970Z  INFO 1 --- [user-service] [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@7cbede2b
2025-05-25T18:44:54.973Z  INFO 1 --- [user-service] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2025-05-25T18:44:55.074Z  INFO 1 --- [user-service] [           main] org.hibernate.orm.connections.pooling    : HHH10001005: Database info:
        Database JDBC URL [Connecting through datasource 'HikariDataSource (HikariPool-1)']
        Database driver: undefined/unknown
        Database version: 8.0.41
        Autocommit mode: undefined/unknown
        Isolation level: undefined/unknown
        Minimum pool size: undefined/unknown
        Maximum pool size: undefined/unknown
2025-05-25T18:44:56.089Z  INFO 1 --- [user-service] [           main] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000489: No JTA platform available (set 'hibernate.transaction.jta.platform' to enable JTA platform integration)
2025-05-25T18:44:56.138Z  INFO 1 --- [user-service] [           main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2025-05-25T18:44:56.789Z  WARN 1 --- [user-service] [           main] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2025-05-25T18:44:57.825Z  INFO 1 --- [user-service] [           main] o.s.b.a.e.web.EndpointLinksResolver      : Exposing 1 endpoint beneath base path '/actuator'
2025-05-25T18:44:57.942Z  INFO 1 --- [user-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8001 (http) with context path '/'
2025-05-25T18:44:57.960Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Started UserServiceApplication in 7.276 seconds (process running for 8.065)
````

**Donde**

- `docker container run`, permite corre un nuevo contenedor.
- `-p 8005:8001`, asigna un puerto `externo:interno` al contenedor.
- `user-service`, nombre de la imagen a partir del cual se crea el contenedor. Como no especificamos el tag, por defecto
  usar√° la imagen con tag `latest`.
- `¬øQu√© es el modo attach?`, la posesi√≥n de la terminal luego de ejecutar el comando.

### Des-atachar deteniendo el contenedor

Si queremos volver a tener el control de la l√≠nea de comando debemos presionar `Ctrl + C`, pero esto detendr√° el
contenedor, cambiando su status `Up` por `Exited`.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED              STATUS                       PORTS     NAMES
f4d4875b5032   user-service   "/__cacert_entrypoin‚Ä¶"   About a minute ago   Exited (130) 9 seconds ago             brave_antonelli
````

### Des-atachar sin detener el contenedor

Si tu terminal qued√≥ atachada al contenedor despu√©s de ejecutar `docker container run`, puedes recuperar el control de
la terminal sin detener el contenedor usando la siguiente combinaci√≥n de teclas.

````bash
Ctrl + P
Ctrl + Q
````

**Nota**
> A m√≠ no me funcion√≥ la combinaci√≥n de teclas, pero en la mayor√≠a de las fuentes consultadas mencionan esa combinaci√≥n.
> As√≠ que para evitar problemas lo mejor ser√° que cuando cree un contenedor agregarle el flag `-d` para que siempre se
> cree `des-atachado`.

## Crea contenedor con el flag -d (detach)

Si ejecutamos un contenedor usando el flag `-d` estaremos ejecut√°ndolo en modo `dettached`, es decir, el contenedor
se ejecutar√° en segundo plano, sin que la terminal quede `atachada` a √©l. Esto nos permite seguir usando la terminal
para otros comandos, mientras el contenedor sigue corriendo en segundo plano.

````bash
$ docker container run -d -p 8001:8001 user-service
893ea8741f0050270fcb792e050d9ecf7e7fe13f66002d1bedaa42927b350d8b
````

## Lista todos los contenedores

El siguiente comando se utiliza para listar todos los contenedores en tu sistema, incluyendo tanto los que
est√°n en ejecuci√≥n como los que han sido detenidos. La opci√≥n `-a` significa `all` (todos), y nos muestra el estado
completo de los contenedores, no solo los que est√°n activos.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                    NAMES
893ea8741f00   user-service   "/__cacert_entrypoin‚Ä¶"   4 minutes ago   Up 4 minutes   0.0.0.0:8001->8001/tcp   compassionate_wilson
````

- `docker container ls`: Muestra solo los contenedores que est√°n en ejecuci√≥n en ese momento.
- `docker container ls -a`: Muestra todos los contenedores, independientemente de si est√°n en ejecuci√≥n, detenidos
  o en estado creado pero nunca ejecutados.

## Detiene contenedor en ejecuci√≥n

Con el siguiente comando detenemos uno o m√°s contenedores que est√°n en ejecuci√≥n. Para eso utilizamos el `CONTAINER_ID`
de los contenedores a detener.

````bash
$ docker container stop 893ea8741f00
893ea8741f00
````

Si listamos los contenedores, vemos que el contenedor ya est√° detenido (`Exited`).

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS                        PORTS     NAMES
893ea8741f00   user-service   "/__cacert_entrypoin‚Ä¶"   5 minutes ago   Exited (143) 19 seconds ago             compassionate_wilson
````

## Inicia contenedor detenido

Con el siguiente comando iniciamos uno o m√°s contenedores detenidos.

````bash
$ docker container start 893ea8741f00
893ea8741f00
````

Si volvemos a listar los contenedores, vemos que el contenedor con id `893ea8741f00` se volvi√≥ a levantar.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS          PORTS                    NAMES
893ea8741f00   user-service   "/__cacert_entrypoin‚Ä¶"   6 minutes ago   Up 17 seconds   0.0.0.0:8001->8001/tcp   compassionate_wilson
````

## Muestra log del contenedor

El siguiente comando permite ver los `logs` de un contenedor en espec√≠fico en `Docker`. En nuestro caso estamos usando
el `893ea8741f00` como ID del contenedor que deseamos ver sus registros.

Este comando `no toma posesi√≥n de la terminal`.

````bash
$ docker container logs 893ea8741f00

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.4.5)

2025-05-25T18:49:14.228Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Starting UserServiceApplication v0.0.1-SNAPSHOT using Java 21.0.7 with PID 1 (/app/BOOT-INF/classes started by root in /app) 2025-05-25T18:49:14.230Z DEBUG 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Running with Spring Boot v3.4.5, Spring v6.2.6
2025-05-25T18:49:14.231Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : No active profile set, falling back to 1 default profile: "default"
2025-05-25T18:49:15.409Z  INFO 1 --- [user-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-05-25T18:49:15.474Z  INFO 1 --- [user-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 54 ms. Found 1 JPA repository interface.
2025-05-25T18:49:15.687Z  INFO 1 --- [user-service] [           main] o.s.cloud.context.scope.GenericScope     : BeanFactory id=91540a6b-3294-3658-b380-dfb1c22ae3d2
2025-05-25T18:49:16.455Z  INFO 1 --- [user-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8001 (http)
2025-05-25T18:49:16.472Z  INFO 1 --- [user-service] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2025-05-25T18:49:16.472Z  INFO 1 --- [user-service] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.40]
2025-05-25T18:49:16.509Z  INFO 1 --- [user-service] [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
...
````

## Muestra log del contenedor en tiempo real (-f o --follow)

Para seguir viendo los `logs` en tiempo real podemos usar el flag `-f` o `--follow`.

‚ö†Ô∏è Importante
> Si luego queremos dejar de dar seguimiento al log, simplemente presionamos `Ctrl + C` para retomar el control de la
> l√≠nea de comandos. El contenedor seguir√° ejecut√°ndose por debajo, es decir, en este caso el contenedor no se detendr√°,
> seguir√° ejecut√°ndose.

````bash
$ docker container logs 940bc9dd5ef8 -f

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.4.5)

2025-05-26T00:36:09.474Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Starting UserServiceApplication v0.0.1-SNAPSHOT using Java 21.0.7 with PID 1 (/app/BOOT-INF/classes started by root in /app) 2025-05-26T00:36:09.477Z DEBUG 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Running with Spring Boot v3.4.5, Spring v6.2.6
2025-05-26T00:36:09.478Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : No active profile set, falling back to 1 default profile: "default"
2025-05-26T00:36:10.877Z  INFO 1 --- [user-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-05-26T00:36:10.978Z  INFO 1 --- [user-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 86 ms. Found 1 JPA repository interface.
2025-05-26T00:36:11.216Z  INFO 1 --- [user-service] [           main] o.s.cloud.context.scope.GenericScope     : BeanFactory id=91540a6b-3294-3658-b380-dfb1c22ae3d2
2025-05-26T00:36:12.042Z  INFO 1 --- [user-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8001 (http)
2025-05-26T00:36:12.059Z  INFO 1 --- [user-service] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2025-05-26T00:36:12.059Z  INFO 1 --- [user-service] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.40]
2025-05-26T00:36:12.105Z  INFO 1 --- [user-service] [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2025-05-26T00:36:12.107Z  INFO 1 --- [user-service] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 2546 ms
2025-05-26T00:36:12.489Z  INFO 1 --- [user-service] [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2025-05-26T00:36:12.542Z  INFO 1 --- [user-service] [           main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 6.6.13.Final
2025-05-26T00:36:12.575Z  INFO 1 --- [user-service] [           main] o.h.c.internal.RegionFactoryInitiator    : HHH000026: Second-level cache disabled
2025-05-26T00:36:12.906Z  INFO 1 --- [user-service] [           main] o.s.o.j.p.SpringPersistenceUnitInfo      : No LoadTimeWeaver setup: ignoring JPA class transformer
2025-05-26T00:36:12.939Z  INFO 1 --- [user-service] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2025-05-26T00:36:13.531Z  INFO 1 --- [user-service] [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@706d2bae
2025-05-26T00:36:13.534Z  INFO 1 --- [user-service] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2025-05-26T00:36:13.665Z  INFO 1 --- [user-service] [           main] org.hibernate.orm.connections.pooling    : HHH10001005: Database info:
        Database JDBC URL [Connecting through datasource 'HikariDataSource (HikariPool-1)']
        Database driver: undefined/unknown
        Database version: 8.0.41
        Autocommit mode: undefined/unknown
        Isolation level: undefined/unknown
        Minimum pool size: undefined/unknown
        Maximum pool size: undefined/unknown
2025-05-26T00:36:14.701Z  INFO 1 --- [user-service] [           main] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000489: No JTA platform available (set 'hibernate.transaction.jta.platform' to enable JTA platform integration)
2025-05-26T00:36:14.755Z  INFO 1 --- [user-service] [           main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2025-05-26T00:36:15.440Z  WARN 1 --- [user-service] [           main] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2025-05-26T00:36:16.338Z  INFO 1 --- [user-service] [           main] o.s.b.a.e.web.EndpointLinksResolver      : Exposing 1 endpoint beneath base path '/actuator'
2025-05-26T00:36:16.426Z  INFO 1 --- [user-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8001 (http) with context path '/'
2025-05-26T00:36:16.446Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Started UserServiceApplication in 7.51 seconds (process running for 8.129)
2025-05-26T00:37:50.344Z  INFO 1 --- [user-service] [nio-8001-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2025-05-26T00:37:50.345Z  INFO 1 --- [user-service] [nio-8001-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2025-05-26T00:37:50.348Z  INFO 1 --- [user-service] [nio-8001-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 2 ms
2025-05-26T00:38:25.149Z DEBUG 1 --- [user-service] [nio-8001-exec-3] org.hibernate.SQL                        :
    select
        u1_0.id,
        u1_0.email,
        u1_0.name,
        u1_0.password
    from
        users u1_0
    where
        u1_0.id=?
````

## Elimina contenedor que est√° detenido (Exited)

````bash
$ docker container rm 940bc9dd5ef8
````

## Fuerza la eliminaci√≥n de un contenedor que est√° siendo ejecutado (Up)

````bash
$ docker container rm -f 940bc9dd5ef8
````

## Elimina todos los contenedores detenidos (Exited)

Este comando eliminar√° solo los contenedores detenidos `Exited`, no eliminar√° los contenedores con status `Up`.

````bash
$ docker container prune
WARNING! This will remove all stopped containers.
Are you sure you want to continue? [y/N] y
Total reclaimed space: 0B
````

## Elimina autom√°ticamente el contenedor cuando se detenga (--rm)

Con el siguiente comando creamos un contendor. Ahora, como le hemos agregado el flag `--rm`, esta opci√≥n indica que
Docker debe eliminar autom√°ticamente el contenedor cuando se detenga. Esto es √∫til para evitar que queden contenedores
detenidos que no se utilizar√°n, manteniendo as√≠ el sistema m√°s limpio.

````bash
$ docker container run -d -p 9002:8001 --rm user-service
ad9821a9aac5a5b5a8f2ace77bcc14accf3be37bcda89bec58dc0227d9d60491
````

Al listar los contenedores vemos que el que acabamos de levantar est√° en status `Up`.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                    NAMES
ad9821a9aac5   user-service   "/__cacert_entrypoin‚Ä¶"   12 seconds ago   Up 12 seconds   0.0.0.0:9002->8001/tcp   gifted_sanderson
940bc9dd5ef8   user-service   "/__cacert_entrypoin‚Ä¶"   11 minutes ago   Up 11 minutes   0.0.0.0:8001->8001/tcp   xenodochial_kilby
````

Ahora procedemos a detener el contenedor creado anteriormente.

````bash
$ docker container stop ad9821a9aac5
ad9821a9aac5
````

Al volver a listar los contenedores vemos que el contenedor creado anteriormente fue eliminado autom√°ticamente.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                    NAMES
940bc9dd5ef8   user-service   "/__cacert_entrypoin‚Ä¶"   12 minutes ago   Up 12 minutes   0.0.0.0:8001->8001/tcp   xenodochial_kilby
````

## Ingresa en modo interactivo en contenedor en ejecuci√≥n (exec -it)

El siguiente comando se utiliza para ejecutar un nuevo proceso dentro de un contenedor que ya est√° en ejecuci√≥n.
Vamos a desglosar cada parte del comando para entender su funcionalidad:

````bash
$ docker container exec -it 940bc9dd5ef8 /bin/sh
/app # ls
BOOT-INF  META-INF  org
/app # cd ..
/ # ls -l
total 72
-rwxr-xr-x   1 root root 5307 Apr 23 16:31 __cacert_entrypoint.sh
drwxr-xr-x   1 root root 4096 May 23 04:39 app
drwxr-xr-x   1 root root 4096 Apr 23 16:31 bin
drwxr-xr-x   5 root root  340 May 26 00:36 dev
drwxr-xr-x   1 root root 4096 May 26 00:36 etc
drwxr-xr-x   2 root root 4096 Feb 13 23:04 home
drwxr-xr-x   1 root root 4096 Feb 13 23:04 lib
drwxr-xr-x   5 root root 4096 Feb 13 23:04 media
drwxr-xr-x   2 root root 4096 Feb 13 23:04 mnt
drwxr-xr-x   1 root root 4096 Apr 23 16:31 opt
dr-xr-xr-x 246 root root    0 May 26 00:36 proc
drwx------   1 root root 4096 May 26 00:50 root
drwxr-xr-x   3 root root 4096 Feb 13 23:04 run
drwxr-xr-x   2 root root 4096 Feb 13 23:04 sbin
drwxr-xr-x   2 root root 4096 Feb 13 23:04 srv
dr-xr-xr-x  11 root root    0 May 26 00:36 sys
drwxrwxrwt   1 root root 4096 May 26 00:36 tmp
drwxr-xr-x   1 root root 4096 Apr 23 16:31 usr
drwxr-xr-x   1 root root 4096 Feb 13 23:04 var
/ #
````

**Donde**

- `exec`, ejecuta un comando en un contenedor que ya est√° en funcionamiento.
- `-it`, esta opci√≥n combina dos banderas:
    - `-i` (interactivo): Mantiene la entrada est√°ndar (STDIN) abierta, permitiendo que interact√∫es con el proceso que
      est√°s ejecutando en el contenedor.
    - `-t` (terminal): Asigna un pseudo-terminal, lo que permite que la salida del comando se formatee correctamente,
      proporcionando una experiencia similar a la de un terminal normal.
- `/bin/sh`, este es el comando que se ejecutar√° dentro del contenedor. En este caso, est√°s iniciando un shell de
  comandos `(sh)`. Esto te permitir√° interactuar con el sistema de archivos del contenedor y ejecutar otros comandos
  dentro de √©l.

Como se observa en el resultado anterior, pudimos ingresar dentro del contenedor en ejecuci√≥n y lo primero que hice fue
listar el contenido del directorio actual `/app`. Recordemos que dicho directorio es el que definimos en el `WORKDIR`
del `Dockerfile` y en el que extra√≠mos como resultado final el contenido de nuestro `jar`.

## Ingresar en modo interactivo al iniciar la creaci√≥n de un nuevo contenedor

En este caso vamos a crear un nuevo contenedor, pero vamos a ingresar directamente a √©l para inspeccionar su contenido
(`-it`) y cuando salgamos de √©l con el comando `exit`, el contenedor se borrar√° autom√°ticamente:

````bash
$  docker container run -p 9001:8001 --rm -it user-service /bin/sh
/app # ls
BOOT-INF  META-INF  org
/app #
````

Si abrimos otro terminal, veremos que el contenedor est√° con status `Up`.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                    NAMES
0f4e80bea695   user-service   "/__cacert_entrypoin‚Ä¶"   38 seconds ago   Up 37 seconds   0.0.0.0:9001->8001/tcp   cool_chebyshev
940bc9dd5ef8   user-service   "/__cacert_entrypoin‚Ä¶"   20 minutes ago   Up 20 minutes   0.0.0.0:8001->8001/tcp   xenodochial_kilby
````

Ahora, si escribimos el comando `exit` para salir, veremos que el contenedor se eliminar√° autom√°ticamente (`--rm`).

````bash
$ docker container run -p 9001:8001 --rm -it user-service /bin/sh
/app # ls
BOOT-INF  META-INF  org
/app # exit
````

Comprobamos que el contenedor se elimin√≥ autom√°ticamente.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                    NAMES
940bc9dd5ef8   user-service   "/__cacert_entrypoin‚Ä¶"   21 minutes ago   Up 21 minutes   0.0.0.0:8001->8001/tcp   xenodochial_kilby
````

‚úÖ En resumen
> Hemos creado un nuevo contenedor agregando el comando `--rm` para que cuando nos salgamos del contendor
> escribiendo `exit`, √©ste se elimine autom√°ticamente. Tambi√©n hemos agregado el comando `-it` para utilizar el
> `terminal interactivo` del contenedor, luego el nombre de la imagen y finalmente la instrucci√≥n `/bin/sh`.

## Copia archivos

### Desde M√°quina Local hacia Contenedor

Podemos copiar archivos que est√°n en nuestra m√°quina local hacia dentro de un **contenedor que est√° en ejecuci√≥n**.
Par eso, crearemos un contenedor con el siguiente comando.

````bash
$ docker container run -p 9001:8001 --rm -it user-service /bin/sh
/app # ls
BOOT-INF  META-INF  org
/app #
````

Ahora, nos posicionaremos con la terminal en el directorio donde est√° el archivo que queremos copiar. En nuestro caso
ser√° el archivo `Lec04WindowAssignment.java`.

````bash
D:\
$ ls -l
total 16
drwxr-xr-x 1 magadiflo 197121    0 Apr  1 22:05 '$RECYCLE.BIN'/
drwxr-xr-x 1 magadiflo 197121    0 Apr  3 16:29  formalities/
drwxr-xr-x 1 magadiflo 197121    0 Apr  3 16:06  installers/
drwxr-xr-x 1 magadiflo 197121    0 Apr  4 09:51  job_history/
-rw-r--r-- 1 magadiflo 197121 2104 May 25 20:10  Lec04WindowAssignment.java
drwxr-xr-x 1 magadiflo 197121    0 Apr  4 09:49  programming/
drwxr-xr-x 1 magadiflo 197121    0 Apr  1 22:58 'System Volume Information'/
````

Antes de copiar el archivo, necesitamos averiguar el identificador o el nombre del contenedor.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                    NAMES
28f23de065f1   user-service   "/__cacert_entrypoin‚Ä¶"   2 minutes ago    Up 2 minutes    0.0.0.0:9001->8001/tcp   compassionate_dhawan
940bc9dd5ef8   user-service   "/__cacert_entrypoin‚Ä¶"   36 minutes ago   Up 36 minutes   0.0.0.0:8001->8001/tcp   xenodochial_kilby
````

Ahora, usando el comando `cp` copiamos el archivo `Lec04WindowAssignment.java` hacia un directorio dentro del
contenedor. En nuestro caso lo copiaremos en nuestro directorio `/app`. Notar que estamos usando el identificador del
contenedor (`28f23de065f1`) a donde copiaremos el archivo.

````bash
D:\
$ docker container cp .\Lec04WindowAssignment.java 28f23de065f1:/app
Successfully copied 4.1kB to 28f23de065f1:/app
````

**Donde**

- `cp`, copia `archivos/carpetas` entre el sistema de archivos local y un contenedor.
- `.\Lec04WindowAssignment.java 28f23de065f1:/app`, el archivo `Lec04WindowAssignment.java` que ser√° copiado en el
  contenedor con ID `28f23de065f1` y dentro del contenedor se copiar√° en el WORKDIR `/app`.

Luego de haber copiado, listamos el directorio `/app` para ver que el archivo fue copiado correctamente, incluso
podemos ver el contenido de dicho archivo.

````bash
$ docker container run -p 9001:8001 --rm -it user-service /bin/sh
/app # ls
BOOT-INF  META-INF  org
/app # ls
BOOT-INF  Lec04WindowAssignment.java  META-INF  org
/app # cat Lec04WindowAssignment.java
package dev.magadiflo.app.sec10;

import dev.magadiflo.app.common.Util;
import dev.magadiflo.app.sec10.assignment.window.FileWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.nio.file.Path;
import java.time.Duration;

public class Lec04WindowAssignment {

    private static final Logger log = LoggerFactory.getLogger(Lec04WindowAssignment.class);
    private static final String PATH = "src/main/resources/sec10/";

    public static void main(String[] args) {
        cleanDirectory()
                .thenMany(eventStream())
                .window(Duration.ofMillis(1800))
                .zipWith(sequential())
                .flatMap(tuple -> {
                    Flux<String> window = tuple.getT1();
                    Integer count = tuple.getT2();
                    return processEvents(window, count);
                })
                .subscribe();

        Util.sleepSeconds(60);
    }

    private static Mono<Void> cleanDirectory() {
        return Mono.fromRunnable(() -> {
            FileWriter.cleanDirectory(Path.of(PATH));
        });
    }

    private static Flux<Integer> sequential() {
        return Flux.generate(
                () -> 1,
                (count, synchronousSink) -> {
                    synchronousSink.next(count);
                    return count + 1;
                }
        );
    }

    private static Flux<String> eventStream() {
        return Flux.interval(Duration.ofMillis(500))
                .map(value -> "evento-" + (value + 1));
    }

    private static Mono<Void> processEvents(Flux<String> flux, int count) {
        String fileName = "log-" + count + ".txt";
        Path path = Path.of(PATH + fileName);
        return flux
                .doFirst(() -> FileWriter.createFile(path))
                .doOnNext(value -> FileWriter.writeFile(path, value))
                .doOnComplete(() -> log.info("Fin de escritura {}\n", fileName))
                .then();
    }
}
/app #
````

### Desde Contenedor hacia M√°quina Local

En este apartado copiaremos un archivo o directorio de nuestro contenedor hacia nuestra m√°quina local. Para eso
creamos un nuevo contenedor en modo interactivo y de eliminaci√≥n autom√°tica.

En este contenedor creamos un directorio `/test` y dentro de √©l un archivo `my_custom_file.txt`.

````bash
$ docker container run -p 9001:8001 --rm -it user-service /bin/sh
/app # ls
BOOT-INF  META-INF  org
/app # mkdir test
/app # ls
BOOT-INF  META-INF  org  test
/app # cd test/
/app/test # ls
/app/test # echo "Archivo creado desde dentro del contenedor" > my_custom_file.txt
/app/test # ls
my_custom_file.txt
/app/test # cat my_custom_file.txt
Archivo creado desde dentro del contenedor
/app/test #
````

Averiguamos cu√°l es el identificador del contenedor del cual copiaremos su archivo.

````bash
docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED              STATUS              PORTS                    NAMES
392b32602454   user-service   "/__cacert_entrypoin‚Ä¶"   About a minute ago   Up About a minute   0.0.0.0:9001->8001/tcp   adoring_engelbart
940bc9dd5ef8   user-service   "/__cacert_entrypoin‚Ä¶"   44 minutes ago       Up 44 minutes       0.0.0.0:8001->8001/tcp   xenodochial_kilby
````

Ahora, usando el comando `cp`, copiamos el directorio `/test` de nuestro contenedor hacia una direcci√≥n en nuestra
m√°quina local.

````bash
$ docker container cp 392b32602454:/app/test D:\
Successfully copied 2.56kB to D:\
````

**Donde**

- `392b32602454`, ID del contenedor de donde copiaremos.
- `/app/test`, directorio que copiaremos del contenedor hacia nuestra m√°quina local.
- `D:\`, ruta de destino en nuestra m√°quina local.

> üìå`Nota`, si estamos ubicados mediante la l√≠nea de comandos en el directorio `D:\` y es a esa ruta a donde
> queremos copiar el contenido, podr√≠amos usar el `.` (contexto actual) en vez de la ruta `D:\`.

Verificamos que efectivamente, el copiado fue exitoso.

````bash
D:\test
$ ls -l
total 1
-rw-r--r-- 1 magadiflo 197121 43 May 25 20:19 my_custom_file.txt

D:\test
$ cat my_custom_file.txt
Archivo creado desde dentro del contenedor
````
