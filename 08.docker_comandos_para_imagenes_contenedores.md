# Sección 08: Docker - Comandos para manejar imágenes y contenedores

---

# Comandos para imágenes

----

## Listar imágenes

````bash
$ docker image ls
REPOSITORY     TAG       IMAGE ID       CREATED      SIZE
user-service   latest    9c6a6aca8d0c   2 days ago   407MB
````

## Elimina una imagen (sin especificar tag)

La siguiente instrucción elimina la imagen `user-service`. Como no especificamos una etiqueta en particular, por defecto
elimina el`(TAG)` `latest` que es el tag por defecto. Si la imagen tiene contenedores ejecutándose mostrará mensajes de
error y no podrá eliminarse.

````bash
$ docker image rm user-service
Untagged: user-service:latest
Deleted: sha256:9c6a6aca8d0c7412bf993e849978b3bb8866cf8918b5daf6bedab1b2e138ac82
````

## Elimina una imagen (especificando tag)

La siguiente instrucción elimina la imagen `user-service` con tag `v1`. Si la imagen tiene contenedores ejecutándose
mostrará mensajes de error y no podrá eliminarse.

Primero listamos las imágenes para ver el que eliminaremos.

````bash
$ docker image ls
REPOSITORY     TAG       IMAGE ID       CREATED      SIZE
user-service   v1        00c060ecf18c   2 days ago   407MB
user-service   latest    48b66cc5368c   2 days ago   407MB
````

Ahora sí, eliminamos la imagen `user-service` con tag `v1`.

````bash
$ docker image rm user-service:v1
Untagged: user-service:v1
Deleted: sha256:00c060ecf18c504fd7d30c109e39741df8c341f8f4215520f5527d178d4eda69
````

## Elimina imágenes no utilizadas

Elimina todas las imágenes no usadas o inactivas (dangling images) de Docker. Las imágenes inactivas son imágenes que
no tienen etiquetas y no están asociadas con contenedores en ejecución o detenidos.

````bash
$ docker image prune
````

## Inspecciona imagen

El comando `inspect` muestra información detallada sobre la imagen de Docker. Este comando devuelve
un objeto en formato JSON con una serie de metadatos sobre la imagen, tales como:

- `Id`: El identificador único (ID) de la imagen, representado como un hash.
- `RepoTags`: Las etiquetas de repositorio, como user-service:latest, que identifican la imagen.
- `Created`: La fecha y hora en que la imagen fue creada.
- `ExposedPorts`: Los puertos expuestos en el contenedor, en este caso, 8001/tcp.
- `Env`: Variables de entorno configuradas dentro de la imagen (como la versión de Java).
- `Cmd`: El comando por defecto que se ejecuta cuando el contenedor se inicia (en tu caso, `java`
  `org.springframework.boot.loader.launch.JarLauncher`).
- `Layers`: Una lista de los hashes de las capas de la imagen, que indican cómo se compone la imagen a nivel de sistema
  de archivos.
- `Size`: El tamaño total de la imagen en bytes.
- `GraphDriver`: Información sobre el sistema de almacenamiento utilizado, como overlay2.

Este comando es útil cuando quieres revisar los detalles internos de la imagen, como sus capas, configuración de
puertos, comandos, etc.

````bash
$ docker image inspect user-service
[
    {
        "Id": "sha256:3d6e1ac368580d0d5cae4942c9d5ff8247dedc944a5a17a771293ab1bd0cc944",
        "RepoTags": [
            "user-service:latest"
        ],
        "RepoDigests": [
            "user-service@sha256:3d6e1ac368580d0d5cae4942c9d5ff8247dedc944a5a17a771293ab1bd0cc944"
        ],
        "Parent": "",
        "Comment": "buildkit.dockerfile.v0",
        "Created": "2025-05-23T04:39:46.309349177Z",
        "DockerVersion": "",
        "Author": "",
        "Config": {
            "Hostname": "",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "ExposedPorts": {
                "8001/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/opt/java/openjdk/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "JAVA_HOME=/opt/java/openjdk",
                "LANG=en_US.UTF-8",
                "LANGUAGE=en_US:en",
                "LC_ALL=en_US.UTF-8",
                "JAVA_VERSION=jdk-21.0.7+6"
            ],
            "Cmd": [
                "java",
                "org.springframework.boot.loader.launch.JarLauncher"
            ],
            "ArgsEscaped": true,
            "Image": "",
            "Volumes": null,
            "WorkingDir": "/app",
            "Entrypoint": [
                "/__cacert_entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": null
        },
        "Architecture": "amd64",
        "Os": "linux",
        "Size": 131600847,
        "GraphDriver": {
            "Data": null,
            "Name": "overlayfs"
        },
        "RootFS": {
            "Type": "layers",
            "Layers": [
                "sha256:08000c18d16dadf9553d747a58cf44023423a9ab010aab96cf263d2216b8b350",
                "sha256:343c5fbeb913f2ca566e329bd1a1a82d1fa9bd4cd3b978600a4bd1f393abf2fd",
                "sha256:d34c6dad4fc84c4d92ab906ddd97ab0f39548bc002093c146705faca0740af73",
                "sha256:002d22842e01692f8f3acfd0d4015ef6340f14c694ea05dc0701328025c2ae7e",
                "sha256:5c70c8580947e31e01c006bf2c3c49d02b5a47019a549982c5040151816fe1ce",
                "sha256:9daa96500800074a04730109aa086bd9e7aa754621634efac81d535178c840de",
                "sha256:e4d29b9ba970f0eef832ee9afdf47739185df59c5b75736fe782a77f4d1b1a76",
                "sha256:6faa915d79865c583eead18a64b01851be4e31983a2b245c80789eb951c6dbb4",
                "sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef",
                "sha256:7a9687dadcf9b637da6b91d3d3899505a90add2870c2f3cd6e9793ff807269bc"
            ]
        },
        "Metadata": {
            "LastTagTime": "2025-05-25T18:10:53.432302378Z"
        },
        "Descriptor": {
            "mediaType": "application/vnd.oci.image.index.v1+json",
            "digest": "sha256:3d6e1ac368580d0d5cae4942c9d5ff8247dedc944a5a17a771293ab1bd0cc944",
            "size": 856
        }
    }
]
````

## Etiqueta imagen

Podemos crear una imagen asignándole una etiqueta (`tag`). Si no le asignamos ninguna etiqueta, por defecto tomará el
valor `latest`. Hasta el momento ya tenemos creado la imagen `user-service` con la etiqueta `latest`, que es la
etiqueta por defecto.

````bash
$ ocker image ls
REPOSITORY     TAG       IMAGE ID       CREATED      SIZE
user-service   latest    3d6e1ac36858   2 days ago   407MB
````

Ahora, crearemos una nueva imagen con la etiqueta `v1`.

````bash
$ D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-8)                                                                            
$ docker image build -t user-service:v1 .\business-domain\user-service -f .\business-domain\user-service\Dockerfile                                                                   
[+] Building 1.3s (24/24) FINISHED                                                                                                                                docker:desktop-linux
 => [internal] load build definition from Dockerfile                                                                                                                              0.0s
 => => transferring dockerfile: 776B                                                                                                                                              0.0s
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jre-alpine                                                                                                  1.0s
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                                                                  1.0s
 => [auth] library/eclipse-temurin:pull token for registry-1.docker.io                                                                                                            0.0s
 => [internal] load .dockerignore                                                                                                                                                 0.0s
 => => transferring context: 214B                                                                                                                                                 0.0s
 => [dependencies 1/9] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0                               0.1s
 => => resolve docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0                                            0.0s
 => [internal] load build context                                                                                                                                                 0.0s
 => => transferring context: 2.98kB                                                                                                                                               0.0s
 => [builder 1/4] FROM docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd                                    0.1s
 => => resolve docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd                                            0.0s
 => CACHED [builder 2/4] WORKDIR /app                                                                                                                                             0.0s
 => CACHED [dependencies 2/9] WORKDIR /app                                                                                                                                        0.0s
 => CACHED [dependencies 3/9] COPY ./mvnw ./                                                                                                                                      0.0s
 => CACHED [dependencies 4/9] COPY ./.mvn ./.mvn                                                                                                                                  0.0s
 => CACHED [dependencies 5/9] COPY ./pom.xml ./                                                                                                                                   0.0s
 => CACHED [dependencies 6/9] RUN sed -i -e 's/\r$//' ./mvnw                                                                                                                      0.0s
 => CACHED [dependencies 7/9] RUN ./mvnw dependency:go-offline                                                                                                                    0.0s
 => CACHED [dependencies 8/9] COPY ./src ./src                                                                                                                                    0.0s
 => CACHED [dependencies 9/9] RUN ./mvnw clean package -DskipTests                                                                                                                0.0s
 => CACHED [builder 3/4] COPY --from=dependencies /app/target/*.jar ./app.jar                                                                                                     0.0s
 => CACHED [builder 4/4] RUN java -Djarmode=layertools -jar app.jar extract                                                                                                       0.0s
 => CACHED [runner 3/6] COPY --from=builder /app/dependencies ./                                                                                                                  0.0s
 => CACHED [runner 4/6] COPY --from=builder /app/spring-boot-loader ./                                                                                                            0.0s
 => CACHED [runner 5/6] COPY --from=builder /app/snapshot-dependencies ./                                                                                                         0.0s
 => CACHED [runner 6/6] COPY --from=builder /app/application ./                                                                                                                   0.0s
 => exporting to image                                                                                                                                                            0.1s
 => => exporting layers                                                                                                                                                           0.0s
 => => exporting manifest sha256:f8469b8029893ffb33a7c126ba7bed43af855044a9376ea4e9266c8452399dec                                                                                 0.0s
 => => exporting config sha256:31201a78d21650ee023e12e4e3a977910e595c45687666334f344bf327d0b476                                                                                   0.0s
 => => exporting attestation manifest sha256:1a2abc9aaf817736362547571e12cb99121ec21ff8bf41a1237771e8628d89ed                                                                     0.0s
 => => exporting manifest list sha256:3b3a3c4b45f5c4a24b4d2c0d9f39a15cb3a50b2cb8da6ed4d65581e2c267b637                                                                            0.0s
 => => naming to docker.io/library/user-service:v1                                                                                                                                0.0s
 => => unpacking to docker.io/library/user-service:v1                                                                                                                             0.0s
                                                                                                                                                                                      
View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/xffy50yhagfhtjzzwankr1rii
````

Si listamos las imágenes veremos que ahora tenemos dos versiones, la imagen con etiqueta `latest` y `v1`.

````bash
$ docker image ls
REPOSITORY     TAG       IMAGE ID       CREATED      SIZE
user-service   latest    3d6e1ac36858   2 days ago   407MB
user-service   v1        3b3a3c4b45f5   2 days ago   407MB
````

## Renombra etiqueta de imagen

El comando para renombrar la etiqueta de una imagen en Docker es `docker image tag`. Este comando permite asignar una
nueva etiqueta (o `tag`) a una imagen existente, lo cual es equivalente a renombrarla.

Listamos para verificar las imágenes y etiquetas que tenemos.

````bash
$ docker image ls
REPOSITORY     TAG       IMAGE ID       CREATED      SIZE
user-service   latest    3d6e1ac36858   2 days ago   407MB
user-service   v1        3b3a3c4b45f5   2 days ago   407MB
````

A continuación, asignaremos una nueva etiqueta a la imagen `user-service:latest`, de forma que también esté disponible
como `magadiflo/user-service:v2`.

````bash
$ docker image tag user-service:latest magadiflo/user-service:v2
````

Después de ejecutar el comando anterior, listamos las imágenes para comprobar la existencia de la nueva etiqueta.

````bash
$ docker image ls
REPOSITORY               TAG       IMAGE ID       CREATED      SIZE
user-service             latest    3d6e1ac36858   2 days ago   407MB
magadiflo/user-service   v2        3d6e1ac36858   2 days ago   407MB
user-service             v1        3b3a3c4b45f5   2 days ago   407MB
````

Como se puede observar, no se ha creado una nueva imagen, sino que se ha generado una nueva etiqueta
(`magadiflo/user-service:v2`) que apunta al mismo `ID de imagen` (`3d6e1ac36858`). Es decir, ahora la misma imagen
tiene múltiples nombres o etiquetas asociadas.

---

# Comandos para contenedores

---

## Crea contenedor (attach)

Si ejecutamos el siguiente comando sin la bandera `-d`, la terminal quedará enganchado, es decir veremos la ejecución
del contenedor en primer plano sin tener control de la línea de comando.

````bash
$ docker container run -p 8085:8001 user-service

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.4.5)

2025-05-25T18:44:51.232Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Starting UserServiceApplication v0.0.1-SNAPSHOT using Java 21.0.7 with PID 1 (/app/BOOT-INF/classes started by root in /app) 2025-05-25T18:44:51.235Z DEBUG 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Running with Spring Boot v3.4.5, Spring v6.2.6
2025-05-25T18:44:51.237Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : No active profile set, falling back to 1 default profile: "default"
2025-05-25T18:44:52.469Z  INFO 1 --- [user-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-05-25T18:44:52.554Z  INFO 1 --- [user-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 61 ms. Found 1 JPA repository interface.
2025-05-25T18:44:52.759Z  INFO 1 --- [user-service] [           main] o.s.cloud.context.scope.GenericScope     : BeanFactory id=91540a6b-3294-3658-b380-dfb1c22ae3d2
2025-05-25T18:44:53.531Z  INFO 1 --- [user-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8001 (http)
2025-05-25T18:44:53.552Z  INFO 1 --- [user-service] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2025-05-25T18:44:53.553Z  INFO 1 --- [user-service] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.40]
2025-05-25T18:44:53.602Z  INFO 1 --- [user-service] [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2025-05-25T18:44:53.604Z  INFO 1 --- [user-service] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 2302 ms
2025-05-25T18:44:53.997Z  INFO 1 --- [user-service] [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2025-05-25T18:44:54.056Z  INFO 1 --- [user-service] [           main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 6.6.13.Final
2025-05-25T18:44:54.093Z  INFO 1 --- [user-service] [           main] o.h.c.internal.RegionFactoryInitiator    : HHH000026: Second-level cache disabled
2025-05-25T18:44:54.412Z  INFO 1 --- [user-service] [           main] o.s.o.j.p.SpringPersistenceUnitInfo      : No LoadTimeWeaver setup: ignoring JPA class transformer
2025-05-25T18:44:54.450Z  INFO 1 --- [user-service] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2025-05-25T18:44:54.970Z  INFO 1 --- [user-service] [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@7cbede2b
2025-05-25T18:44:54.973Z  INFO 1 --- [user-service] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2025-05-25T18:44:55.074Z  INFO 1 --- [user-service] [           main] org.hibernate.orm.connections.pooling    : HHH10001005: Database info:
        Database JDBC URL [Connecting through datasource 'HikariDataSource (HikariPool-1)']
        Database driver: undefined/unknown
        Database version: 8.0.41
        Autocommit mode: undefined/unknown
        Isolation level: undefined/unknown
        Minimum pool size: undefined/unknown
        Maximum pool size: undefined/unknown
2025-05-25T18:44:56.089Z  INFO 1 --- [user-service] [           main] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000489: No JTA platform available (set 'hibernate.transaction.jta.platform' to enable JTA platform integration)
2025-05-25T18:44:56.138Z  INFO 1 --- [user-service] [           main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2025-05-25T18:44:56.789Z  WARN 1 --- [user-service] [           main] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2025-05-25T18:44:57.825Z  INFO 1 --- [user-service] [           main] o.s.b.a.e.web.EndpointLinksResolver      : Exposing 1 endpoint beneath base path '/actuator'
2025-05-25T18:44:57.942Z  INFO 1 --- [user-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8001 (http) with context path '/'
2025-05-25T18:44:57.960Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Started UserServiceApplication in 7.276 seconds (process running for 8.065)
````

**Donde**

- `docker container run`, permite corre un nuevo contenedor.
- `-p 8005:8001`, asigna un puerto `externo:interno` al contenedor.
- `user-service`, nombre de la imagen a partir del cual se crea el contenedor. Como no especificamos el tag, por defecto
  usará la imagen con tag `latest`.
- `¿Qué es el modo attach?`, la posesión de la terminal luego de ejecutar el comando.

### Des-atachar deteniendo el contenedor

Si queremos volver a tener el control de la línea de comando debemos presionar `Ctrl + C`, pero esto detendrá el
contenedor, cambiando su status `Up` por `Exited`.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED              STATUS                       PORTS     NAMES
f4d4875b5032   user-service   "/__cacert_entrypoin…"   About a minute ago   Exited (130) 9 seconds ago             brave_antonelli
````

### Des-atachar sin detener el contenedor

Si tu terminal quedó atachada al contenedor después de ejecutar `docker container run`, puedes recuperar el control de
la terminal sin detener el contenedor usando la siguiente combinación de teclas.

````bash
Ctrl + P
Ctrl + Q
````

**Nota**
> A mí no me funcionó la combinación de teclas, pero en la mayoría de las fuentes consultadas mencionan esa combinación.
> Así que para evitar problemas lo mejor será que cuando cree un contenedor agregarle el flag `-d` para que siempre se
> cree `des-atachado`.

## Crea contenedor con el flag -d (detach)

Si ejecutamos un contenedor usando el flag `-d` estaremos ejecutándolo en modo `dettached`, es decir, el contenedor
se ejecutará en segundo plano, sin que la terminal quede `atachada` a él. Esto nos permite seguir usando la terminal
para otros comandos, mientras el contenedor sigue corriendo en segundo plano.

````bash
$ docker container run -d -p 8001:8001 user-service
893ea8741f0050270fcb792e050d9ecf7e7fe13f66002d1bedaa42927b350d8b
````

## Lista todos los contenedores

El siguiente comando se utiliza para listar todos los contenedores en tu sistema, incluyendo tanto los que
están en ejecución como los que han sido detenidos. La opción `-a` significa `all` (todos), y nos muestra el estado
completo de los contenedores, no solo los que están activos.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                    NAMES
893ea8741f00   user-service   "/__cacert_entrypoin…"   4 minutes ago   Up 4 minutes   0.0.0.0:8001->8001/tcp   compassionate_wilson
````

- `docker container ls`: Muestra solo los contenedores que están en ejecución en ese momento.
- `docker container ls -a`: Muestra todos los contenedores, independientemente de si están en ejecución, detenidos
  o en estado creado pero nunca ejecutados.

## Detiene contenedor en ejecución

Con el siguiente comando detenemos uno o más contenedores que están en ejecución. Para eso utilizamos el `CONTAINER_ID`
de los contenedores a detener.

````bash
$ docker container stop 893ea8741f00
893ea8741f00
````

Si listamos los contenedores, vemos que el contenedor ya está detenido (`Exited`).

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS                        PORTS     NAMES
893ea8741f00   user-service   "/__cacert_entrypoin…"   5 minutes ago   Exited (143) 19 seconds ago             compassionate_wilson
````

## Inicia contenedor detenido

Con el siguiente comando iniciamos uno o más contenedores detenidos.

````bash
$ docker container start 893ea8741f00
893ea8741f00
````

Si volvemos a listar los contenedores, vemos que el contenedor con id `893ea8741f00` se volvió a levantar.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS          PORTS                    NAMES
893ea8741f00   user-service   "/__cacert_entrypoin…"   6 minutes ago   Up 17 seconds   0.0.0.0:8001->8001/tcp   compassionate_wilson
````

## Muestra log del contenedor

El siguiente comando permite ver los `logs` de un contenedor en específico en `Docker`. En nuestro caso estamos usando
el `893ea8741f00` como ID del contenedor que deseamos ver sus registros.

Este comando `no toma posesión de la terminal`.

````bash
$ docker container logs 893ea8741f00

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.4.5)

2025-05-25T18:49:14.228Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Starting UserServiceApplication v0.0.1-SNAPSHOT using Java 21.0.7 with PID 1 (/app/BOOT-INF/classes started by root in /app) 2025-05-25T18:49:14.230Z DEBUG 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Running with Spring Boot v3.4.5, Spring v6.2.6
2025-05-25T18:49:14.231Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : No active profile set, falling back to 1 default profile: "default"
2025-05-25T18:49:15.409Z  INFO 1 --- [user-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-05-25T18:49:15.474Z  INFO 1 --- [user-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 54 ms. Found 1 JPA repository interface.
2025-05-25T18:49:15.687Z  INFO 1 --- [user-service] [           main] o.s.cloud.context.scope.GenericScope     : BeanFactory id=91540a6b-3294-3658-b380-dfb1c22ae3d2
2025-05-25T18:49:16.455Z  INFO 1 --- [user-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8001 (http)
2025-05-25T18:49:16.472Z  INFO 1 --- [user-service] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2025-05-25T18:49:16.472Z  INFO 1 --- [user-service] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.40]
2025-05-25T18:49:16.509Z  INFO 1 --- [user-service] [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
...
````

## Muestra log del contenedor en tiempo real (-f o --follow)

Para seguir viendo los `logs` en tiempo real podemos usar el flag `-f` o `--follow`.

⚠️ Importante
> Si luego queremos dejar de dar seguimiento al log, simplemente presionamos `Ctrl + C` para retomar el control de la
> línea de comandos. El contenedor seguirá ejecutándose por debajo, es decir, en este caso el contenedor no se detendrá,
> seguirá ejecutándose.

````bash
$ docker container logs 940bc9dd5ef8 -f

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.4.5)

2025-05-26T00:36:09.474Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Starting UserServiceApplication v0.0.1-SNAPSHOT using Java 21.0.7 with PID 1 (/app/BOOT-INF/classes started by root in /app) 2025-05-26T00:36:09.477Z DEBUG 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Running with Spring Boot v3.4.5, Spring v6.2.6
2025-05-26T00:36:09.478Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : No active profile set, falling back to 1 default profile: "default"
2025-05-26T00:36:10.877Z  INFO 1 --- [user-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-05-26T00:36:10.978Z  INFO 1 --- [user-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 86 ms. Found 1 JPA repository interface.
2025-05-26T00:36:11.216Z  INFO 1 --- [user-service] [           main] o.s.cloud.context.scope.GenericScope     : BeanFactory id=91540a6b-3294-3658-b380-dfb1c22ae3d2
2025-05-26T00:36:12.042Z  INFO 1 --- [user-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8001 (http)
2025-05-26T00:36:12.059Z  INFO 1 --- [user-service] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2025-05-26T00:36:12.059Z  INFO 1 --- [user-service] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.40]
2025-05-26T00:36:12.105Z  INFO 1 --- [user-service] [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2025-05-26T00:36:12.107Z  INFO 1 --- [user-service] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 2546 ms
2025-05-26T00:36:12.489Z  INFO 1 --- [user-service] [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2025-05-26T00:36:12.542Z  INFO 1 --- [user-service] [           main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 6.6.13.Final
2025-05-26T00:36:12.575Z  INFO 1 --- [user-service] [           main] o.h.c.internal.RegionFactoryInitiator    : HHH000026: Second-level cache disabled
2025-05-26T00:36:12.906Z  INFO 1 --- [user-service] [           main] o.s.o.j.p.SpringPersistenceUnitInfo      : No LoadTimeWeaver setup: ignoring JPA class transformer
2025-05-26T00:36:12.939Z  INFO 1 --- [user-service] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2025-05-26T00:36:13.531Z  INFO 1 --- [user-service] [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@706d2bae
2025-05-26T00:36:13.534Z  INFO 1 --- [user-service] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2025-05-26T00:36:13.665Z  INFO 1 --- [user-service] [           main] org.hibernate.orm.connections.pooling    : HHH10001005: Database info:
        Database JDBC URL [Connecting through datasource 'HikariDataSource (HikariPool-1)']
        Database driver: undefined/unknown
        Database version: 8.0.41
        Autocommit mode: undefined/unknown
        Isolation level: undefined/unknown
        Minimum pool size: undefined/unknown
        Maximum pool size: undefined/unknown
2025-05-26T00:36:14.701Z  INFO 1 --- [user-service] [           main] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000489: No JTA platform available (set 'hibernate.transaction.jta.platform' to enable JTA platform integration)
2025-05-26T00:36:14.755Z  INFO 1 --- [user-service] [           main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2025-05-26T00:36:15.440Z  WARN 1 --- [user-service] [           main] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2025-05-26T00:36:16.338Z  INFO 1 --- [user-service] [           main] o.s.b.a.e.web.EndpointLinksResolver      : Exposing 1 endpoint beneath base path '/actuator'
2025-05-26T00:36:16.426Z  INFO 1 --- [user-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8001 (http) with context path '/'
2025-05-26T00:36:16.446Z  INFO 1 --- [user-service] [           main] d.m.user.app.UserServiceApplication      : Started UserServiceApplication in 7.51 seconds (process running for 8.129)
2025-05-26T00:37:50.344Z  INFO 1 --- [user-service] [nio-8001-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2025-05-26T00:37:50.345Z  INFO 1 --- [user-service] [nio-8001-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2025-05-26T00:37:50.348Z  INFO 1 --- [user-service] [nio-8001-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 2 ms
2025-05-26T00:38:25.149Z DEBUG 1 --- [user-service] [nio-8001-exec-3] org.hibernate.SQL                        :
    select
        u1_0.id,
        u1_0.email,
        u1_0.name,
        u1_0.password
    from
        users u1_0
    where
        u1_0.id=?
````

## Elimina contenedor que está detenido (Exited)

````bash
$ docker container rm 940bc9dd5ef8
````

## Fuerza la eliminación de un contenedor que está siendo ejecutado (Up)

````bash
$ docker container rm -f 940bc9dd5ef8
````

## Elimina todos los contenedores detenidos (Exited)

Este comando eliminará solo los contenedores detenidos `Exited`, no eliminará los contenedores con status `Up`.

````bash
$ docker container prune
WARNING! This will remove all stopped containers.
Are you sure you want to continue? [y/N] y
Total reclaimed space: 0B
````

## Elimina automáticamente el contenedor cuando se detenga (--rm)

Con el siguiente comando creamos un contendor. Ahora, como le hemos agregado el flag `--rm`, esta opción indica que
Docker debe eliminar automáticamente el contenedor cuando se detenga. Esto es útil para evitar que queden contenedores
detenidos que no se utilizarán, manteniendo así el sistema más limpio.

````bash
$ docker container run -d -p 9002:8001 --rm user-service
ad9821a9aac5a5b5a8f2ace77bcc14accf3be37bcda89bec58dc0227d9d60491
````

Al listar los contenedores vemos que el que acabamos de levantar está en status `Up`.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                    NAMES
ad9821a9aac5   user-service   "/__cacert_entrypoin…"   12 seconds ago   Up 12 seconds   0.0.0.0:9002->8001/tcp   gifted_sanderson
940bc9dd5ef8   user-service   "/__cacert_entrypoin…"   11 minutes ago   Up 11 minutes   0.0.0.0:8001->8001/tcp   xenodochial_kilby
````

Ahora procedemos a detener el contenedor creado anteriormente.

````bash
$ docker container stop ad9821a9aac5
ad9821a9aac5
````

Al volver a listar los contenedores vemos que el contenedor creado anteriormente fue eliminado automáticamente.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                    NAMES
940bc9dd5ef8   user-service   "/__cacert_entrypoin…"   12 minutes ago   Up 12 minutes   0.0.0.0:8001->8001/tcp   xenodochial_kilby
````

## Ingresa en modo interactivo en contenedor en ejecución (exec -it)

El siguiente comando se utiliza para ejecutar un nuevo proceso dentro de un contenedor que ya está en ejecución.
Vamos a desglosar cada parte del comando para entender su funcionalidad:

````bash
$ docker container exec -it 940bc9dd5ef8 /bin/sh
/app # ls
BOOT-INF  META-INF  org
/app # cd ..
/ # ls -l
total 72
-rwxr-xr-x   1 root root 5307 Apr 23 16:31 __cacert_entrypoint.sh
drwxr-xr-x   1 root root 4096 May 23 04:39 app
drwxr-xr-x   1 root root 4096 Apr 23 16:31 bin
drwxr-xr-x   5 root root  340 May 26 00:36 dev
drwxr-xr-x   1 root root 4096 May 26 00:36 etc
drwxr-xr-x   2 root root 4096 Feb 13 23:04 home
drwxr-xr-x   1 root root 4096 Feb 13 23:04 lib
drwxr-xr-x   5 root root 4096 Feb 13 23:04 media
drwxr-xr-x   2 root root 4096 Feb 13 23:04 mnt
drwxr-xr-x   1 root root 4096 Apr 23 16:31 opt
dr-xr-xr-x 246 root root    0 May 26 00:36 proc
drwx------   1 root root 4096 May 26 00:50 root
drwxr-xr-x   3 root root 4096 Feb 13 23:04 run
drwxr-xr-x   2 root root 4096 Feb 13 23:04 sbin
drwxr-xr-x   2 root root 4096 Feb 13 23:04 srv
dr-xr-xr-x  11 root root    0 May 26 00:36 sys
drwxrwxrwt   1 root root 4096 May 26 00:36 tmp
drwxr-xr-x   1 root root 4096 Apr 23 16:31 usr
drwxr-xr-x   1 root root 4096 Feb 13 23:04 var
/ #
````

**Donde**

- `exec`, ejecuta un comando en un contenedor que ya está en funcionamiento.
- `-it`, esta opción combina dos banderas:
    - `-i` (interactivo): Mantiene la entrada estándar (STDIN) abierta, permitiendo que interactúes con el proceso que
      estás ejecutando en el contenedor.
    - `-t` (terminal): Asigna un pseudo-terminal, lo que permite que la salida del comando se formatee correctamente,
      proporcionando una experiencia similar a la de un terminal normal.
- `/bin/sh`, este es el comando que se ejecutará dentro del contenedor. En este caso, estás iniciando un shell de
  comandos `(sh)`. Esto te permitirá interactuar con el sistema de archivos del contenedor y ejecutar otros comandos
  dentro de él.

Como se observa en el resultado anterior, pudimos ingresar dentro del contenedor en ejecución y lo primero que hice fue
listar el contenido del directorio actual `/app`. Recordemos que dicho directorio es el que definimos en el `WORKDIR`
del `Dockerfile` y en el que extraímos como resultado final el contenido de nuestro `jar`.

## Ingresar en modo interactivo al iniciar la creación de un nuevo contenedor

En este caso vamos a crear un nuevo contenedor, pero vamos a ingresar directamente a él para inspeccionar su contenido
(`-it`) y cuando salgamos de él con el comando `exit`, el contenedor se borrará automáticamente:

````bash
$  docker container run -p 9001:8001 --rm -it user-service /bin/sh
/app # ls
BOOT-INF  META-INF  org
/app #
````

Si abrimos otro terminal, veremos que el contenedor está con status `Up`.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                    NAMES
0f4e80bea695   user-service   "/__cacert_entrypoin…"   38 seconds ago   Up 37 seconds   0.0.0.0:9001->8001/tcp   cool_chebyshev
940bc9dd5ef8   user-service   "/__cacert_entrypoin…"   20 minutes ago   Up 20 minutes   0.0.0.0:8001->8001/tcp   xenodochial_kilby
````

Ahora, si escribimos el comando `exit` para salir, veremos que el contenedor se eliminará automáticamente (`--rm`).

````bash
$ docker container run -p 9001:8001 --rm -it user-service /bin/sh
/app # ls
BOOT-INF  META-INF  org
/app # exit
````

Comprobamos que el contenedor se eliminó automáticamente.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                    NAMES
940bc9dd5ef8   user-service   "/__cacert_entrypoin…"   21 minutes ago   Up 21 minutes   0.0.0.0:8001->8001/tcp   xenodochial_kilby
````

✅ En resumen
> Hemos creado un nuevo contenedor agregando el comando `--rm` para que cuando nos salgamos del contendor
> escribiendo `exit`, éste se elimine automáticamente. También hemos agregado el comando `-it` para utilizar el
> `terminal interactivo` del contenedor, luego el nombre de la imagen y finalmente la instrucción `/bin/sh`.

## Copia archivos

### Desde Máquina Local hacia Contenedor

Podemos copiar archivos que están en nuestra máquina local hacia dentro de un **contenedor que está en ejecución**.
Par eso, crearemos un contenedor con el siguiente comando.

````bash
$ docker container run -p 9001:8001 --rm -it user-service /bin/sh
/app # ls
BOOT-INF  META-INF  org
/app #
````

Ahora, nos posicionaremos con la terminal en el directorio donde está el archivo que queremos copiar. En nuestro caso
será el archivo `Lec04WindowAssignment.java`.

````bash
D:\
$ ls -l
total 16
drwxr-xr-x 1 magadiflo 197121    0 Apr  1 22:05 '$RECYCLE.BIN'/
drwxr-xr-x 1 magadiflo 197121    0 Apr  3 16:29  formalities/
drwxr-xr-x 1 magadiflo 197121    0 Apr  3 16:06  installers/
drwxr-xr-x 1 magadiflo 197121    0 Apr  4 09:51  job_history/
-rw-r--r-- 1 magadiflo 197121 2104 May 25 20:10  Lec04WindowAssignment.java
drwxr-xr-x 1 magadiflo 197121    0 Apr  4 09:49  programming/
drwxr-xr-x 1 magadiflo 197121    0 Apr  1 22:58 'System Volume Information'/
````

Antes de copiar el archivo, necesitamos averiguar el identificador o el nombre del contenedor.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                    NAMES
28f23de065f1   user-service   "/__cacert_entrypoin…"   2 minutes ago    Up 2 minutes    0.0.0.0:9001->8001/tcp   compassionate_dhawan
940bc9dd5ef8   user-service   "/__cacert_entrypoin…"   36 minutes ago   Up 36 minutes   0.0.0.0:8001->8001/tcp   xenodochial_kilby
````

Ahora, usando el comando `cp` copiamos el archivo `Lec04WindowAssignment.java` hacia un directorio dentro del
contenedor. En nuestro caso lo copiaremos en nuestro directorio `/app`. Notar que estamos usando el identificador del
contenedor (`28f23de065f1`) a donde copiaremos el archivo.

````bash
D:\
$ docker container cp .\Lec04WindowAssignment.java 28f23de065f1:/app
Successfully copied 4.1kB to 28f23de065f1:/app
````

**Donde**

- `cp`, copia `archivos/carpetas` entre el sistema de archivos local y un contenedor.
- `.\Lec04WindowAssignment.java 28f23de065f1:/app`, el archivo `Lec04WindowAssignment.java` que será copiado en el
  contenedor con ID `28f23de065f1` y dentro del contenedor se copiará en el WORKDIR `/app`.

Luego de haber copiado, listamos el directorio `/app` para ver que el archivo fue copiado correctamente, incluso
podemos ver el contenido de dicho archivo.

````bash
$ docker container run -p 9001:8001 --rm -it user-service /bin/sh
/app # ls
BOOT-INF  META-INF  org
/app # ls
BOOT-INF  Lec04WindowAssignment.java  META-INF  org
/app # cat Lec04WindowAssignment.java
package dev.magadiflo.app.sec10;

import dev.magadiflo.app.common.Util;
import dev.magadiflo.app.sec10.assignment.window.FileWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.nio.file.Path;
import java.time.Duration;

public class Lec04WindowAssignment {

    private static final Logger log = LoggerFactory.getLogger(Lec04WindowAssignment.class);
    private static final String PATH = "src/main/resources/sec10/";

    public static void main(String[] args) {
        cleanDirectory()
                .thenMany(eventStream())
                .window(Duration.ofMillis(1800))
                .zipWith(sequential())
                .flatMap(tuple -> {
                    Flux<String> window = tuple.getT1();
                    Integer count = tuple.getT2();
                    return processEvents(window, count);
                })
                .subscribe();

        Util.sleepSeconds(60);
    }

    private static Mono<Void> cleanDirectory() {
        return Mono.fromRunnable(() -> {
            FileWriter.cleanDirectory(Path.of(PATH));
        });
    }

    private static Flux<Integer> sequential() {
        return Flux.generate(
                () -> 1,
                (count, synchronousSink) -> {
                    synchronousSink.next(count);
                    return count + 1;
                }
        );
    }

    private static Flux<String> eventStream() {
        return Flux.interval(Duration.ofMillis(500))
                .map(value -> "evento-" + (value + 1));
    }

    private static Mono<Void> processEvents(Flux<String> flux, int count) {
        String fileName = "log-" + count + ".txt";
        Path path = Path.of(PATH + fileName);
        return flux
                .doFirst(() -> FileWriter.createFile(path))
                .doOnNext(value -> FileWriter.writeFile(path, value))
                .doOnComplete(() -> log.info("Fin de escritura {}\n", fileName))
                .then();
    }
}
/app #
````

### Desde Contenedor hacia Máquina Local

En este apartado copiaremos un archivo o directorio de nuestro contenedor hacia nuestra máquina local. Para eso
creamos un nuevo contenedor en modo interactivo y de eliminación automática.

En este contenedor creamos un directorio `/test` y dentro de él un archivo `my_custom_file.txt`.

````bash
$ docker container run -p 9001:8001 --rm -it user-service /bin/sh
/app # ls
BOOT-INF  META-INF  org
/app # mkdir test
/app # ls
BOOT-INF  META-INF  org  test
/app # cd test/
/app/test # ls
/app/test # echo "Archivo creado desde dentro del contenedor" > my_custom_file.txt
/app/test # ls
my_custom_file.txt
/app/test # cat my_custom_file.txt
Archivo creado desde dentro del contenedor
/app/test #
````

Averiguamos cuál es el identificador del contenedor del cual copiaremos su archivo.

````bash
docker container ls -a
CONTAINER ID   IMAGE          COMMAND                  CREATED              STATUS              PORTS                    NAMES
392b32602454   user-service   "/__cacert_entrypoin…"   About a minute ago   Up About a minute   0.0.0.0:9001->8001/tcp   adoring_engelbart
940bc9dd5ef8   user-service   "/__cacert_entrypoin…"   44 minutes ago       Up 44 minutes       0.0.0.0:8001->8001/tcp   xenodochial_kilby
````

Ahora, usando el comando `cp`, copiamos el directorio `/test` de nuestro contenedor hacia una dirección en nuestra
máquina local.

````bash
$ docker container cp 392b32602454:/app/test D:\
Successfully copied 2.56kB to D:\
````

**Donde**

- `392b32602454`, ID del contenedor de donde copiaremos.
- `/app/test`, directorio que copiaremos del contenedor hacia nuestra máquina local.
- `D:\`, ruta de destino en nuestra máquina local.

> 📌`Nota`, si estamos ubicados mediante la línea de comandos en el directorio `D:\` y es a esa ruta a donde
> queremos copiar el contenido, podríamos usar el `.` (contexto actual) en vez de la ruta `D:\`.

Verificamos que efectivamente, el copiado fue exitoso.

````bash
D:\test
$ ls -l
total 1
-rw-r--r-- 1 magadiflo 197121 43 May 25 20:19 my_custom_file.txt

D:\test
$ cat my_custom_file.txt
Archivo creado desde dentro del contenedor
````
