# Sección 05: RestClient: Comunicación entre microservicios

> En esta sección el autor trabaja con `HTTP Feign Client`, pero en mi caso optaré por trabajar con el nuevo cliente
> rest proporcionado por `Spring Boot 3.2`, el `RestClient`.
---

## Introducción: Conectando microservicios

En esta sección veremos cómo relacionar nuestros dos microservicios `user-service` y `course-service`. Luego,
agregaremos funcionalidades en ambos microservicios que nos ayudarán a establecer la comunicación.

En la siguiente imagen vemos un panorama general de lo que realizaremos en esta sección:

![01.png](assets/section-05/01.png)

## Creando JPA Entity CourseUser

Hasta este punto tenemos creado nuestros dos microservicios `course-service` y `user-service`, cada uno manejando su
propia base de datos.

![02.png](assets/section-05/02.png)

Ahora, dejemos a un lado solo por este momento el tema de microservicios y enfoquémonos en la regla de negocio que
trabajaremos en este proyecto:

> Un `usuario` o `alumno` podrá estar en un único `curso` y en un `curso` podrán estar muchos `usuarios` o
> `alumnos`. Imaginemos que `cursos` son por ejemplo cursos de deporte donde tú como alumno puedes elegir estar solo
> en uno de ellos, puedes elegir fútbol o voley o basket o natación, etc., pero solo uno de ellos.
>
> Lo que se quiere lograr es una relación de `One-To-Many`, podríamos haber tomado cualquier otro ejemplo como
> Categoría y Productos y haber realizado todo el proyecto en base a esas entidades, pero bueno, el tutor eligió
> cursos y usuarios para trabajar en todo este proyecto.

Por lo tanto, teniendo nuestra regla de negocio definida, nuestro diagrama `ER de Base de Datos` quedaría de esta
manera:

![03.png](assets/section-05/03.png)

Ahora, la pregunta es **¿cómo llevamos esa relación a los microservicios, si cada microservicio tiene propia base de
datos independiente?**

Lo que podemos hacer es crear una tabla, en una de las bases de datos, que tenga la función de ser un `espejo` de la
tabla de la otra base de datos y donde solo almacene los identificadores, ya que la información completa la tiene la
otra base de datos.

Y ahora, la siguiente pregunta sería **¿en qué base de datos creamos la nueva tabla que hará de "espejo" de la otra
tabla?**.

Analizando la pregunta anterior, llegamos a la conclusión de que la nueva tabla, a la que llamaremos por cierto
`course_users`, debería estar en el microservicio de `course-service` ya que de por sí, un curso necesariamente
requiere usuarios que estén registrados en él para que tenga sentido su razón de existencia, por lo tanto, llevaremos
ese control en dicho microservicio.

![04.png](assets/section-05/04.png)

Para finalizar la idea anterior, la tabla `course_users` sería como si colocáramos la tabla `users` dentro del
microservicio `course-service` en su reemplazo, pero aquí únicamente contendrá la `id` de la tabla `users` a través del
atributo `user_id`, es decir, el `user_id` sería como la `id` de la tabla `users`. Ahora, con respecto al atributo
`course_id`, como estamos en el microservicio `course-service` aquí sí se convierte en un `FK` explícito que apunta a
la tabla `courses`. Finalmente, con respecto al `id` de la tabla `course_users`, solo nos sirve como clave primaria de
la tabla, para nada más. Aquí los dos atributos importantes son `course_id` y el `user_id`.

Listo, una vez habiendo explicado el funcionamiento de la tabla `course_users`, llega el momento de crear la entidad
correspondiente y establecer la relación.

A continuación creamos la entidad `CourseUser` correspondiente a la tabla `course_users` donde debemos observar varios
aspectos importantes:

1. Definimos la propiedad `userId` correspondiente al campo `user_id` que representa conceptualmente la `Primary Key`
   de la tabla `users` en la tabla `course_users`, es decir, es como si `course_users` fuera la tabla `users`. ¡Ojo!
   estoy diciendo que **representa conceptualmente**, es decir, estamos diciendo a qué hace referencia ese atributo.
   Además, estamos diciendo que dicha propiedad es única para evitar que un usuario pueda estar en varios cursos.


2. Sobreescribimos el método `equals()` para decirle a hibernate que cuando se compare una entidad del
   tipo `CourseUser` lo haga a través de la propiedad `userId`. También sobreescribiremos el método `hashCode()` para
   evitar comportamientos inesperados.

### Relación entre equals() y hashCode()

La regla general es que si sobrescribes `equals()`, también debes sobrescribir `hashCode()`, y ambos deben mantener la
siguiente relación:

- Si dos objetos son iguales según el método `equals()`, deben tener el mismo valor de `hashCode()`.
- Si dos objetos tienen el mismo valor de `hashCode()`, no necesariamente son iguales según `equals()`.

Esto garantiza que las colecciones que utilizan hash funcionen de manera correcta. Si no sobrescribes ambos métodos de
manera coherente, podrías tener comportamientos inesperados cuando usas objetos en colecciones como `HashMap` o
`HashSet`.

Si solo sobrescribes el método `equals()` y no sobrescribes el método `hashCode()`, puedes encontrarte con
comportamientos inesperados, especialmente cuando uses tu objeto en colecciones basadas en hash, como `HashMap`,
`HashSet` o `HashTable`. Esto sucede porque estas colecciones dependen tanto de `equals()` como de `hashCode()` para
gestionar la inserción y búsqueda de objetos de manera eficiente.

A continuación se muestra cómo quedaría la entidad `CourseUser`.

````java

@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
@Entity
@Table(name = "course_users")
public class CourseUser {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true)
    private Long userId;

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        CourseUser that = (CourseUser) o;
        return Objects.equals(userId, that.userId);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(userId);
    }
}
````

## Crea relación unidireccional entre Course y CourseUser

En la entidad `Course` establecemos la `relación unidireccional` `@OneToMany` con la entidad `CourseUser`.

````java

@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
@Entity
@Table(name = "courses")
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String name;

    @JoinColumn(name = "course_id")
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    private List<CourseUser> courseUsers = new ArrayList<>();
}
````

Si ejecutamos la aplicación, veremos que la tabla y la relación se crean sin ningún problema.

![05.png](assets/section-05/05.png)
