# Sección 05: RestClient: Comunicación entre microservicios

> En esta sección el autor trabaja con `HTTP Feign Client`, pero en mi caso optaré por trabajar con el nuevo cliente
> rest proporcionado por `Spring Boot 3.2`, el `RestClient`.
---

## Introducción: Conectando microservicios

En esta sección veremos cómo relacionar nuestros dos microservicios `user-service` y `course-service`. Luego,
agregaremos funcionalidades en ambos microservicios que nos ayudarán a establecer la comunicación.

En la siguiente imagen vemos un panorama general de lo que realizaremos en esta sección:

![01.png](assets/section-05/01.png)

## Creando JPA Entity CourseUser

Hasta este punto tenemos creado nuestros dos microservicios `course-service` y `user-service`, cada uno manejando su
propia base de datos.

![02.png](assets/section-05/02.png)

Ahora, dejemos a un lado solo por este momento el tema de microservicios y enfoquémonos en la regla de negocio que
trabajaremos en este proyecto:

> Un `usuario` o `alumno` podrá estar en un único `curso` y en un `curso` podrán estar muchos `usuarios` o
> `alumnos`. Imaginemos que `cursos` son por ejemplo cursos de deporte donde tú como alumno puedes elegir estar solo
> en uno de ellos, puedes elegir fútbol o voley o basket o natación, etc., pero solo uno de ellos.
>
> Lo que se quiere lograr es una relación de `One-To-Many`, podríamos haber tomado cualquier otro ejemplo como
> Categoría y Productos y haber realizado todo el proyecto en base a esas entidades, pero bueno, el tutor eligió
> cursos y usuarios para trabajar en todo este proyecto.

Por lo tanto, teniendo nuestra regla de negocio definida, nuestro diagrama `ER de Base de Datos` quedaría de esta
manera:

![03.png](assets/section-05/03.png)

Ahora, la pregunta es **¿cómo llevamos esa relación a los microservicios, si cada microservicio tiene propia base de
datos independiente?**

Lo que podemos hacer es crear una tabla, en una de las bases de datos, que tenga la función de ser un `espejo` de la
tabla de la otra base de datos y donde solo almacene los identificadores, ya que la información completa la tiene la
otra base de datos.

Y ahora, la siguiente pregunta sería **¿en qué base de datos creamos la nueva tabla que hará de "espejo" de la otra
tabla?**.

Analizando la pregunta anterior, llegamos a la conclusión de que la nueva tabla, a la que llamaremos por cierto
`course_users`, debería estar en el microservicio de `course-service` ya que de por sí, un curso necesariamente
requiere usuarios que estén registrados en él para que tenga sentido su razón de existencia, por lo tanto, llevaremos
ese control en dicho microservicio.

![04.png](assets/section-05/04.png)

Para finalizar la idea anterior, la tabla `course_users` sería como si colocáramos la tabla `users` dentro del
microservicio `course-service` en su reemplazo, pero aquí únicamente contendrá la `id` de la tabla `users` a través del
atributo `user_id`, es decir, el `user_id` sería como la `id` de la tabla `users`. Ahora, con respecto al atributo
`course_id`, como estamos en el microservicio `course-service` aquí sí se convierte en un `FK` explícito que apunta a
la tabla `courses`. Finalmente, con respecto al `id` de la tabla `course_users`, solo nos sirve como clave primaria de
la tabla, para nada más. Aquí los dos atributos importantes son `course_id` y el `user_id`.

Listo, una vez habiendo explicado el funcionamiento de la tabla `course_users`, llega el momento de crear la entidad
correspondiente y establecer la relación.

A continuación creamos la entidad `CourseUser` correspondiente a la tabla `course_users` donde debemos observar varios
aspectos importantes:

1. Definimos la propiedad `userId` correspondiente al campo `user_id` que representa conceptualmente la `Primary Key`
   de la tabla `users` en la tabla `course_users`, es decir, es como si `course_users` fuera la tabla `users`. ¡Ojo!
   estoy diciendo que **representa conceptualmente**, es decir, estamos diciendo a qué hace referencia ese atributo.
   Además, estamos diciendo que dicha propiedad es única para evitar que un usuario pueda estar en varios cursos.


2. Sobreescribimos el método `equals()` para decirle a hibernate que cuando se compare una entidad del
   tipo `CourseUser` lo haga a través de la propiedad `userId`. También sobreescribiremos el método `hashCode()` para
   evitar comportamientos inesperados.

### Relación entre equals() y hashCode()

La regla general es que si sobrescribes `equals()`, también debes sobrescribir `hashCode()`, y ambos deben mantener la
siguiente relación:

- Si dos objetos son iguales según el método `equals()`, deben tener el mismo valor de `hashCode()`.
- Si dos objetos tienen el mismo valor de `hashCode()`, no necesariamente son iguales según `equals()`.

Esto garantiza que las colecciones que utilizan hash funcionen de manera correcta. Si no sobrescribes ambos métodos de
manera coherente, podrías tener comportamientos inesperados cuando usas objetos en colecciones como `HashMap` o
`HashSet`.

Si solo sobrescribes el método `equals()` y no sobrescribes el método `hashCode()`, puedes encontrarte con
comportamientos inesperados, especialmente cuando uses tu objeto en colecciones basadas en hash, como `HashMap`,
`HashSet` o `HashTable`. Esto sucede porque estas colecciones dependen tanto de `equals()` como de `hashCode()` para
gestionar la inserción y búsqueda de objetos de manera eficiente.

A continuación se muestra cómo quedaría la entidad `CourseUser`.

````java

@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
@Entity
@Table(name = "course_users")
public class CourseUser {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true)
    private Long userId;

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        CourseUser that = (CourseUser) o;
        return Objects.equals(userId, that.userId);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(userId);
    }
}
````

## Crea relación unidireccional entre Course y CourseUser

En la entidad `Course` establecemos la `relación unidireccional` `@OneToMany` con la entidad `CourseUser`.

````java

@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
@Entity
@Table(name = "courses")
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String name;

    @JoinColumn(name = "course_id")
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    private List<CourseUser> courseUsers = new ArrayList<>();
}
````

Si ejecutamos la aplicación, veremos que la tabla y la relación se crean sin ningún problema.

![05.png](assets/section-05/05.png)

## Crea DTOs de usuario: UserRequest y UserResponse

Hasta este punto, en la base de datos del microservicio `course-service` tenemos dos tablas relacionadas: `courses` y
`course_users`. Desde la entidad `Course`, podemos acceder a los registros asociados en `course_users`, ya que la
relación está definida en esa dirección. Sin embargo, en cada registro de `CourseUser` solo se almacena el
identificador del usuario (`user_id`), sin información adicional.

Para obtener los datos completos del usuario a partir de su identificador, es necesario realizar una llamada `HTTP` al
microservicio `user-service` utilizando `RestClient`. En este contexto, necesitamos crear una clase `DTO` llamada
`UserResponse`, que representará la estructura de datos retornados por el `user-service`.

De esta manera, por ejemplo, cuando se solicite la lista de usuarios registrados en un curso, el DTO `UserResponse` nos
permitirá mapear correctamente la información devuelta por el `user-service`, y así incluirla como parte de la
respuesta en algún endpoint del `course-service`.

````java
public record UserResponse(Long id,
                           String name,
                           String email,
                           String password) {
}
````

Ahora, cuando mostremos información de un curso, también mostraremos información de los usuarios que están registrados
en dicho curso. En ese sentido, vamos a modificar el `CourseResponse` que habíamos creado en la `sección 03` para
incluir en la respuesta la lista de usuarios registrados al curso.

````java
public record CourseResponse(Long id,
                             String name,
                             @JsonInclude(JsonInclude.Include.NON_NULL)
                             List<UserResponse> users) {
}
````

Nuestro `course-service` tendrá la opción de poder registrar usuarios; esto por debajo se comunicará con el
`user-service` para realizar esa funcionalidad. En ese sentido, necesitamos crear un dto para mapear la
información del usuario enviado por el cliente. Este dto lo usaremos más adelante.

````java
public record UserRequest(@NotBlank
                          String name,
                          @NotBlank
                          @Email
                          String email,
                          @NotBlank
                          String password) {
}
````

Notar que en el dto anterior estamos agregando anotaciones de validación, aunque el `user-service` ya tiene
implementado las validaciones, podría ser una opción válida que el `course-service` realice validaciones antes de
enviar los datos al `user-service`, de esta manera se puede detectar errores antes de enviar los datos a
`user-service`. Esto evita peticiones innecesarias y mejora el rendimiento al prevenir llamadas HTTP que de todas
formas fallarían por errores de validación. La otra opción sería dejar que el `user-service` haga las validaciones, en
ese sentido, el `course-service` solo actuaría como un pasador de datos sin validar. La ventaja de esta última opción
es que estaríamos centralizando la lógica de validación en el `user-service`, lo que haría que sea más fácil de
mantener. Solo tendrías que gestionar las validaciones en un solo lugar.

En resumen, validar en ambos servicios puede ser útil para mejorar la eficiencia, pero en algunos casos podría ser
suficiente realizar una validación básica en el `course-service` y dejar la validación principal al `user-service`.

## RestClient en course-service

Antes de implementar endpoints adicionales para la comunicación entre nuestros dos microservicios vamos a configurar
nuestro cliente `HTTP`. Para este proyecto se seleccionó  `RestClient`, pero también hay otros clientes http que
podríamos haber utilizado en nuestro proyecto de `Spring Boot`, tales como: `WebClient`, `Feign Client` o
`RestTemplate`.

Como primer paso, crearemos una clase de configuración que define un `RestClient` preconfigurado con una URL
parametrizada obtenida desde el archivo `application.yml`.

Este cliente HTTP estará disponible como un bean y podrá ser inyectado directamente en cualquier componente que lo
necesite.

````java

@Configuration
public class RestClientConfig {

    @Value("${custom.user-service.base-url}")
    private String userServiceBaseUrl;

    @Bean
    public RestClient userServiceRestClient() {
        return RestClient.builder()
                .baseUrl(this.userServiceBaseUrl)
                .build();
    }
}
````

A continuación se muestra la configuración agregada al `application.yml` del `course-service`; esta configuración la
estamos inyectando en la clase de configuración anterior.

````yml
custom:
  user-service:
    base-url: http://localhost:8001/api/v1/users
````

## Crea repositorio para CourseUser

Recordemos que en este microservicio `course-service` hemos creado la entidad `CourseUser` que nos está permitiendo
manejar la relación con los usuarios. Más adelante, veremos que es necesario tener un repositorio que nos permita
interactuar con esta entidad. Por ejemplo, necesitaremos crear el siguiente método `deleteByUserId(Long userId)` para
poder eliminar la relación del usuario con el curso.

````java
public interface CourseUserRepository extends JpaRepository<CourseUser, Long> {
    void deleteByUserId(Long userId);
}
````

## Agrega clases adicionales para la implementación del servicio

Antes de crear los métodos de comunicación en nuestros servicios, vamos a crear la interfaz de mapeo entre la entidad
`CourseUser` y el dto `UserResponse`.

````java

@Mapper(componentModel = MappingConstants.ComponentModel.SPRING)
public interface CourseUserMapper {
    @Mapping(target = "id", ignore = true)
    @Mapping(source = "id", target = "userId")
    CourseUser toCourseUser(UserResponse userResponse);
}
````

Además, necesitamos crear una clase personalizada que nos permita particularizar el mensaje de error cuando se busca
un usuario en el `user-service` y el servicio nos retorne un `404` o cuando nos retorne un `status` distinto.

````java
public class RemoteUserNotFoundException extends RuntimeException {
    public RemoteUserNotFoundException(Long userId) {
        super("El usuario con id %d no fue encontrado en el user-service.".formatted(userId));
    }
}
````

Si la excepción lanzada no es el `404` entonces lanzamos esta excepción.

````java
public class CommunicationException extends RuntimeException {
    public CommunicationException(String message) {
        super("Se produjo un error en el user-service: %s".formatted(message));
    }
}
````

Manejamos las excepciones anteriores en la clase `GlobalExceptionHandler`.

````java

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {
    /* other code */
    @ExceptionHandler(RemoteUserNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleRemoteUserNotFoundException(RemoteUserNotFoundException exception, HttpServletRequest request) {
        log.error("Usuario no encontrado en el user-service: {}", exception.getMessage());
        ErrorResponse errorResponse = new ErrorResponse(
                HttpStatus.NOT_FOUND.value(),
                HttpStatus.NOT_FOUND.getReasonPhrase(),
                exception.getMessage(),
                request.getRequestURI(),
                null
        );
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
    }

    @ExceptionHandler(CommunicationException.class)
    public ResponseEntity<ErrorResponse> handleCommunicationException(CommunicationException exception, HttpServletRequest request) {
        log.error("Error en la comunicación con el user-service: {}", exception.getMessage());
        ErrorResponse errorResponse = new ErrorResponse(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(),
                exception.getMessage(),
                request.getRequestURI(),
                null
        );
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
    }
    /* other code */
}
````
