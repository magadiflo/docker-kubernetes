# Sección 02: Microservicio Usuarios

---

## Creando microservicio usuarios con spring boot y cloud

### Dependencias

Iniciamos mostrando las dependencias que serán utilizadas en el `user-service`. La única dependencia que agregamos
manualmente fue `MapStruct`, las demás dependencias las agregamos desde
[Spring Initializr (ver dependencias)](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.4.5&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=user-service&name=user-service&description=Demo%20project%20for%20Spring%20Boot&packageName=dev.magadiflo.user.app&dependencies=web,validation,data-jpa,mysql,lombok,actuator,cloud-starter).

````xml

<!--Spring Boot 3.4.5-->
<!--Spring Cloud 2024.0.1-->
<!--Java 21-->
<!--org.mapstruct.version 1.6.3-->
<!--lombok-mapstruct-binding.version 0.2.0-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter</artifactId>
    </dependency>
    <!--Agregado manualmente-->
    <dependency>
        <groupId>org.mapstruct</groupId>
        <artifactId>mapstruct</artifactId>
        <version>${org.mapstruct.version}</version>
    </dependency>
    <!--/Agregado manualmente-->

    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

### Procesadores de anotaciones

**Referencias**

- [Using MapStruct with Maven and Lombok.](https://bootify.io/spring-data/mapstruct-with-maven-and-lombok.html)
- [Using MapStruct With Lombok](https://www.baeldung.com/java-mapstruct-lombok)

Como vamos a trabajar con `MapStruct` necesitamos ampliar el `maven-compiler-plugin` para activar la generación de
código de `MapStruct`. Observar que nuestro primer procesador de anotaciones es `Lombok`, seguido directamente por
`MapStruct`. Se requiere otra referencia a `lombok-mapstruct-binding` para que estas dos bibliotecas funcionen juntas.
Sin `Lombok`, solo se necesitaría el `mapstruct-processor` en este momento.

````xml

<plugins>
    <!--MapStruct-->
    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>${maven-compiler-plugin.version}</version>
        <configuration>
            <source>${java.version}</source>
            <target>${java.version}</target>
            <annotationProcessorPaths>
                <path>
                    <groupId>org.projectlombok</groupId>
                    <artifactId>lombok</artifactId>
                    <version>${lombok.version}</version>
                </path>
                <path>
                    <groupId>org.mapstruct</groupId>
                    <artifactId>mapstruct-processor</artifactId>
                    <version>${org.mapstruct.version}</version>
                </path>
                <path>
                    <groupId>org.projectlombok</groupId>
                    <artifactId>lombok-mapstruct-binding</artifactId>
                    <version>${lombok-mapstruct-binding.version}</version>
                </path>
            </annotationProcessorPaths>
        </configuration>
    </plugin>
    <!--/MapStruct-->
</plugins>
````

Es fácil cometer errores aquí, ya que los procesadores de anotaciones son una función avanzada. El principal error es
olvidar que nuestro entorno de ejecución buscará procesadores de anotaciones en el `path` o en el `classpath`, pero no
en ambas.

Debemos tener en cuenta que, para la versión `1.18.16 de Lombok y superiores`, necesitamos agregar tanto la dependencia
`lombok-mapstruct-binding` de `Lombok` como la dependencia `mapstruct-processor` en el elemento
`annotationProcessorPaths`. Si no lo hacemos, podríamos obtener un error de compilación:
`“Propiedad desconocida en el tipo de resultado…”`.

Necesitamos la dependencia `lombok-mapstruct-binding` para que `Lombok` y `MapStruct` funcionen juntos. En esencia, le
indica a `MapStruct` que espere hasta que `Lombok` haya completado todo el procesamiento de anotaciones antes de generar
clases de mapeador para los beans mejorados con `Lombok`.

## Configurando el contexto de persistencia JPA/Hibernate

En el `application.yml` del `user-service` configuramos las siguientes propiedades.

````yml
server:
  port: 8001
  error:
    include-message: always

spring:
  application:
    name: user-service
  datasource:
    url: jdbc:mysql://localhost:3306/db_user_service
    username: admin
    password: magadiflo
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        format_sql: true

logging:
  level:
    dev.magadiflo.user.app: debug
    org.hibernate.SQL: debug
````

> Notar que hemos establecido la conexión a la base de datos de `mysql` que actualmente se está ejecutando en mi máquina
> física. Más adelante trabajaremos con bases de datos contenerizadas. Por lo tanto, quiero dejar en claro es que por
> por el momento, trabajaremos con `mysql` instalada en mi máquina local.

## Entity User

Creamos nuestra entidad `User` con el que trabajaremos en esta aplicación. Crearemos las tablas de las bases de datos
a partir de esta clase de entidad, así que las anotaciones sobre los campos se aplicarán la primera vez que se cree
la tabla en la base de datos, por ejemplo, para el campo `name` en la base de datos se establecerá que no admite
`nulos`.

````java

@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;
}
````

## Construye tabla users a partir de entidad User

Si hasta este punto ejecutamos la aplicación, veremos que la tabla se crea correctamente en nuestra base de datos de
`MySQL`.

![01.png](assets/section-02/01.png)

## Implementando el componente repository de acceso a datos

Creamos un repositorio para la entidad `User` que extienda de `JpaRepository`, donde le definiremos un método
personalizado para consultar por la existencia de un email.

````java
public interface UserRepository extends JpaRepository<User, Long> {
    boolean existsByEmail(String email);
}
````

