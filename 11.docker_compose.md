# Secci√≥n 11: Docker Compose: Orquestador para definir y ejecutar multi-contenedores

---

## [Docker Compose overview](https://docs.docker.com/compose/)

`Compose` es una herramienta para definir y ejecutar aplicaciones `Docker multicontenedor`. Con `Compose`, utilizas un
archivo `YAML` para configurar los servicios de tu aplicaci√≥n. Luego, con un solo comando, creas e inicias todos los
servicios a partir de tu configuraci√≥n.

`Compose` funciona en todos los entornos; `producci√≥n`, `staging`, `desarrollo`, `pruebas`, as√≠ como flujos de trabajo
`CI`. Tambi√©n dispone de comandos para gestionar todo el ciclo de vida de tu aplicaci√≥n:

- Iniciar, detener y reconstruir servicios
- Ver el estado de los servicios en ejecuci√≥n
- Transmitir la salida de registro de los servicios en ejecuci√≥n
- Ejecutar un comando puntual en un servicio

Las caracter√≠sticas clave de `Compose` que lo hacen eficaz son:

- Disponer de m√∫ltiples entornos aislados en un √∫nico host
- Conservar los datos de volumen cuando se crean contenedores
- Recrear solo los contenedores que han cambiado
- Soportar variables y mover una composici√≥n entre entornos

![01.png](assets/section-11/01.png)

### [The Compose file](https://docs.docker.com/compose/intro/compose-application-model/#the-compose-file)

Antes de empezar a crear el archivo `compose.yml` (en versiones anteriores era `docker-compose.yml`) veamos algunos
aspectos sobre √©l.

El archivo `Compose` es un archivo `YAML` que define:

- Version `(Optional)`
- Services `(Required)`
- Networks
- Volumes
- Configs
- Secrets

La ruta predeterminada para un archivo `Compose` es `compose.yaml` (preferido) o `compose.yml` que se coloca en el
directorio de trabajo. `Compose` tambi√©n admite `docker-compose.yaml` y `docker-compose.yml` para la compatibilidad
con versiones anteriores. Si existen ambos archivos, `Compose` prefiere el can√≥nico `compose.yaml`.

### [Elemento de nivel superior Versi√≥n](https://docs.docker.com/compose/compose-file/04-version-and-name/)

La propiedad de nivel superior `versi√≥n` est√° definida por la `Especificaci√≥n Compose` para compatibilidad con versiones
anteriores. `Solo tiene car√°cter informativo`.

**Compose no utiliza la versi√≥n para seleccionar un esquema exacto para validar el archivo Compose, sino que prefiere
el esquema m√°s reciente cuando est√° implementado.**

### [Elemento de nivel superior de los Servicios](https://docs.docker.com/compose/compose-file/05-services/)

Un `servicio `es una definici√≥n abstracta de un recurso inform√°tico dentro de una aplicaci√≥n que **puede escalarse o
sustituirse independientemente de otros componentes**.
`Los servicios est√°n respaldados por un conjunto de contenedores`, ejecutados por la plataforma de acuerdo con
los requisitos de replicaci√≥n y las restricciones de ubicaci√≥n. **Dado que los servicios est√°n respaldados por
contenedores, se definen mediante una imagen Docker y un conjunto de argumentos de tiempo de ejecuci√≥n.**
`Todos los contenedores de un servicio se crean de forma id√©ntica con estos argumentos.`

Un archivo `Compose` debe declarar un elemento de nivel superior de servicios como un mapa cuyas `claves` **son
representaciones de cadenas de nombres de servicios**, y cuyos `valores` **son definiciones de servicios.**
Una `definici√≥n de servicio` **contiene la configuraci√≥n que se aplica a cada contenedor de servicio.**

**Cada servicio tambi√©n puede incluir una secci√≥n de** `build`, **que define c√≥mo crear la imagen Docker para el
servicio.** `Compose permite crear im√°genes Docker utilizando esta definici√≥n de servicio.` Si no se utiliza,
la secci√≥n de construcci√≥n se ignora y el archivo `Compose` sigue consider√°ndose v√°lido.

A continuaci√≥n se muestran algunos atributos usados dentro de un servicio:

- `build`, especifica la configuraci√≥n de compilaci√≥n para crear una imagen de contenedor a partir del c√≥digo fuente,
  tal y como se define en la especificaci√≥n de compilaci√≥n de `Compose`.


- `container_name`, es una cadena que especifica un nombre de contenedor personalizado, **en lugar de
  un nombre generado por defecto.**


- `volumes`, definen rutas de host de montaje o `vol√∫menes con nombre` que son accesibles por contenedores
  de servicio. Puedes usar vol√∫menes para definir m√∫ltiples tipos de montajes; `volumen`, `bind`, `tmpfs` o `npipe`.

  > Para `reutilizar un volumen a trav√©s de m√∫ltiples servicios`, se debe declarar un `volumen con nombre` **en la clave
  > de vol√∫menes de nivel superior.**
  >
  > `La declaraci√≥n de vol√∫menes de nivel superior` permite **configurar vol√∫menes con nombre que pueden reutilizarse en
  > varios servicios.** Para utilizar un volumen en varios servicios, debe conceder expl√≠citamente acceso a cada
  > servicio mediante el atributo volumes.

- `networks`, capa que permite a los servicios comunicarse entre s√≠. `El elemento de nivel superior networks permite
  configurar redes con nombre que pueden reutilizarse en varios servicios`. Para utilizar una red en varios servicios,
  debes conceder expl√≠citamente acceso a `cada servicio` utilizando el atributo `networks`.

  > Podr√≠amos no configurar expl√≠citamente un `networks` y en ese caso, por defecto, `Compose` configura una √∫nica red
  > para tu aplicaci√≥n. Cada contenedor para un servicio se une a la red por defecto y es accesible por otros
  > contenedores en esa red, y detectable por ellos en un nombre de host id√©ntico al nombre del contenedor.

## Creando archivo de docker compose

Antes de crear el archivo `compose.yml` y sus respectivos servicios, veamos qu√© im√°genes tenemos relacionados a este
proyecto y qu√© contenedores se est√°n ejecutando actualmente.

Sobre las im√°genes.

````bash
$ docker image ls
REPOSITORY       TAG             IMAGE ID       CREATED        SIZE
course-service   latest          092938a96244   3 days ago     270MB
user-service     latest          4fd59c6bcdb5   4 days ago     271MB
postgres         17-alpine       048d0cbdfc92   10 days ago    279MB
mysql            8.0.41-debian   4340b8ad7a7c   4 months ago   610MB
````

Sobre los contenedores.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE                 COMMAND                  CREATED      STATUS          PORTS                               NAMES
b08a8300361b   postgres:17-alpine    "docker-entrypoint.s‚Ä¶"   5 days ago   Up 18 minutes   0.0.0.0:5433->5432/tcp              c-postgres
76ef3be3ad14   mysql:8.0.41-debian   "docker-entrypoint.s‚Ä¶"   5 days ago   Up 18 minutes   33060/tcp, 0.0.0.0:3307->3306/tcp   c-mysql
````

### Eliminando contenedores

Como vamos a usar `docker compose` para la creaci√≥n de los servicios de contenedores, vamos a eliminar los dos
contenedores de bases de datos mostrados en el resultado anterior que fueron creados manualmente.

üö® Recordemos que esas bases de datos contenerizadas est√°n trabajando con vol√∫menes, por lo tanto, √∫nicamente
eliminamos los contenedores.

````bash
$ docker container rm -f c-postgres c-mysql
c-postgres
c-mysql
````

Ahora, si volvemos a listar, veremos que ya no tenemos ning√∫n contenedor.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
````

### A partir de im√°genes, crea contenedores de bases de datos

En la ra√≠z de nuestro proyecto `docker-kubernetes` creamos el archivo `compose.yml` y agregamos los siguientes dos
servicios para nuestras bases de datos de `mysql` y `postgres`.

````yml
services:
  s-mysql:
    image: mysql:8.0.41-debian
    container_name: c-mysql
    restart: unless-stopped
    ports:
      - '3307:3306'
    environment:
      MYSQL_ROOT_PASSWORD: magadiflo
      MYSQL_DATABASE: db_user_service
      MYSQL_USER: admin
      MYSQL_PASSWORD: magadiflo
    volumes:
      - mysql-data:/var/lib/mysql
    networks:
      - docker-kubernetes-net
    healthcheck:
      test: [ "CMD-SHELL", "mysqladmin ping -h 127.0.0.1 -u$${MYSQL_USER} -p$${MYSQL_PASSWORD}" ]
      interval: 10s
      timeout: 5s
      retries: 5

  s-postgres:
    image: postgres:17-alpine
    container_name: c-postgres
    restart: unless-stopped
    ports:
      - '5433:5432'
    environment:
      POSTGRES_DB: db_course_service
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: magadiflo
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - docker-kubernetes-net
    healthcheck:
      test: [ 'CMD-SHELL', 'pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}' ]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  mysql-data:
    name: mysql-data
    external: true
  postgres-data:
    name: postgres-data
    external: true

networks:
  docker-kubernetes-net:
    name: docker-kubernetes-net
    external: true
````

**Donde**

- `s-mysql` y `s-postgres` son los dos √∫nicos servicios que est√°n definidos hasta el momento en el archivo
  `compose.yml`. Estos servicios utilizan una imagen p√∫blica de base de datos que se extrae del registro de `Docker Hub`
  y es a partir de esas im√°genes que se crear√°n los contenedores.


- Como todos los servicios estar√°n en la misma red `docker-kubernetes-net`, debemos definir
  el `elemento de nivel superior networks` y luego a cada servicio definirle el networks `docker-kubernetes-net`.


- Trabajamos con `volumenes con nombre: mysql-data y postgres-data`, las cuales, adem√°s de ser
  definidas en cada servicio, deber√°n ser definidas en `la declaraci√≥n de vol√∫menes de nivel superior`.


- Tanto al servicio de `mysql` como al servicio de `postgres` les hemos definido el atributo `healthcheck`. Pero,
  `¬øQu√© es un healthcheck?`.

El `healthcheck` es una funcionalidad en `Docker` que permite monitorear el estado de salud de un contenedor. Define
una serie de condiciones que `Docker` verificar√° peri√≥dicamente para determinar si el contenedor est√° funcionando
correctamente. Si el contenedor no pasa las pruebas de salud, se puede tomar acci√≥n, como reiniciar el contenedor o
marcarlo como `no saludable`.

Tomemos como ejemplo el `healthcheck` del servicio de `s-postgres`.

````yml
healthcheck:
  test: [ 'CMD-SHELL', 'pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}' ]
  interval: 10s
  timeout: 5s
  retries: 5
````

1. `test: [ 'CMD-SHELL', 'pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}' ]`
    - Este es el comando que `Docker` ejecuta para verificar si `PostgreSQL` est√° disponible y listo para aceptar
      conexiones.
    - `CMD-SHELL`: Indica que el comando ser√° ejecutado en un `shell`, lo que permite usar el comando como si lo
      estuvieras ejecutando en la terminal.
    - `pg_isready`: Es una herramienta de `PostgreSQL` que se utiliza espec√≠ficamente para verificar si el servidor de
      base de datos est√° disponible y listo para aceptar conexiones. No inicia una conexi√≥n real, pero revisa el estado
      del servidor.
    - `-U $${POSTGRES_USER}`: Especifica el usuario que se usar√° para realizar la comprobaci√≥n.
    - `-d $${POSTGRES_DB}`: Indica la base de datos sobre la cual se est√° verificando la disponibilidad.

   > En resumen, este comando verifica que el servidor `PostgreSQL` est√© corriendo y sea capaz de aceptar conexiones
   > para el usuario `postgres` en la base de datos `db_course_service`.

2. `interval: 10s`, este par√°metro define el intervalo de tiempo entre cada ejecuci√≥n del `healthcheck`, es decir, cada
   cu√°nto tiempo `Docker` ejecutar√° el comando de prueba. En este caso, el intervalo es de 10 segundos. `Docker`
   ejecutar√° la prueba cada 10 segundos mientras el contenedor est√© corriendo.


3. `timeout: 5s`, este par√°metro establece el tiempo m√°ximo que `Docker` esperar√° a que la prueba de `healthcheck` se
   complete antes de considerarla fallida. Aqu√≠ se ha configurado un timeout de 5 segundos. Si el comando no devuelve
   una respuesta en ese tiempo, se considera que la prueba ha fallado.


4. `retries: 5`, este par√°metro define cu√°ntas veces `Docker` intentar√° ejecutar el `healthcheck` antes de marcar el
   contenedor como `no saludable`. En este caso, si la prueba falla 5 veces consecutivas, `Docker` marcar√° el contenedor
   como no saludable.

### Sobre el `$${POSTGRES_USER}`

En `Docker Compose` no existe un soporte directo para interpolaci√≥n de variables de entorno dentro de los comandos de
`healthcheck`. Sin embargo, podemos solucionarlo utilizando variables de entorno dentro del contenedor para evitar
repetir valores.

Una forma es aprovechar que los valores de las variables de entorno definidos en el servicio (como `POSTGRES_USER` y
`POSTGRES_DB`) est√°n disponibles dentro del contenedor, y podemos utilizarlas en el comando `test` del `healthcheck`.
Lo √∫nico que necesitamos es acceder a esas variables usando la siguiente sintaxis `$${POSTGRES_USER}`.

### üîç Qu√© sucede con `$${POSTGRES_USER}` en `compose.yml`

Cuando escribimos, por ejemplo:

````yml
test: [ 'CMD-SHELL', 'pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}' ]
````

`Docker Compose` interpreta el archivo `compose.yml` antes de pas√°rselo a `Docker`. Si solo escribimos
`${POSTGRES_USER}` (con un solo $), `Compose` intentar√° expandir la variable usando las variables de entorno del
sistema host (es decir, de donde ejecutas `docker compose up`). Pero si usamos `$$`, `Docker Compose` interpreta
eso como:

- `$$` ‚Üí se convierte en un solo signo `$`.
- Por tanto, `$${POSTGRES_USER}` ‚Üí se convierte en `${POSTGRES_USER}` dentro del contenedor, sin que `Compose` lo
  expanda.

### ‚úÖ Qu√© significa esto en el contexto de healthcheck

El valor final que se pasar√° al contenedor ser√°:

````bash
pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}
````

Dentro del contenedor, estas variables (`POSTGRES_USER`, `POSTGRES_DB`) s√≠ existen como variables de entorno, gracias
a la secci√≥n `environment`, as√≠ que se resuelven correctamente cuando el shell las eval√∫a.

En resumen, el uso de `$$` en `$${POSTGRES_USER}` es un truco de `Docker Compose` para evitar que se expanda la
variable al momento de interpretar el archivo `yml`. En lugar de resolver la variable con el entorno del host,
`Docker Compose` deja la expresi√≥n `${POSTGRES_USER}` tal cual y la pasa al contenedor. Ya dentro del contenedor,
cuando se ejecuta el comando del `healthcheck`, el shell s√≠ puede resolver `${POSTGRES_USER}` usando las variables
de entorno que fueron definidas en la secci√≥n `environment`.

**Nota 1**
> Cuando hablo de `expandir la variable` en el contexto de `Docker Compose` (y, en general, en programaci√≥n
> y scripting), me refiero al proceso de reemplazar el nombre de la variable con su valor correspondiente. Es decir,
> la expansi√≥n es el acto de tomar una variable definida (como `POSTGRES_USER`) y sustituirla por su valor
> (por ejemplo, `postgres`) en el momento en que se procesa el archivo.

**Nota 2**
> M√°s adelante crearemos el contenedor para `course-service` quien depende de la base de datos de `PostgreSQL`. El
> servicio de `s-course-service` usar√° el atributo `depends_on`. Normalmente, combinamos el atributo `depends_on` con el
> atributo `healthcheck` que ya tenemos configurado en el servicio de `s-postgres`. El `healthcheck` indicar√° al
> servicio de `s-course-service` que espere a que la base de datos de `PostgreSQL` est√© lista para que reci√©n empiece a
> crearse. Pero eso lo veremos cuando creemos el servicio para `course-service`.

- En el archivo `compose.yml` tambi√©n hemos definido el atributo `external: true` tanto para el `volumes` como para el
  `networks`. Esto es necesario, pues de esa manera le indicamos a `docker compose` que use los vol√∫menes o la red que
  ya existen y que fueron creados mediante la l√≠nea de comandos. Es decir, hasta este punto tenemos ya construido una
  red llamada `docker-kubernetes-net`, tambi√©n tenemos construida el volumen `mysql-data` y `postgres-data` que fueron
  creados mediante la l√≠nea de comando (`sin usar Docker Compose`), as√≠ que si no colocamos el atributo
  `external: true`, no nos va a dejar ejecutar el comando de `docker compose` y, en cambio, nos mostrar√° los mensajes
  tal como se muestran a continuaci√≥n.

    ````bash
    $ docker compose up -d
    time="2025-06-11T00:02:49-05:00" level=warning msg="a network with name docker-kubernetes-net exists but was not created by compose.\nSet `external: true` to use an existing network"
    network docker-kubernetes-net was found but has incorrect label com.docker.compose.network set to "" (expected: "docker-kubernetes-net")
    ````
  El mensaje que ves indica que la red `docker-kubernetes-net` ya existe en `Docker`, pero no fue creada por
  `Docker Compose`, lo que puede generar un conflicto, especialmente en la forma en que `Docker Compose` maneja las
  redes.<br><br>
  Como el mensaje sugiere, necesitas indicarle a `Docker Compose` que esta red es externa y que no debe intentar
  recrearla. Para hacer esto, debes ajustar la configuraci√≥n de la red en tu archivo `compose.yml` a√±adiendo la
  opci√≥n `external: true`.<br><br>
  Cuando `Docker Compose` intenta crear una red con el mismo nombre de una red que ya existe fuera del contexto de
  `Docker Compose`, puede producir este tipo de advertencias. Al declarar la red como `external:true`, le est√°s diciendo
  a `Docker Compose` que no intente administrarla y que simplemente la use.

    ````bash
    $ docker compose up -d                                                                                                                                                            
    time="2025-06-11T00:03:38-05:00" level=warning msg="volume \"postgres-data\" already exists but was not created by Docker Compose. Use `external: true` to use an existing volume"
    time="2025-06-11T00:03:38-05:00" level=warning msg="volume \"mysql-data\" already exists but was not created by Docker Compose. Use `external: true` to use an existing volume"                                                                                                                                                                                                                                                                                                                                                      1.3s  ‚úî Container c-mysql     Started
    ````
  El nuevo mensaje que te aparece es muy similar al caso de las redes: indica que los vol√∫menes `mysql-data` y
  `postgres-data` ya existen, pero no fueron creados por `Docker Compose`, lo que puede generar un conflicto.<br><br>
  Para solucionar esto, al igual que con las redes, debes indicar que estos vol√∫menes son externos y que
  `Docker Compose`solo debe utilizarlos sin intentar crearlos o gestionarlos.<br><br>
  Puedes agregar la propiedad `external: true` a los vol√∫menes en tu archivo `compose.yml` para indicarle a
  `Docker Compose` que los vol√∫menes ya existen y no debe crearlos de nuevo.<br><br>
  Esto ocurre porque los vol√∫menes fueron creados previamente (posiblemente de forma manual o en otro contexto), y
  `Docker Compose` no fue quien los gestion√≥ inicialmente. Al igual que con las redes, `Docker Compose` intenta crear y
  administrar sus propios vol√∫menes, y si ya existe uno con el mismo nombre, esto genera un conflicto.

### Ejecutando Docker Compose para crear servicios de contenedores de bases de datos

Antes de ejecutar nuestro `compose.yml`, veamos las redes, vol√∫menes y contenedores que tenemos actualmente. Debemos
notar que tenemos la red `docker-kubernetes-net` ya creada, tambi√©n tenemos los vol√∫menes `mysql-data` y `postgres-data`
ya creados. Lo √∫nico que no tenemos creados son los contenedores.

````bash
$ docker network ls
NETWORK ID     NAME                    DRIVER    SCOPE
f7fda8e506d0   bridge                  bridge    local
f5cc994b8f90   docker-kubernetes-net   bridge    local
e067f6421fbb   host                    host      local
10b2c1c97ecf   none                    null      local

$ docker volume ls
DRIVER    VOLUME NAME
local     mysql-data
local     postgres-data

$ docker container ls -a
CONTAINER ID   IMAGE            COMMAND                  CREATED       STATUS                     PORTS     NAMES
````

Ejecutamos `Docker Compose` con el siguiente comando y vemos que los dos contenedores de bases de datos se crean
correctamente.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-11)
Œª docker compose up -d                                                                                     
[+] Running 2/2                                                                                            
 ‚úî s-mysql Pulled                                                                                          
 ‚úî s-postgres Pulled                                                                                       
[+] Running 2/2                                                                                            
 ‚úî Container c-mysql     Started                                                                           
 ‚úî Container c-postgres  Started                                                                                                                                                   
````

Si listamos los dos contenedores, veremos que ambos est√° corriendo sin problemas.

````bash
$  docker container ls -a
CONTAINER ID   IMAGE                 COMMAND                  CREATED          STATUS                    PORTS                               NAMES
e27dcd1ec6f8   postgres:17-alpine    "docker-entrypoint.s‚Ä¶"   48 seconds ago   Up 39 seconds (healthy)   0.0.0.0:5433->5432/tcp              c-postgres
1b2c70301c59   mysql:8.0.41-debian   "docker-entrypoint.s‚Ä¶"   48 seconds ago   Up 39 seconds (healthy)   33060/tcp, 0.0.0.0:3307->3306/tcp   c-mysql
````

Inspeccionamos el contenedor `c-postgres`. Debemos notar que en el apartado de `Test`, vemos el comando
`"pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"` el cual est√° usando variables de entorno como el
`${POSTGRES_USER}`. Aqu√≠, dentro del contenedor, ya se pasa con `un solo d√≥lar ${POSTGRES_USER}`, mientras que en el
archivo `compose.yml` lo definimos con dos d√≥lares `$${POSTGRES_USER}`, ese es el truco, usar 2 d√≥lares en el archivo
`compose.yml` para que dentro del contenedor pase con 1 d√≥lar. Los valores de estas variables de entorno las
encontramos en el atributo `Env`.

````bash
$ docker container inspect c-postgres
[
    {
        ...
        "Config": {
            ...
            "Env": [
                "POSTGRES_USER=postgres",
                "POSTGRES_PASSWORD=magadiflo",
                "POSTGRES_DB=db_course_service",
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "GOSU_VERSION=1.17",
                "LANG=en_US.utf8",
                "PG_MAJOR=17",
                "PG_VERSION=17.5",
                "PG_SHA256=fcb7ab38e23b264d1902cb25e6adafb4525a6ebcbd015434aeef9eda80f528d8",
                "DOCKER_PG_LLVM_DEPS=llvm19-dev \t\tclang19",
                "PGDATA=/var/lib/postgresql/data"
            ],
            "Cmd": [
                "postgres"
            ],
            "Healthcheck": {
                "Test": [
                    "CMD-SHELL",
                    "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"
                ],
                "Interval": 10000000000,
                "Timeout": 5000000000,
                "Retries": 5
            },
            "Image": "postgres:17-alpine",
            "Volumes": {
                "/var/lib/postgresql/data": {}
            },
           ...
        }
    }
]
````

Inspeccionamos el contenedor `c-mysql`.

````bash
$ docker container inspect c-mysql
[
    {
        ...
        "Config": {
            "Hostname": "1b2c70301c59",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": true,
            "AttachStderr": true,
            "ExposedPorts": {
                "3306/tcp": {},
                "33060/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "MYSQL_DATABASE=db_user_service",
                "MYSQL_USER=admin",
                "MYSQL_PASSWORD=magadiflo",
                "MYSQL_ROOT_PASSWORD=magadiflo",
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "GOSU_VERSION=1.17",
                "MYSQL_MAJOR=8.0",
                "MYSQL_VERSION=8.0.41-1debian12"
            ],
            "Cmd": [
                "mysqld"
            ],
            "Healthcheck": {
                "Test": [
                    "CMD-SHELL",
                    "mysqladmin ping -h 127.0.0.1 -u${MYSQL_USER} -p${MYSQL_PASSWORD}"
                ],
                "Interval": 10000000000,
                "Timeout": 5000000000,
                "Retries": 5
            },
            "Image": "mysql:8.0.41-debian",
            "Volumes": {
                "/var/lib/mysql": {}
            },
            "WorkingDir": "",
            "Entrypoint": [
                "docker-entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": {
                "com.docker.compose.config-hash": "84e33592b9fed512d4545d4f9d50200496213a6ce07c4b770d899f1e5e574f29",
                "com.docker.compose.container-number": "1",
                "com.docker.compose.depends_on": "",
                "com.docker.compose.image": "sha256:4340b8ad7a7ca86dc7f4abe876bc0c8addb3636b0d1be5e660573153540a392c",
                "com.docker.compose.oneoff": "False",
                "com.docker.compose.project": "docker-kubernetes",
                "com.docker.compose.project.config_files": "D:\\programming\\spring\\01.udemy\\02.andres_guzman\\08.docker_kubernetes\\docker-kubernetes\\compose.yml",
                "com.docker.compose.project.working_dir": "D:\\programming\\spring\\01.udemy\\02.andres_guzman\\08.docker_kubernetes\\docker-kubernetes",
                "com.docker.compose.service": "s-mysql",
                "com.docker.compose.version": "2.36.0"
            }
        ...
    }
]
````

Comprobamos que el contenedor `c-postgres` contiene los datos almacenados en el volumen.

````bash
$ docker container exec -it c-postgres /bin/sh
/ # psql -U postgres -d db_course_service
psql (17.5)
Type "help" for help.

db_course_service=# \dt
            List of relations
 Schema |     Name     | Type  |  Owner
--------+--------------+-------+----------
 public | course_users | table | postgres
 public | courses      | table | postgres
(2 rows)

db_course_service=# SELECT * FROM courses;
 id |         name
----+----------------------
  1 | Spring Boot 3
  2 | Spring WebFlux
  3 | Reactive Programming
  4 | Docker
  5 | Kubernetes
(5 rows)

db_course_service=#
````

Comprobamos que el contenedor `c-mysql` contiene los datos almacenados en el volumen.

````bash
$ docker container exec -it c-mysql /bin/sh
# mysql -uadmin -p
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 73
Server version: 8.0.41 MySQL Community Server - GPL

Copyright (c) 2000, 2025, Oracle and/or its affiliates.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| db_user_service    |
| information_schema |
| performance_schema |
+--------------------+
3 rows in set (0.00 sec)

mysql> USE db_user_service;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql> SHOW TABLES;
+---------------------------+
| Tables_in_db_user_service |
+---------------------------+
| users                     |
+---------------------------+
1 row in set (0.00 sec)

mysql> SELECT * FROM users;
+----+--------------------+----------+----------+
| id | email              | name     | password |
+----+--------------------+----------+----------+
|  1 | lesly@gmail.com    | Lesly    | 123456   |
|  4 | kiara@gmail.com    | Kiara    | 123456   |
|  5 | milagros@gmail.com | Milagros | 123456   |
|  6 | susana@gmail.com   | Susana   | 123456   |
|  7 | briela@gmail.com   | Briela   | 123456   |
+----+--------------------+----------+----------+
5 rows in set (0.00 sec)

mysql>
````

### A partir de im√°genes, crea contenedores de microservicios de usuarios y cursos

En el apartado anterior agregamos al archivo `compose.yml` los servicios para nuestros contenedores de bases de datos.
En esta secci√≥n veremos c√≥mo agregar los servicios para los contenedores de nuestros microservicios.

Observemos que actualmente tenemos construida nuestras im√°genes de los microservicios `user-service` y
`course-service`. Entonces, a partir de esas im√°genes ya construidas, definiremos en el archivo `compose.yml` la
configuraci√≥n necesaria para crear los servicios para los contenedores de nuestros dos microservicios.

````bash
$ docker image ls
REPOSITORY       TAG             IMAGE ID       CREATED        SIZE
course-service   latest          092938a96244   5 days ago     270MB
postgres         17-alpine       f40315d0e8a6   5 days ago     279MB
user-service     latest          4fd59c6bcdb5   6 days ago     271MB
mysql            8.0.41-debian   4340b8ad7a7c   4 months ago   610MB
````

A continuaci√≥n se muestra √∫nicamente la configuraci√≥n de los servicios correspondientes a nuestras dos aplicaciones.
Estos servicios est√°n definidos en el `compose.yml`.

````bash
services:
  s-user-service:
    image: user-service:latest
    container_name: c-user-service
    restart: unless-stopped
    ports:
      - '8001:8001'
    env_file: ./business-domain/user-service/.env
    networks:
      - docker-kubernetes-net
    depends_on:
      s-mysql:
        condition: service_healthy

  s-course-service:
    image: course-service:latest
    container_name: c-course-service
    restart: unless-stopped
    ports:
      - '8002:8002'
    env_file: ./business-domain/course-service/.env
    networks:
      - docker-kubernetes-net
    depends_on:
      s-postgres:
        condition: service_healthy
````

**Donde**

- Hemos agregado 2 servicios `s-user-service` y `s-course-service`.


- En `image` estamos definiendo la imagen que vamos a usar y que precisamente ya los tenemos construidos y est√°n
  alojados en la plataforma de `Docker` de nuestra m√°quina local. M√°s adelante veremos c√≥mo usar `compose.yml` para que
  √©l sea quien inicie la construcci√≥n de la imagen apoy√°ndonos del `Dockerfile`.


- La opci√≥n `depends_on` hace referencia al servicio del cual depende. Por ejemplo, servicio `s-course-service` depende
  del servicio `s-postgres`.


- El `s-courser-service` depende del servicio `s-postgres` y la condici√≥n para que `s-course-service` inicie, es que el
  servicio `s-postgres` debe estar en `service_healthy`. Eso significa que el servicio dependiente solo arrancar√° una
  vez que el servicio del que depende haya pasado su `healthcheck` y est√© en estado `healthy` (saludable). Es una medida
  de seguridad para garantizar que la base de datos est√© realmente lista para recibir conexiones antes de que el
  microservicio intente interactuar con ella. Por esa raz√≥n es que en el servicio de `s-postgres` usamos el atributo
  `healthcheck` y su `test`.


- `restart` define la pol√≠tica que la plataforma aplica al terminar el contenedor. Los distintos valores son:
    - `no`: La pol√≠tica de reinicio por defecto. No reinicia el contenedor bajo ninguna circunstancia.
    - `always`: La pol√≠tica siempre reinicia el contenedor hasta su eliminaci√≥n.
    - `on-failure`: La pol√≠tica reinicia el contenedor si el c√≥digo de salida indica un error.
    - `unless-stopped`: La pol√≠tica `unless-stopped` reinicia autom√°ticamente el contenedor sin importar el c√≥digo de
      salida (si fall√≥ o no), pero deja de reiniciarlo si el contenedor ha sido detenido manualmente por el usuario. No
      se reiniciar√° nuevamente hasta que sea iniciado manualmente, incluso despu√©s de reiniciar Docker o el sistema.
