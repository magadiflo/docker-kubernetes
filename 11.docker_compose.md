# Secci√≥n 11: Docker Compose: Orquestador para definir y ejecutar multi-contenedores

---

## [Docker Compose overview](https://docs.docker.com/compose/)

`Compose` es una herramienta para definir y ejecutar aplicaciones `Docker multicontenedor`. Con `Compose`, utilizas un
archivo `YAML` para configurar los servicios de tu aplicaci√≥n. Luego, con un solo comando, creas e inicias todos los
servicios a partir de tu configuraci√≥n.

`Compose` funciona en todos los entornos; `producci√≥n`, `staging`, `desarrollo`, `pruebas`, as√≠ como flujos de trabajo
`CI`. Tambi√©n dispone de comandos para gestionar todo el ciclo de vida de tu aplicaci√≥n:

- Iniciar, detener y reconstruir servicios
- Ver el estado de los servicios en ejecuci√≥n
- Transmitir la salida de registro de los servicios en ejecuci√≥n
- Ejecutar un comando puntual en un servicio

Las caracter√≠sticas clave de `Compose` que lo hacen eficaz son:

- Disponer de m√∫ltiples entornos aislados en un √∫nico host
- Conservar los datos de volumen cuando se crean contenedores
- Recrear solo los contenedores que han cambiado
- Soportar variables y mover una composici√≥n entre entornos

![01.png](assets/section-11/01.png)

### [The Compose file](https://docs.docker.com/compose/intro/compose-application-model/#the-compose-file)

Antes de empezar a crear el archivo `compose.yml` (en versiones anteriores era `docker-compose.yml`) veamos algunos
aspectos sobre √©l.

El archivo `Compose` es un archivo `YAML` que define:

- Version `(Optional)`
- Services `(Required)`
- Networks
- Volumes
- Configs
- Secrets

La ruta predeterminada para un archivo `Compose` es `compose.yaml` (preferido) o `compose.yml` que se coloca en el
directorio de trabajo. `Compose` tambi√©n admite `docker-compose.yaml` y `docker-compose.yml` para la compatibilidad
con versiones anteriores. Si existen ambos archivos, `Compose` prefiere el can√≥nico `compose.yaml`.

### [Elemento de nivel superior Versi√≥n](https://docs.docker.com/compose/compose-file/04-version-and-name/)

La propiedad de nivel superior `versi√≥n` est√° definida por la `Especificaci√≥n Compose` para compatibilidad con versiones
anteriores. `Solo tiene car√°cter informativo`.

**Compose no utiliza la versi√≥n para seleccionar un esquema exacto para validar el archivo Compose, sino que prefiere
el esquema m√°s reciente cuando est√° implementado.**

### [Elemento de nivel superior de los Servicios](https://docs.docker.com/compose/compose-file/05-services/)

Un `servicio `es una definici√≥n abstracta de un recurso inform√°tico dentro de una aplicaci√≥n que **puede escalarse o
sustituirse independientemente de otros componentes**.
`Los servicios est√°n respaldados por un conjunto de contenedores`, ejecutados por la plataforma de acuerdo con
los requisitos de replicaci√≥n y las restricciones de ubicaci√≥n. **Dado que los servicios est√°n respaldados por
contenedores, se definen mediante una imagen Docker y un conjunto de argumentos de tiempo de ejecuci√≥n.**
`Todos los contenedores de un servicio se crean de forma id√©ntica con estos argumentos.`

Un archivo `Compose` debe declarar un elemento de nivel superior de servicios como un mapa cuyas `claves` **son
representaciones de cadenas de nombres de servicios**, y cuyos `valores` **son definiciones de servicios.**
Una `definici√≥n de servicio` **contiene la configuraci√≥n que se aplica a cada contenedor de servicio.**

**Cada servicio tambi√©n puede incluir una secci√≥n de** `build`, **que define c√≥mo crear la imagen Docker para el
servicio.** `Compose permite crear im√°genes Docker utilizando esta definici√≥n de servicio.` Si no se utiliza,
la secci√≥n de construcci√≥n se ignora y el archivo `Compose` sigue consider√°ndose v√°lido.

A continuaci√≥n se muestran algunos atributos usados dentro de un servicio:

- `build`, especifica la configuraci√≥n de compilaci√≥n para crear una imagen de contenedor a partir del c√≥digo fuente,
  tal y como se define en la especificaci√≥n de compilaci√≥n de `Compose`.


- `container_name`, es una cadena que especifica un nombre de contenedor personalizado, **en lugar de
  un nombre generado por defecto.**


- `volumes`, definen rutas de host de montaje o `vol√∫menes con nombre` que son accesibles por contenedores
  de servicio. Puedes usar vol√∫menes para definir m√∫ltiples tipos de montajes; `volumen`, `bind`, `tmpfs` o `npipe`.

  > Para `reutilizar un volumen a trav√©s de m√∫ltiples servicios`, se debe declarar un `volumen con nombre` **en la clave
  > de vol√∫menes de nivel superior.**
  >
  > `La declaraci√≥n de vol√∫menes de nivel superior` permite **configurar vol√∫menes con nombre que pueden reutilizarse en
  > varios servicios.** Para utilizar un volumen en varios servicios, debe conceder expl√≠citamente acceso a cada
  > servicio mediante el atributo volumes.

- `networks`, capa que permite a los servicios comunicarse entre s√≠. `El elemento de nivel superior networks permite
  configurar redes con nombre que pueden reutilizarse en varios servicios`. Para utilizar una red en varios servicios,
  debes conceder expl√≠citamente acceso a `cada servicio` utilizando el atributo `networks`.

  > Podr√≠amos no configurar expl√≠citamente un `networks` y en ese caso, por defecto, `Compose` configura una √∫nica red
  > para tu aplicaci√≥n. Cada contenedor para un servicio se une a la red por defecto y es accesible por otros
  > contenedores en esa red, y detectable por ellos en un nombre de host id√©ntico al nombre del contenedor.

## Creando archivo de docker compose

Antes de crear el archivo `compose.yml` y sus respectivos servicios, veamos qu√© im√°genes tenemos relacionados a este
proyecto y qu√© contenedores se est√°n ejecutando actualmente.

Sobre las im√°genes.

````bash
$ docker image ls
REPOSITORY       TAG             IMAGE ID       CREATED        SIZE
course-service   latest          092938a96244   3 days ago     270MB
user-service     latest          4fd59c6bcdb5   4 days ago     271MB
postgres         17-alpine       048d0cbdfc92   10 days ago    279MB
mysql            8.0.41-debian   4340b8ad7a7c   4 months ago   610MB
````

Sobre los contenedores.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE                 COMMAND                  CREATED      STATUS          PORTS                               NAMES
b08a8300361b   postgres:17-alpine    "docker-entrypoint.s‚Ä¶"   5 days ago   Up 18 minutes   0.0.0.0:5433->5432/tcp              c-postgres
76ef3be3ad14   mysql:8.0.41-debian   "docker-entrypoint.s‚Ä¶"   5 days ago   Up 18 minutes   33060/tcp, 0.0.0.0:3307->3306/tcp   c-mysql
````

### Eliminando contenedores

Como vamos a usar `docker compose` para la creaci√≥n de los servicios de contenedores, vamos a eliminar los dos
contenedores de bases de datos mostrados en el resultado anterior que fueron creados manualmente.

üö® Recordemos que esas bases de datos contenerizadas est√°n trabajando con vol√∫menes, por lo tanto, √∫nicamente
eliminamos los contenedores.

````bash
$ docker container rm -f c-postgres c-mysql
c-postgres
c-mysql
````

Ahora, si volvemos a listar, veremos que ya no tenemos ning√∫n contenedor.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
````

### A partir de im√°genes, crea contenedores de bases de datos

En la ra√≠z de nuestro proyecto `docker-kubernetes` creamos el archivo `compose.yml` y agregamos los siguientes dos
servicios para nuestras bases de datos de `mysql` y `postgres`.

````yml
services:
  s-mysql:
    image: mysql:8.0.41-debian
    container_name: c-mysql
    restart: unless-stopped
    ports:
      - '3307:3306'
    environment:
      MYSQL_ROOT_PASSWORD: magadiflo
      MYSQL_DATABASE: db_user_service
      MYSQL_USER: admin
      MYSQL_PASSWORD: magadiflo
    volumes:
      - mysql-data:/var/lib/mysql
    networks:
      - docker-kubernetes-net
    healthcheck:
      test: [ "CMD-SHELL", "mysqladmin ping -h 127.0.0.1 -u$${MYSQL_USER} -p$${MYSQL_PASSWORD}" ]
      interval: 10s
      timeout: 5s
      retries: 5

  s-postgres:
    image: postgres:17-alpine
    container_name: c-postgres
    restart: unless-stopped
    ports:
      - '5433:5432'
    environment:
      POSTGRES_DB: db_course_service
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: magadiflo
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - docker-kubernetes-net
    healthcheck:
      test: [ 'CMD-SHELL', 'pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}' ]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  mysql-data:
    name: mysql-data
    external: true
  postgres-data:
    name: postgres-data
    external: true

networks:
  docker-kubernetes-net:
    name: docker-kubernetes-net
    external: true
````

**Donde**

- `s-mysql` y `s-postgres` son los dos √∫nicos servicios que est√°n definidos hasta el momento en el archivo
  `compose.yml`. Estos servicios utilizan una imagen p√∫blica de base de datos que se extrae del registro de `Docker Hub`
  y es a partir de esas im√°genes que se crear√°n los contenedores.


- Como todos los servicios estar√°n en la misma red `docker-kubernetes-net`, debemos definir
  el `elemento de nivel superior networks` y luego a cada servicio definirle el networks `docker-kubernetes-net`.


- Trabajamos con `volumenes con nombre: mysql-data y postgres-data`, las cuales, adem√°s de ser
  definidas en cada servicio, deber√°n ser definidas en `la declaraci√≥n de vol√∫menes de nivel superior`.


- Tanto al servicio de `mysql` como al servicio de `postgres` les hemos definido el atributo `healthcheck`. Pero,
  `¬øQu√© es un healthcheck?`.

El `healthcheck` es una funcionalidad en `Docker` que permite monitorear el estado de salud de un contenedor. Define
una serie de condiciones que `Docker` verificar√° peri√≥dicamente para determinar si el contenedor est√° funcionando
correctamente. Si el contenedor no pasa las pruebas de salud, se puede tomar acci√≥n, como reiniciar el contenedor o
marcarlo como `no saludable`.

Tomemos como ejemplo el `healthcheck` del servicio de `s-postgres`.

````yml
healthcheck:
  test: [ 'CMD-SHELL', 'pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}' ]
  interval: 10s
  timeout: 5s
  retries: 5
````

1. `test: [ 'CMD-SHELL', 'pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}' ]`
    - Este es el comando que `Docker` ejecuta para verificar si `PostgreSQL` est√° disponible y listo para aceptar
      conexiones.
    - `CMD-SHELL`: Indica que el comando ser√° ejecutado en un `shell`, lo que permite usar el comando como si lo
      estuvieras ejecutando en la terminal.
    - `pg_isready`: Es una herramienta de `PostgreSQL` que se utiliza espec√≠ficamente para verificar si el servidor de
      base de datos est√° disponible y listo para aceptar conexiones. No inicia una conexi√≥n real, pero revisa el estado
      del servidor.
    - `-U $${POSTGRES_USER}`: Especifica el usuario que se usar√° para realizar la comprobaci√≥n.
    - `-d $${POSTGRES_DB}`: Indica la base de datos sobre la cual se est√° verificando la disponibilidad.

   > En resumen, este comando verifica que el servidor `PostgreSQL` est√© corriendo y sea capaz de aceptar conexiones
   > para el usuario `postgres` en la base de datos `db_course_service`.

2. `interval: 10s`, este par√°metro define el intervalo de tiempo entre cada ejecuci√≥n del `healthcheck`, es decir, cada
   cu√°nto tiempo `Docker` ejecutar√° el comando de prueba. En este caso, el intervalo es de 10 segundos. `Docker`
   ejecutar√° la prueba cada 10 segundos mientras el contenedor est√© corriendo.


3. `timeout: 5s`, este par√°metro establece el tiempo m√°ximo que `Docker` esperar√° a que la prueba de `healthcheck` se
   complete antes de considerarla fallida. Aqu√≠ se ha configurado un timeout de 5 segundos. Si el comando no devuelve
   una respuesta en ese tiempo, se considera que la prueba ha fallado.


4. `retries: 5`, este par√°metro define cu√°ntas veces `Docker` intentar√° ejecutar el `healthcheck` antes de marcar el
   contenedor como `no saludable`. En este caso, si la prueba falla 5 veces consecutivas, `Docker` marcar√° el contenedor
   como no saludable.

### Sobre el `$${POSTGRES_USER}`

En `Docker Compose` no existe un soporte directo para interpolaci√≥n de variables de entorno dentro de los comandos de
`healthcheck`. Sin embargo, podemos solucionarlo utilizando variables de entorno dentro del contenedor para evitar
repetir valores.

Una forma es aprovechar que los valores de las variables de entorno definidos en el servicio (como `POSTGRES_USER` y
`POSTGRES_DB`) est√°n disponibles dentro del contenedor, y podemos utilizarlas en el comando `test` del `healthcheck`.
Lo √∫nico que necesitamos es acceder a esas variables usando la siguiente sintaxis `$${POSTGRES_USER}`.

### üîç Qu√© sucede con `$${POSTGRES_USER}` en `compose.yml`

Cuando escribimos, por ejemplo:

````yml
test: [ 'CMD-SHELL', 'pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}' ]
````

`Docker Compose` interpreta el archivo `compose.yml` antes de pas√°rselo a `Docker`. Si solo escribimos
`${POSTGRES_USER}` (con un solo $), `Compose` intentar√° expandir la variable usando las variables de entorno del
sistema host (es decir, de donde ejecutas `docker compose up`). Pero si usamos `$$`, `Docker Compose` interpreta
eso como:

- `$$` ‚Üí se convierte en un solo signo `$`.
- Por tanto, `$${POSTGRES_USER}` ‚Üí se convierte en `${POSTGRES_USER}` dentro del contenedor, sin que `Compose` lo
  expanda.

### ‚úÖ Qu√© significa esto en el contexto de healthcheck

El valor final que se pasar√° al contenedor ser√°:

````bash
pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}
````

Dentro del contenedor, estas variables (`POSTGRES_USER`, `POSTGRES_DB`) s√≠ existen como variables de entorno, gracias
a la secci√≥n `environment`, as√≠ que se resuelven correctamente cuando el shell las eval√∫a.

En resumen, el uso de `$$` en `$${POSTGRES_USER}` es un truco de `Docker Compose` para evitar que se expanda la
variable al momento de interpretar el archivo `yml`. En lugar de resolver la variable con el entorno del host,
`Docker Compose` deja la expresi√≥n `${POSTGRES_USER}` tal cual y la pasa al contenedor. Ya dentro del contenedor,
cuando se ejecuta el comando del `healthcheck`, el shell s√≠ puede resolver `${POSTGRES_USER}` usando las variables
de entorno que fueron definidas en la secci√≥n `environment`.

**Nota 1**
> Cuando hablo de `expandir la variable` en el contexto de `Docker Compose` (y, en general, en programaci√≥n
> y scripting), me refiero al proceso de reemplazar el nombre de la variable con su valor correspondiente. Es decir,
> la expansi√≥n es el acto de tomar una variable definida (como `POSTGRES_USER`) y sustituirla por su valor
> (por ejemplo, `postgres`) en el momento en que se procesa el archivo.

**Nota 2**
> M√°s adelante crearemos el contenedor para `course-service` quien depende de la base de datos de `PostgreSQL`. El
> servicio de `s-course-service` usar√° el atributo `depends_on`. Normalmente, combinamos el atributo `depends_on` con el
> atributo `healthcheck` que ya tenemos configurado en el servicio de `s-postgres`. El `healthcheck` indicar√° al
> servicio de `s-course-service` que espere a que la base de datos de `PostgreSQL` est√© lista para que reci√©n empiece a
> crearse. Pero eso lo veremos cuando creemos el servicio para `course-service`.

- En el archivo `compose.yml` tambi√©n hemos definido el atributo `external: true` tanto para el `volumes` como para el
  `networks`. Esto es necesario, pues de esa manera le indicamos a `docker compose` que use los vol√∫menes o la red que
  ya existen y que fueron creados mediante la l√≠nea de comandos. Es decir, hasta este punto tenemos ya construido una
  red llamada `docker-kubernetes-net`, tambi√©n tenemos construida el volumen `mysql-data` y `postgres-data` que fueron
  creados mediante la l√≠nea de comando (`sin usar Docker Compose`), as√≠ que si no colocamos el atributo
  `external: true`, no nos va a dejar ejecutar el comando de `docker compose` y, en cambio, nos mostrar√° los mensajes
  tal como se muestran a continuaci√≥n.

    ````bash
    $ docker compose up -d
    time="2025-06-11T00:02:49-05:00" level=warning msg="a network with name docker-kubernetes-net exists but was not created by compose.\nSet `external: true` to use an existing network"
    network docker-kubernetes-net was found but has incorrect label com.docker.compose.network set to "" (expected: "docker-kubernetes-net")
    ````
  El mensaje que ves indica que la red `docker-kubernetes-net` ya existe en `Docker`, pero no fue creada por
  `Docker Compose`, lo que puede generar un conflicto, especialmente en la forma en que `Docker Compose` maneja las
  redes.<br><br>
  Como el mensaje sugiere, necesitas indicarle a `Docker Compose` que esta red es externa y que no debe intentar
  recrearla. Para hacer esto, debes ajustar la configuraci√≥n de la red en tu archivo `compose.yml` a√±adiendo la
  opci√≥n `external: true`.<br><br>
  Cuando `Docker Compose` intenta crear una red con el mismo nombre de una red que ya existe fuera del contexto de
  `Docker Compose`, puede producir este tipo de advertencias. Al declarar la red como `external:true`, le est√°s diciendo
  a `Docker Compose` que no intente administrarla y que simplemente la use.

    ````bash
    $ docker compose up -d                                                                                                                                                            
    time="2025-06-11T00:03:38-05:00" level=warning msg="volume \"postgres-data\" already exists but was not created by Docker Compose. Use `external: true` to use an existing volume"
    time="2025-06-11T00:03:38-05:00" level=warning msg="volume \"mysql-data\" already exists but was not created by Docker Compose. Use `external: true` to use an existing volume"                                                                                                                                                                                                                                                                                                                                                      1.3s  ‚úî Container c-mysql     Started
    ````
  El nuevo mensaje que te aparece es muy similar al caso de las redes: indica que los vol√∫menes `mysql-data` y
  `postgres-data` ya existen, pero no fueron creados por `Docker Compose`, lo que puede generar un conflicto.<br><br>
  Para solucionar esto, al igual que con las redes, debes indicar que estos vol√∫menes son externos y que
  `Docker Compose`solo debe utilizarlos sin intentar crearlos o gestionarlos.<br><br>
  Puedes agregar la propiedad `external: true` a los vol√∫menes en tu archivo `compose.yml` para indicarle a
  `Docker Compose` que los vol√∫menes ya existen y no debe crearlos de nuevo.<br><br>
  Esto ocurre porque los vol√∫menes fueron creados previamente (posiblemente de forma manual o en otro contexto), y
  `Docker Compose` no fue quien los gestion√≥ inicialmente. Al igual que con las redes, `Docker Compose` intenta crear y
  administrar sus propios vol√∫menes, y si ya existe uno con el mismo nombre, esto genera un conflicto.

### Ejecutando Docker Compose para crear servicios de contenedores de bases de datos

Antes de ejecutar nuestro `compose.yml`, veamos las redes, vol√∫menes y contenedores que tenemos actualmente. Debemos
notar que tenemos la red `docker-kubernetes-net` ya creada, tambi√©n tenemos los vol√∫menes `mysql-data` y `postgres-data`
ya creados. Lo √∫nico que no tenemos creados son los contenedores.

````bash
$ docker network ls
NETWORK ID     NAME                    DRIVER    SCOPE
f7fda8e506d0   bridge                  bridge    local
f5cc994b8f90   docker-kubernetes-net   bridge    local
e067f6421fbb   host                    host      local
10b2c1c97ecf   none                    null      local

$ docker volume ls
DRIVER    VOLUME NAME
local     mysql-data
local     postgres-data

$ docker container ls -a
CONTAINER ID   IMAGE            COMMAND                  CREATED       STATUS                     PORTS     NAMES
````

Ejecutamos `Docker Compose` con el siguiente comando y vemos que los dos contenedores de bases de datos se crean
correctamente.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-11)
Œª docker compose up -d                                                                                     
[+] Running 2/2                                                                                            
 ‚úî s-mysql Pulled                                                                                          
 ‚úî s-postgres Pulled                                                                                       
[+] Running 2/2                                                                                            
 ‚úî Container c-mysql     Started                                                                           
 ‚úî Container c-postgres  Started                                                                                                                                                   
````

Si listamos los dos contenedores, veremos que ambos est√° corriendo sin problemas.

````bash
$  docker container ls -a
CONTAINER ID   IMAGE                 COMMAND                  CREATED          STATUS                    PORTS                               NAMES
e27dcd1ec6f8   postgres:17-alpine    "docker-entrypoint.s‚Ä¶"   48 seconds ago   Up 39 seconds (healthy)   0.0.0.0:5433->5432/tcp              c-postgres
1b2c70301c59   mysql:8.0.41-debian   "docker-entrypoint.s‚Ä¶"   48 seconds ago   Up 39 seconds (healthy)   33060/tcp, 0.0.0.0:3307->3306/tcp   c-mysql
````

Inspeccionamos el contenedor `c-postgres`. Debemos notar que en el apartado de `Test`, vemos el comando
`"pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"` el cual est√° usando variables de entorno como el
`${POSTGRES_USER}`. Aqu√≠, dentro del contenedor, ya se pasa con `un solo d√≥lar ${POSTGRES_USER}`, mientras que en el
archivo `compose.yml` lo definimos con dos d√≥lares `$${POSTGRES_USER}`, ese es el truco, usar 2 d√≥lares en el archivo
`compose.yml` para que dentro del contenedor pase con 1 d√≥lar. Los valores de estas variables de entorno las
encontramos en el atributo `Env`.

````bash
$ docker container inspect c-postgres
[
    {
        ...
        "Config": {
            ...
            "Env": [
                "POSTGRES_USER=postgres",
                "POSTGRES_PASSWORD=magadiflo",
                "POSTGRES_DB=db_course_service",
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "GOSU_VERSION=1.17",
                "LANG=en_US.utf8",
                "PG_MAJOR=17",
                "PG_VERSION=17.5",
                "PG_SHA256=fcb7ab38e23b264d1902cb25e6adafb4525a6ebcbd015434aeef9eda80f528d8",
                "DOCKER_PG_LLVM_DEPS=llvm19-dev \t\tclang19",
                "PGDATA=/var/lib/postgresql/data"
            ],
            "Cmd": [
                "postgres"
            ],
            "Healthcheck": {
                "Test": [
                    "CMD-SHELL",
                    "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"
                ],
                "Interval": 10000000000,
                "Timeout": 5000000000,
                "Retries": 5
            },
            "Image": "postgres:17-alpine",
            "Volumes": {
                "/var/lib/postgresql/data": {}
            },
           ...
        }
    }
]
````

Inspeccionamos el contenedor `c-mysql`.

````bash
$ docker container inspect c-mysql
[
    {
        ...
        "Config": {
            "Hostname": "1b2c70301c59",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": true,
            "AttachStderr": true,
            "ExposedPorts": {
                "3306/tcp": {},
                "33060/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "MYSQL_DATABASE=db_user_service",
                "MYSQL_USER=admin",
                "MYSQL_PASSWORD=magadiflo",
                "MYSQL_ROOT_PASSWORD=magadiflo",
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "GOSU_VERSION=1.17",
                "MYSQL_MAJOR=8.0",
                "MYSQL_VERSION=8.0.41-1debian12"
            ],
            "Cmd": [
                "mysqld"
            ],
            "Healthcheck": {
                "Test": [
                    "CMD-SHELL",
                    "mysqladmin ping -h 127.0.0.1 -u${MYSQL_USER} -p${MYSQL_PASSWORD}"
                ],
                "Interval": 10000000000,
                "Timeout": 5000000000,
                "Retries": 5
            },
            "Image": "mysql:8.0.41-debian",
            "Volumes": {
                "/var/lib/mysql": {}
            },
            "WorkingDir": "",
            "Entrypoint": [
                "docker-entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": {
                "com.docker.compose.config-hash": "84e33592b9fed512d4545d4f9d50200496213a6ce07c4b770d899f1e5e574f29",
                "com.docker.compose.container-number": "1",
                "com.docker.compose.depends_on": "",
                "com.docker.compose.image": "sha256:4340b8ad7a7ca86dc7f4abe876bc0c8addb3636b0d1be5e660573153540a392c",
                "com.docker.compose.oneoff": "False",
                "com.docker.compose.project": "docker-kubernetes",
                "com.docker.compose.project.config_files": "D:\\programming\\spring\\01.udemy\\02.andres_guzman\\08.docker_kubernetes\\docker-kubernetes\\compose.yml",
                "com.docker.compose.project.working_dir": "D:\\programming\\spring\\01.udemy\\02.andres_guzman\\08.docker_kubernetes\\docker-kubernetes",
                "com.docker.compose.service": "s-mysql",
                "com.docker.compose.version": "2.36.0"
            }
        ...
    }
]
````

Comprobamos que el contenedor `c-postgres` contiene los datos almacenados en el volumen.

````bash
$ docker container exec -it c-postgres /bin/sh
/ # psql -U postgres -d db_course_service
psql (17.5)
Type "help" for help.

db_course_service=# \dt
            List of relations
 Schema |     Name     | Type  |  Owner
--------+--------------+-------+----------
 public | course_users | table | postgres
 public | courses      | table | postgres
(2 rows)

db_course_service=# SELECT * FROM courses;
 id |         name
----+----------------------
  1 | Spring Boot 3
  2 | Spring WebFlux
  3 | Reactive Programming
  4 | Docker
  5 | Kubernetes
(5 rows)

db_course_service=#
````

Comprobamos que el contenedor `c-mysql` contiene los datos almacenados en el volumen.

````bash
$ docker container exec -it c-mysql /bin/sh
# mysql -uadmin -p
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 73
Server version: 8.0.41 MySQL Community Server - GPL

Copyright (c) 2000, 2025, Oracle and/or its affiliates.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| db_user_service    |
| information_schema |
| performance_schema |
+--------------------+
3 rows in set (0.00 sec)

mysql> USE db_user_service;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql> SHOW TABLES;
+---------------------------+
| Tables_in_db_user_service |
+---------------------------+
| users                     |
+---------------------------+
1 row in set (0.00 sec)

mysql> SELECT * FROM users;
+----+--------------------+----------+----------+
| id | email              | name     | password |
+----+--------------------+----------+----------+
|  1 | lesly@gmail.com    | Lesly    | 123456   |
|  4 | kiara@gmail.com    | Kiara    | 123456   |
|  5 | milagros@gmail.com | Milagros | 123456   |
|  6 | susana@gmail.com   | Susana   | 123456   |
|  7 | briela@gmail.com   | Briela   | 123456   |
+----+--------------------+----------+----------+
5 rows in set (0.00 sec)

mysql>
````

### A partir de im√°genes, crea contenedores de microservicios de usuarios y cursos

En el apartado anterior agregamos al archivo `compose.yml` los servicios para nuestros contenedores de bases de datos.
En esta secci√≥n veremos c√≥mo agregar los servicios para los contenedores de nuestros microservicios.

Observemos que actualmente tenemos construida nuestras im√°genes de los microservicios `user-service` y
`course-service`. Entonces, a partir de esas im√°genes ya construidas, definiremos en el archivo `compose.yml` la
configuraci√≥n necesaria para crear los servicios para los contenedores de nuestros dos microservicios.

````bash
$ docker image ls
REPOSITORY       TAG             IMAGE ID       CREATED        SIZE
course-service   latest          092938a96244   5 days ago     270MB
postgres         17-alpine       f40315d0e8a6   5 days ago     279MB
user-service     latest          4fd59c6bcdb5   6 days ago     271MB
mysql            8.0.41-debian   4340b8ad7a7c   4 months ago   610MB
````

A continuaci√≥n se muestra √∫nicamente la configuraci√≥n de los servicios correspondientes a nuestras dos aplicaciones.
Estos servicios est√°n definidos en el `compose.yml`.

````bash
services:
  s-user-service:
    image: user-service:latest
    container_name: c-user-service
    restart: unless-stopped
    ports:
      - '8001:8001'
    env_file: ./business-domain/user-service/.env
    networks:
      - docker-kubernetes-net
    depends_on:
      s-mysql:
        condition: service_healthy

  s-course-service:
    image: course-service:latest
    container_name: c-course-service
    restart: unless-stopped
    ports:
      - '8002:8002'
    env_file: ./business-domain/course-service/.env
    networks:
      - docker-kubernetes-net
    depends_on:
      s-postgres:
        condition: service_healthy
````

**Donde**

- Hemos agregado 2 servicios `s-user-service` y `s-course-service`.


- En `image` estamos definiendo la imagen que vamos a usar y que precisamente ya los tenemos construidos y est√°n
  alojados en la plataforma de `Docker` de nuestra m√°quina local. M√°s adelante veremos c√≥mo usar `compose.yml` para que
  √©l sea quien inicie la construcci√≥n de la imagen apoy√°ndonos del `Dockerfile`.


- La opci√≥n `depends_on` hace referencia al servicio del cual depende. Por ejemplo, servicio `s-course-service` depende
  del servicio `s-postgres`.


- El `s-courser-service` depende del servicio `s-postgres` y la condici√≥n para que `s-course-service` inicie, es que el
  servicio `s-postgres` debe estar en `service_healthy`. Eso significa que el servicio dependiente solo arrancar√° una
  vez que el servicio del que depende haya pasado su `healthcheck` y est√© en estado `healthy` (saludable). Es una medida
  de seguridad para garantizar que la base de datos est√© realmente lista para recibir conexiones antes de que el
  microservicio intente interactuar con ella. Por esa raz√≥n es que en el servicio de `s-postgres` usamos el atributo
  `healthcheck` y su `test`.


- `restart` define la pol√≠tica que la plataforma aplica al terminar el contenedor. Los distintos valores son:
    - `no`: La pol√≠tica de reinicio por defecto. No reinicia el contenedor bajo ninguna circunstancia.
    - `always`: La pol√≠tica siempre reinicia el contenedor hasta su eliminaci√≥n.
    - `on-failure`: La pol√≠tica reinicia el contenedor si el c√≥digo de salida indica un error.
    - `unless-stopped`: La pol√≠tica `unless-stopped` reinicia autom√°ticamente el contenedor sin importar el c√≥digo de
      salida (si fall√≥ o no), pero deja de reiniciarlo si el contenedor ha sido detenido manualmente por el usuario. No
      se reiniciar√° nuevamente hasta que sea iniciado manualmente, incluso despu√©s de reiniciar Docker o el sistema.

## Ejecuta docker compose up y down

Antes de ejecutar el archivo `compose.yml` necesitamos asegurarnos de no tener levantado ning√∫n contenedor de nuestros
servicios. Recordemos que anteriormente usamos el comando `docker compose up -d` para levantar los servicios de los
contenedores de bases de datos, as√≠ que en este momento simplemente ejecutamos `docker compose down` para eliminar
los contenedores que ya ten√≠amos levantado de esas bases de datos. Es importante resaltar que dicho comando lo debemos
ejecutar en la misma ra√≠z donde se encuentra el archivo `compose.yml`.

En resumen, debemos iniciar con la red existente `docker-kubernetes-net`, los vol√∫menes existentes `mysql-data` y
`postgres-data` y con ning√∫n contenedor.

> `Nota`, en el comentario anterior digo que debemos iniciar con la red y vol√∫menes `existentes`, es porque esos
> componentes ya los hab√≠amos creado desde un inicio con l√≠nea de comandos, as√≠ que como vamos a usar `docker compose`
> simplemente los vamos a reutilizar.

````bash
$ docker network ls
NETWORK ID     NAME                    DRIVER    SCOPE
5216d833c074   bridge                  bridge    local
f5cc994b8f90   docker-kubernetes-net   bridge    local
e067f6421fbb   host                    host      local
10b2c1c97ecf   none                    null      local

$ docker volume ls
DRIVER    VOLUME NAME
local     mysql-data
local     postgres-data

$ docker container ls -a
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
````

Una vez que tenemos todo listo, nos posicionamos en la ra√≠z donde se encuentra el archivo `compose.yml` y ejecutamos el
siguiente comando.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-11) 
$ docker compose up -d                                                                                      
[+] Running 4/4                                                                                             
 ‚úî Container c-postgres        Healthy                                                                      
 ‚úî Container c-mysql           Healthy                                                                      
 ‚úî Container c-course-service  Started                                                                      
 ‚úî Container c-user-service    Started                                                                      
````

**Donde**

- `docker compose up`, construye, (re)crea, inicia y adjunta a contenedores para un servicio. A menos que ya se est√©n
  ejecutando; este comando tambi√©n inicia cualquier servicio vinculado.
- `-d o --detach`, inicia los contenedores en segundo plano y los deja funcionando.

Verificamos que los 4 contenedores se est√©n ejecutando correctamente, es decir, tengan el estado en `Up`.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE                   COMMAND                  CREATED              STATUS                        PORTS                               NAMES
92ed8273a7e6   user-service:latest     "/__cacert_entrypoin‚Ä¶"   About a minute ago   Up About a minute             0.0.0.0:8001->8001/tcp              c-user-service
aa982a66e44b   course-service:latest   "/__cacert_entrypoin‚Ä¶"   About a minute ago   Up About a minute             0.0.0.0:8002->8002/tcp              c-course-service
fc7240594bad   postgres:17-alpine      "docker-entrypoint.s‚Ä¶"   About a minute ago   Up About a minute (healthy)   0.0.0.0:5433->5432/tcp              c-postgres
4a54e7d1aeda   mysql:8.0.41-debian     "docker-entrypoint.s‚Ä¶"   About a minute ago   Up About a minute (healthy)   33060/tcp, 0.0.0.0:3307->3306/tcp   c-mysql
````

Ahora, con una sola petici√≥n al backend, comprobaremos que todos los microservicios y bases de datos est√©n funcionando
correctamente. Esta petici√≥n buscar√° todos los cursos existentes y nos traer√° adem√°s, los usuarios que est√©n
relacionados con cada curso.

````bash
$ curl -v -G --data "loadRelations=true" http://localhost:8002/api/v1/courses | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 12 Jun 2025 05:01:10 GMT
<
[
  {
    "id": 1,
    "name": "Spring Boot 3",
    "users": [
      {
        "id": 4,
        "name": "Kiara",
        "email": "kiara@gmail.com",
        "password": "123456"
      },
      {
        "id": 5,
        "name": "Milagros",
        "email": "milagros@gmail.com",
        "password": "123456"
      }
    ]
  },
  {...}
]
````

### üì¢ Importante

Repasemos r√°pidamente los servicios que tenemos en el `compose.yml` y el nombre que le dimos a los contenedores de
dichos servicios en el atributo `container_name`.

| Servicios        | Container Name   |
|------------------|------------------|
| s-mysql          | c-mysql          |
| s-postgres       | c-postgres       |
| s-user-service   | c-user-service   |
| s-course-service | c-course-service |

Ahora tomemos como ejemplo las variables de entorno definidas en el archivo `.env` del microservicio `course-service`:

````bash
# Container
CONTAINER_PORT=8002

# Database
DB_HOST=c-postgres
DB_PORT=5432
DB_NAME=db_course_service
DB_USERNAME=postgres
DB_PASSWORD=magadiflo

# Communication with microservice user-service
USER_SERVICE_HOST=c-user-service
USER_SERVICE_PORT=8001
````

- Observa que en `DB_HOST` se est√° utilizando el valor del `container_name` definido en `compose.yml`, es decir,
  `c-postgres`.
- De igual forma, en `USER_SERVICE_HOST` se est√° usando `c-user-service`, tambi√©n tomado del `container_name`.

### ‚ö†Ô∏è ¬øQu√© es lo que quiero decir con esto?

Cuando trabajemos con `Docker Compose`, lo ideal es que `‚úÖ utilicemos el nombre del servicio` *(no el del contenedor)*
definido en el archivo `compose.yml` para permitir la comunicaci√≥n entre microservicios.

Cuando no se especifica una red externa, `Docker Compose` crea autom√°ticamente una red interna para los servicios, y
cada uno puede ser alcanzado por su nombre de servicio. En nuestro caso, estamos utilizando una red externa ya creada
previamente (`docker-kubernetes-net`), y `Docker Compose` la aprovecha para permitir esa misma comunicaci√≥n entre
servicios.

En nuestro caso, el microservicio `course-service` puede comunicarse con `user-service` utilizando el nombre del
servicio: `s-user-service`. Por lo tanto, una llamada HTTP se realizar√≠a as√≠:

````bash
http://s-user-service:<puerto>
````

Donde `<puerto>` corresponde al puerto interno configurado en la propiedad `server.port` del servicio destino.

En resumen:

> ‚úÖ Usa el `nombre del servicio` para la comunicaci√≥n entre microservicios.

Aunque tambi√©n funcionar√≠a usar el `container_name` (porque `Docker` permite que los contenedores se comuniquen entre
s√≠ dentro de la red), no es lo m√°s recomendable por las siguientes razones:

1. `Cambios en el nombre del contenedor`: Si decides cambiar el `container_name` en el `compose.yml`, deber√°s actualizar
   todas las referencias en tu c√≥digo. En cambio, el nombre del servicio tiende a ser m√°s estable.


2. `Consistencia y legibilidad`: Usar el nombre del servicio hace que el c√≥digo sea m√°s claro y coherente. Otras
   personas (o t√∫ mismo en el futuro) podr√°n entender r√°pidamente que se est√° haciendo referencia a un servicio definido
   en `Docker Compose`.


3. `Escalabilidad`: Si en el futuro decides escalar tu servicio (por ejemplo, ejecutando m√∫ltiples instancias de un
   mismo microservicio), podr√≠as enfrentar problemas si est√°s utilizando `container_name`. Esto se debe a que Docker
   Compose genera nombres √∫nicos para cada contenedor basado en el nombre del servicio y el n√∫mero de instancia (por
   ejemplo, `s-user-service_1`, `s-user-service_2`, etc.), lo que significa que el `container_name` no ser√° el mismo
   para todas las instancias y no podr√°s referenciarlo de manera uniforme.

Por todas estas razones, se recomienda utilizar el nombre del servicio en lugar del `container_name` para la
comunicaci√≥n entre microservicios en `Docker Compose`. Esta pr√°ctica mejora la flexibilidad, escalabilidad y
mantenibilidad de tu aplicaci√≥n.

A partir de lo mencionado, vamos a actualizar nuestras variables de entorno para usar el nombre del servicio en lugar
del nombre del contenedor. Esto es especialmente importante ahora que estamos trabajando con `Docker Compose` y nos
beneficiaremos del sistema de resoluci√≥n de nombres que ofrece.

A continuaci√≥n, se muestra el contenido actualizado del archivo `.env` del microservicio `course-service`, el cual se
conecta a los servicios `s-postgres` y `s-user-service`:

````bash
# Container
CONTAINER_PORT=8002

# Database
DB_HOST=s-postgres
DB_PORT=5432
DB_NAME=db_course_service
DB_USERNAME=postgres
DB_PASSWORD=magadiflo

# Communication with microservice user-service
USER_SERVICE_HOST=s-user-service
USER_SERVICE_PORT=8001
````

Lo mismo haremos en el archivo `.env` del microservicio `user-service`.

````bash
# Container
CONTAINER_PORT=8001
SPRING_PROFILES_ACTIVE=default

# Database
DB_HOST=s-mysql
DB_PORT=3306
DB_NAME=db_user_service
DB_USERNAME=admin
DB_PASSWORD=magadiflo

# Communication with microservice course-service
COURSE_SERVICE_HOST=s-course-service
COURSE_SERVICE_PORT=8002
````

Antes de ejecutar `docker compose` es necesario detener los contenedores que anteriormente hab√≠amos ejecutado. Para
eso simplemente ejecutamos:

````bash
$ docker compose down
````

Volvemos a ejecutar el comando de `docker compose` para levantar los contenedores.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-11)
$ docker compose up -d                                                                                     
[+] Running 4/4                                                                                            
 ‚úî Container c-postgres        Healthy                                                                     
 ‚úî Container c-mysql           Healthy                                                                     
 ‚úî Container c-user-service    Started                                                                     
 ‚úî Container c-course-service  Started                                                                     
````

Verificamos que los contenedores se han levantado correctamente.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE                   COMMAND                  CREATED              STATUS                        PORTS                               NAMES
37873d9cf7dd   course-service:latest   "/__cacert_entrypoin‚Ä¶"   About a minute ago   Up About a minute             0.0.0.0:8002->8002/tcp              c-course-service
4888af62bd30   user-service:latest     "/__cacert_entrypoin‚Ä¶"   About a minute ago   Up About a minute             0.0.0.0:8001->8001/tcp              c-user-service
d0e6f0411ce9   postgres:17-alpine      "docker-entrypoint.s‚Ä¶"   About a minute ago   Up About a minute (healthy)   0.0.0.0:5433->5432/tcp              c-postgres
9fbe6ecfa2a6   mysql:8.0.41-debian     "docker-entrypoint.s‚Ä¶"   About a minute ago   Up About a minute (healthy)   33060/tcp, 0.0.0.0:3307->3306/tcp   c-mysql
````

Ahora realizamos una petici√≥n al backend donde vemos la interacci√≥n de los 4 contenedores.

````bash
$ curl -v -G --data "loadRelations=true" http://localhost:8002/api/v1/courses | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Fri, 13 Jun 2025 05:12:36 GMT
<
[
  {
    "id": 1,
    "name": "Spring Boot 3",
    "users": [
      {
        "id": 4,
        "name": "Kiara",
        "email": "kiara@gmail.com",
        "password": "123456"
      },
      {
        "id": 5,
        "name": "Milagros",
        "email": "milagros@gmail.com",
        "password": "123456"
      }
    ]
  },
  {
    "id": 2,
    "name": "Spring WebFlux",
    "users": [
      {
        "id": 6,
        "name": "Susana",
        "email": "susana@gmail.com",
        "password": "123456"
      }
    ]
  },
  {...}
]
````

Como resultado vemos que nos est√° trayendo los datos solicitados. De esta manera comprobamos que el
`usar el nombre de los servicios` s√≠ est√° funcionando sin problemas.

### üìå Eliminando contenedores creados con docker compose (`docker compose down`)

Finalmente, dec√≠amos que para eliminar los contenedores creados con `docker compose` deb√≠amos ejecutar el comando
`docker compose down`, pero hasta ahora no he mostrado un ejemplo. As√≠ que vamos a eliminar los cuatro contenedores
que creamos anteriormente con `docker compose`.

Listando los cuatro contenedores creados anteriormente con docker compose.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE                   COMMAND                  CREATED         STATUS                   PORTS                               NAMES
37873d9cf7dd   course-service:latest   "/__cacert_entrypoin‚Ä¶"   6 minutes ago   Up 6 minutes             0.0.0.0:8002->8002/tcp              c-course-service
4888af62bd30   user-service:latest     "/__cacert_entrypoin‚Ä¶"   6 minutes ago   Up 6 minutes             0.0.0.0:8001->8001/tcp              c-user-service
d0e6f0411ce9   postgres:17-alpine      "docker-entrypoint.s‚Ä¶"   6 minutes ago   Up 6 minutes (healthy)   0.0.0.0:5433->5432/tcp              c-postgres
9fbe6ecfa2a6   mysql:8.0.41-debian     "docker-entrypoint.s‚Ä¶"   6 minutes ago   Up 6 minutes (healthy)   33060/tcp, 0.0.0.0:3307->3306/tcp   c-mysql
````

Procedemos a eliminar los contenedores usando el comando `docker compose down`.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-11)
$ docker compose down                                                                                      
[+] Running 4/4                                                                                            
 ‚úî Container c-course-service  Removed                                                                     
 ‚úî Container c-user-service    Removed                                                                     
 ‚úî Container c-postgres        Removed                                                                     
 ‚úî Container c-mysql           Removed                                                                                                                                     
````

Si listamos los contenedores veremos que ya no tenemos ninguno.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
````
