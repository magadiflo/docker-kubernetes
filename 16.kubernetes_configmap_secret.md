# Sección 16: Kubernetes: ConfigMap y Secret - Configuración centralizada

---

## [ConfigMaps](https://kubernetes.io/docs/concepts/configuration/configmap/)

Un `ConfigMap` es un *objeto de la API de Kubernetes que se utiliza para almacenar datos de configuración no
confidenciales en forma de pares `clave-valor`*. Los pods pueden consumir un `ConfigMap` de distintas formas:

- Como variables de entorno.
- Argumentos en la línea de comandos.
- Archivos montados dentro del contenedor mediante un volumen.

Los `ConfigMap` permiten desacoplar la configuración específica del entorno del código fuente o de la imagen del
contenedor, facilitando así la portabilidad y reutilización de las aplicaciones entre distintos entornos (desarrollo,
pruebas, producción, etc.).

⚠️ Precaución
> Un `ConfigMap` `no proporciona confidencialidad ni cifrado`. Si necesitas almacenar información sensible (como
> contraseñas, tokens o claves de acceso), debes usar un objeto `Secret`, o bien emplear herramientas adicionales para
> mantener los datos protegidos.

Se recomienda utilizar `ConfigMaps` para mantener la configuración separada del código de la aplicación. Esto promueve
buenas prácticas como el principio de configuración externa, uno de los pilares de las aplicaciones modernas y
escalables.

### Ejemplo práctico

Imagina que estás desarrollando una aplicación que se ejecuta localmente durante el desarrollo y en la nube para el
entorno productivo. En lugar de codificar directamente las direcciones de los servicios, configuras tu aplicación para
que lea una variable de entorno llamada `DATABASE_HOST`.

- En desarrollo local, esa variable podría tener el valor `localhost`.
- En producción, la variable podría apuntar al nombre de un servicio de Kubernetes que expone la base de datos dentro
  del clúster.

Gracias al `ConfigMap`, puedes reutilizar exactamente la misma imagen de contenedor en ambos entornos, modificando
únicamente los valores de configuración.

ℹ️ Nota
> Un `ConfigMap` no está diseñado para almacenar grandes volúmenes de datos. El tamaño total de los datos almacenados no
> debe exceder `1 MiB`. Si necesitas administrar configuraciones más grandes, considera otras alternativas como montar
> un volumen, usar un almacenamiento externo o una base de datos.

## [Secrets](https://kubernetes.io/docs/concepts/configuration/secret/)

Un `Secret` es un *objeto de la API de Kubernetes que se utiliza para almacenar y gestionar información sensible*, como
contraseñas, tokens, claves SSH, certificados u otros datos privados.

Este tipo de objeto permite *evitar incluir datos confidenciales directamente en los manifiestos de los Pods o en las
imágenes de contenedor*, mejorando así la seguridad general de la aplicación y del clúster.

Diferencia clave respecto a `ConfigMaps`
> Aunque los `Secrets` son similares a los `ConfigMaps` en estructura y uso, están específicamente diseñados para
> manejar datos sensibles, con medidas de seguridad adicionales.

### Ventajas del uso de Secrets

- `Separación de responsabilidades`: los secretos pueden definirse y gestionarse de forma independiente al resto de los
  recursos del clúster.
- `Reducción del riesgo de exposición`: como los `Secrets` no necesitan estar embebidos en los `Pods`, se evita que los
  datos sensibles se expongan durante el ciclo de vida del despliegue.
- Tratamiento más seguro: `Kubernetes` puede tomar precauciones adicionales, como evitar que los secretos se escriban en
  disco (dependiendo de la configuración del nodo), o restringir su visibilidad a través de `RBAC`.

### Formas de consumo

Los `Secrets` pueden ser consumidos por los `Pods` de las siguientes maneras:

- Como variables de entorno.
- Montados como archivos dentro de un volumen.
- Referenciados directamente desde las definiciones de contenedores, por ejemplo, para configurar credenciales.

### Consideraciones adicionales

- Por defecto, los datos dentro de un `Secret` están codificados en `Base64`, lo que no implica cifrado real. Se
  recomienda habilitar el cifrado en reposo en el clúster de `Kubernetes` y usar controles de acceso adecuados.
- También se puede integrar `Kubernetes` con soluciones externas de gestión de secretos, como `HashiCorp Vault`,
  `AWS Secrets Manager`, `Azure Key Vault`, entre otros, para obtener mayor control y seguridad.

## Agregando ConfigMaps para los microservicios

A continuación, definimos los archivos `ConfigMap` para los microservicios de usuarios y cursos,
`con el fin de centralizar la configuración no confidencial` de cada uno.

`configmap-user.yml`

````yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cm-user-service
data:
  container_port: '8001'
  db_host: s-mysql
  db_port: '3306'
  db_name: db_user_service
  db_username: admin
  db_password: magadiflo
  course_service_host: s-course-service
  course_service_port: '8002'
````

`configmap-course.yml`

````yml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cm-course-service
data:
  container_port: '8002'
  db_host: s-postgres
  db_port: '5432'
  db_name: db_course_service
  db_username: postgres
  db_password: magadiflo
  user_service_host: s-user-service
  user_service_port: '8001'
````

Explicación

- Como vimos previamente, un `ConfigMap` permite `almacenar datos de configuración no confidenciales` en forma de pares
  `clave-valor`.
- En este caso, estamos almacenando:
    - Configuración de la base de datos (`host`, `puerto`, `nombre`, `usuario` y `contraseña`).
    - Información para la comunicación entre microservicios (`host` y` puerto del servicio relacionado`).
- Las claves definidas en el `ConfigMap` pueden ir en minúsculas porque simplemente representan nombres de
  configuración dentro del par `clave-valor` (por ejemplo, `db_host: s-postgres`).
- Las variables de entorno reales se definirán luego en el `Deployment`, donde puedes mapear una variable en
  mayúsculas (como `DB_HOST`) a la clave del `ConfigMap` (`db_host`). Es allí donde se establece la relación entre
  ambas.

> ⚠️ `Importante`: Aunque en este ejemplo se están incluyendo `db_username` y `db_password` dentro del `ConfigMap`,
> en la práctica estos datos deberían manejarse con un objeto `Secret`, ya que contienen información sensible.
> Este cambio se implementará más adelante en la lección correspondiente.

### Aplicando los ConfigMaps al clúster

Una vez creados los archivos `YAML`, aplicamos ambos `ConfigMap` con el siguiente comando:

````bash
$ kubectl apply -f .\kubernetes\configmaps\configmap-course.yml -f .\kubernetes\configmaps\configmap-user.yml
configmap/cm-course-service created
configmap/cm-user-service created
````

Luego, listándolos, verificamos que los `configMaps` hayan sido creados.

````bash
$ kubectl get configMap
NAME                DATA   AGE
cm-course-service   8      22s
cm-user-service     8      22s
kube-root-ca.crt    1      14d
````

En la columna `DATA` se muestra la cantidad de `claves (key)` definidas en el bloque `data:` del `ConfigMap`.
Por ejemplo, `cm-user-service` contiene `8` pares `clave-valor`, por lo tanto, su valor en la columna `DATA` es `8`.

## Uso de ConfigMaps en los Pods de los Deployments

Podemos configurar un `Pod` para que consuma valores desde un `ConfigMap`, lo cual permite que los contenedores
utilicen esos datos como variables de entorno, sin necesidad de codificarlos directamente dentro del manifiesto.

En este caso, vamos a usar los `ConfigMaps` definidos anteriormente para inyectar la configuración dentro de los
contenedores de nuestros microservicios, a través de los `Deployment`.

### Configuración del Deployment del microservicio de usuarios

A continuación se muestra el contenido del archivo `deployment-user.yml`, donde configuramos el contenedor para que
obtenga los valores para sus variables de entorno desde el `ConfigMap` llamado `cm-user-service`.

````yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: d-user-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: d-user-service
  template:
    metadata:
      labels:
        app: d-user-service
    spec:
      containers:
        - image: magadiflo/user-service:latest
          name: c-user-service
          ports:
            - containerPort: 8001
          env:
            - name: CONTAINER_PORT
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: container_port
            - name: DB_HOST
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_host
            - name: DB_PORT
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_port
            - name: DB_NAME
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_name
            - name: DB_USERNAME
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_username
            - name: DB_PASSWORD
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_password
            - name: COURSE_SERVICE_HOST
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: course_service_host
            - name: COURSE_SERVICE_PORT
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: course_service_port
````

**Explicación**

- La clave `env` dentro de `spec.containers` permite definir variables de entorno para el contenedor.
- La instrucción `valueFrom.configMapKeyRef` indica que el valor será tomado desde un `ConfigMap`.
- `configMapKeyRef.name` especifica el nombre del `ConfigMap` desde el cual se extraerá el valor (en este caso,
  `cm-user-service`).
- `configMapKeyRef.key` indica la clave específica dentro del `ConfigMap` cuyo valor será asignado a la variable de
  entorno definida en `name`.

Por ejemplo:

````yml
- name: DB_HOST
  valueFrom:
    configMapKeyRef:
      name: cm-user-service
      key: db_host
````

Significa que la variable de entorno `DB_HOST` dentro del contenedor tomará el valor asignado a la clave `db_host`
en el `ConfigMap` `cm-user-service`.

### Configuración del Deployment del microservicio de cursos

````yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: d-course-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: d-course-service
  template:
    metadata:
      labels:
        app: d-course-service
    spec:
      containers:
        - image: magadiflo/course-service:latest
          name: c-course-service
          ports:
            - containerPort: 8002
          env:
            - name: CONTAINER_PORT
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: container_port
            - name: DB_HOST
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: db_host
            - name: DB_PORT
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: db_port
            - name: DB_NAME
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: db_name
            - name: DB_USERNAME
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: db_username
            - name: DB_PASSWORD
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: db_password
            - name: USER_SERVICE_HOST
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: user_service_host
            - name: USER_SERVICE_PORT
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: user_service_port
````

### Configuración del Deployment de la base de datos Postgres

````yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: d-postgres
spec:
  replicas: 1
  selector:
    matchLabels:
      app: d-postgres
  template:
    metadata:
      labels:
        app: d-postgres
    spec:
      containers:
        - image: postgres:17-alpine
          name: c-postgres
          ports:
            - containerPort: 5432
          env:
            - name: POSTGRES_DB
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: db_name
            - name: POSTGRES_USER
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: db_username
            - name: POSTGRES_PASSWORD
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: db_password
          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
      volumes:
        - name: postgres-data
          persistentVolumeClaim:
            claimName: pvc-postgres
````

### Configuración del Deployment de la base de datos de MySQL

````yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: d-mysql
spec:
  replicas: 1
  selector:
    matchLabels:
      app: d-mysql
  template:
    metadata:
      labels:
        app: d-mysql
    spec:
      containers:
        - image: mysql:8.0.41-debian
          name: c-mysql
          ports:
            - containerPort: 3306
          env:
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_password
            - name: MYSQL_DATABASE
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_name
            - name: MYSQL_USER
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_username
            - name: MYSQL_PASSWORD
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_password
          volumeMounts:
            - name: mysql-data
              mountPath: /var/lib/mysql
      volumes:
        - name: mysql-data
          persistentVolumeClaim:
            claimName: pvc-mysql
````

## Aplica cambios en los deployments

Una vez configurados los archivos `Deployment`, es momento de aplicar los cambios al clúster. Para ello, ejecutamos
el siguiente comando:

````bash
$ kubectl apply -f .\kubernetes\deployments\deployment-mysql.yml -f .\kubernetes\deployments\deployment-postgres.yml -f .\kubernetes\deployments\deployment-user.yml -f .\kubernetes\deployments\deployment-course.yml
deployment.apps/d-mysql configured
deployment.apps/d-postgres configured
deployment.apps/d-user-service configured
deployment.apps/d-course-service configured
````

### Verificar los Pods en ejecución

Listamos los pods para verificar que se hayan creado (o actualizado) correctamente:

````bash
$ kubectl get pods
NAME                                READY   STATUS    RESTARTS      AGE
d-course-service-5cfb4f4dd5-rlxxf   1/1     Running   0             77s
d-mysql-5b458669cf-jwkcc            1/1     Running   0             77s
d-postgres-75895cdd44-kpvnf         1/1     Running   1 (14s ago)   77s
d-user-service-55fbf67cf4-f7dbd     1/1     Running   0             77s
````

### Inspeccionar el contenido del Pod

Podemos usar el comando `kubectl describe pod` para inspeccionar un `pod` en detalle. Esto nos permite verificar
si las variables de entorno han sido correctamente asociadas desde el `ConfigMap`.

````bash
$ kubectl describe pod d-user-service-55fbf67cf4-f7dbd
Name:             d-user-service-55fbf67cf4-f7dbd
Namespace:        default
Priority:         0
Service Account:  default
Node:             minikube/192.168.49.2
Start Time:       Sun, 03 Aug 2025 20:11:17 -0500
Labels:           app=d-user-service
                  pod-template-hash=55fbf67cf4
Annotations:      <none>
Status:           Running
IP:               10.244.0.97
IPs:
  IP:           10.244.0.97
Controlled By:  ReplicaSet/d-user-service-55fbf67cf4
Containers:
  c-user-service:
    Container ID:   docker://3bb52bc2e4577997a6f3aefd6ddd6a59b565fedc78556e10548e531595c5cf50
    Image:          magadiflo/user-service:latest
    Image ID:       docker-pullable://magadiflo/user-service@sha256:d0edef392f95e3e3e082745d166f3f86da4fe3d29d86a3300ce0bcfb5ef68a4b
    Port:           8001/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Sun, 03 Aug 2025 20:11:19 -0500
    Ready:          True
    Restart Count:  0
    Environment:
      CONTAINER_PORT:       <set to the key 'container_port' of config map 'cm-user-service'>       Optional: false
      DB_HOST:              <set to the key 'db_host' of config map 'cm-user-service'>              Optional: false
      DB_PORT:              <set to the key 'db_port' of config map 'cm-user-service'>              Optional: false
      DB_NAME:              <set to the key 'db_name' of config map 'cm-user-service'>              Optional: false
      DB_USERNAME:          <set to the key 'db_username' of config map 'cm-user-service'>          Optional: false
      DB_PASSWORD:          <set to the key 'db_password' of config map 'cm-user-service'>          Optional: false
      COURSE_SERVICE_HOST:  <set to the key 'course_service_host' of config map 'cm-user-service'>  Optional: false
      COURSE_SERVICE_PORT:  <set to the key 'course_service_port' of config map 'cm-user-service'>  Optional: false
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-cr84b (ro)
Conditions:
  Type                        Status
  PodReadyToStartContainers   True
  Initialized                 True
  Ready                       True
  ContainersReady             True
  PodScheduled                True
Volumes:
  kube-api-access-cr84b:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    Optional:                false
    DownwardAPI:             true
QoS Class:                   BestEffort
Node-Selectors:              <none>
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age    From               Message
  ----    ------     ----   ----               -------
  Normal  Scheduled  6m     default-scheduler  Successfully assigned default/d-user-service-55fbf67cf4-f7dbd to minikube
  Normal  Pulling    5m59s  kubelet            Pulling image "magadiflo/user-service:latest"
  Normal  Pulled     5m58s  kubelet            Successfully pulled image "magadiflo/user-service:latest" in 1.094s (1.094s including waiting). Image size: 270793294 bytes.
  Normal  Created    5m58s  kubelet            Created container: c-user-service
  Normal  Started    5m58s  kubelet            Started container c-user-service
````

La salida anterior nos confirma que cada variable de entorno ha sido correctamente inyectada desde el `ConfigMap`
correspondiente.

### Verificar que la aplicación sigue funcionando

Finalmente, probamos que los servicios sigan funcionando correctamente después de aplicar los cambios:

````bash
$ curl -v -G --data "loadRelations=true" http://127.0.0.1:63850/api/v1/courses/1 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 04 Aug 2025 01:16:17 GMT
<
{
  "id": 1,
  "name": "Spring Boot 3",
  "users": [
    {
      "id": 2,
      "name": "Milagros",
      "email": "milagros@gmail.com",
      "password": "123456"
    }
  ]
}
````

Esto confirma que la aplicación sigue operativa y que los `ConfigMaps` han sido correctamente referenciados en los
`Deployments`.
