# Secci√≥n 16: Kubernetes: ConfigMap y Secret - Configuraci√≥n centralizada

---

## [ConfigMaps](https://kubernetes.io/docs/concepts/configuration/configmap/)

Un `ConfigMap` es un *objeto de la API de Kubernetes que se utiliza para almacenar datos de configuraci√≥n no
confidenciales en forma de pares `clave-valor`*. Los pods pueden consumir un `ConfigMap` de distintas formas:

- Como variables de entorno.
- Argumentos en la l√≠nea de comandos.
- Archivos montados dentro del contenedor mediante un volumen.

Los `ConfigMap` permiten desacoplar la configuraci√≥n espec√≠fica del entorno del c√≥digo fuente o de la imagen del
contenedor, facilitando as√≠ la portabilidad y reutilizaci√≥n de las aplicaciones entre distintos entornos (desarrollo,
pruebas, producci√≥n, etc.).

‚ö†Ô∏è Precauci√≥n
> Un `ConfigMap` `no proporciona confidencialidad ni cifrado`. Si necesitas almacenar informaci√≥n sensible (como
> contrase√±as, tokens o claves de acceso), debes usar un objeto `Secret`, o bien emplear herramientas adicionales para
> mantener los datos protegidos.

Se recomienda utilizar `ConfigMaps` para mantener la configuraci√≥n separada del c√≥digo de la aplicaci√≥n. Esto promueve
buenas pr√°cticas como el principio de configuraci√≥n externa, uno de los pilares de las aplicaciones modernas y
escalables.

### Ejemplo pr√°ctico

Imagina que est√°s desarrollando una aplicaci√≥n que se ejecuta localmente durante el desarrollo y en la nube para el
entorno productivo. En lugar de codificar directamente las direcciones de los servicios, configuras tu aplicaci√≥n para
que lea una variable de entorno llamada `DATABASE_HOST`.

- En desarrollo local, esa variable podr√≠a tener el valor `localhost`.
- En producci√≥n, la variable podr√≠a apuntar al nombre de un servicio de Kubernetes que expone la base de datos dentro
  del cl√∫ster.

Gracias al `ConfigMap`, puedes reutilizar exactamente la misma imagen de contenedor en ambos entornos, modificando
√∫nicamente los valores de configuraci√≥n.

‚ÑπÔ∏è Nota
> Un `ConfigMap` no est√° dise√±ado para almacenar grandes vol√∫menes de datos. El tama√±o total de los datos almacenados no
> debe exceder `1 MiB`. Si necesitas administrar configuraciones m√°s grandes, considera otras alternativas como montar
> un volumen, usar un almacenamiento externo o una base de datos.

## [Secrets](https://kubernetes.io/docs/concepts/configuration/secret/)

Un `Secret` es un *objeto de la API de Kubernetes que se utiliza para almacenar y gestionar informaci√≥n sensible*, como
contrase√±as, tokens, claves SSH, certificados u otros datos privados.

Este tipo de objeto permite *evitar incluir datos confidenciales directamente en los manifiestos de los Pods o en las
im√°genes de contenedor*, mejorando as√≠ la seguridad general de la aplicaci√≥n y del cl√∫ster.

Diferencia clave respecto a `ConfigMaps`
> Aunque los `Secrets` son similares a los `ConfigMaps` en estructura y uso, est√°n espec√≠ficamente dise√±ados para
> manejar datos sensibles, con medidas de seguridad adicionales.

### Ventajas del uso de Secrets

- `Separaci√≥n de responsabilidades`: los secretos pueden definirse y gestionarse de forma independiente al resto de los
  recursos del cl√∫ster.
- `Reducci√≥n del riesgo de exposici√≥n`: como los `Secrets` no necesitan estar embebidos en los `Pods`, se evita que los
  datos sensibles se expongan durante el ciclo de vida del despliegue.
- Tratamiento m√°s seguro: `Kubernetes` puede tomar precauciones adicionales, como evitar que los secretos se escriban en
  disco (dependiendo de la configuraci√≥n del nodo), o restringir su visibilidad a trav√©s de `RBAC`.

### Formas de consumo

Los `Secrets` pueden ser consumidos por los `Pods` de las siguientes maneras:

- Como variables de entorno.
- Montados como archivos dentro de un volumen.
- Referenciados directamente desde las definiciones de contenedores, por ejemplo, para configurar credenciales.

### Consideraciones adicionales

- Por defecto, los datos dentro de un `Secret` est√°n codificados en `Base64`, lo que no implica cifrado real. Se
  recomienda habilitar el cifrado en reposo en el cl√∫ster de `Kubernetes` y usar controles de acceso adecuados.
- Tambi√©n se puede integrar `Kubernetes` con soluciones externas de gesti√≥n de secretos, como `HashiCorp Vault`,
  `AWS Secrets Manager`, `Azure Key Vault`, entre otros, para obtener mayor control y seguridad.

## Agregando ConfigMaps para los microservicios

A continuaci√≥n, definimos los archivos `ConfigMap` para los microservicios de usuarios y cursos,
`con el fin de centralizar la configuraci√≥n no confidencial` de cada uno.

`configmap-user.yml`

````yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cm-user-service
data:
  container_port: '8001'
  db_host: s-mysql
  db_port: '3306'
  db_name: db_user_service
  db_username: admin
  db_password: magadiflo
  course_service_host: s-course-service
  course_service_port: '8002'
````

`configmap-course.yml`

````yml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cm-course-service
data:
  container_port: '8002'
  db_host: s-postgres
  db_port: '5432'
  db_name: db_course_service
  db_username: postgres
  db_password: magadiflo
  user_service_host: s-user-service
  user_service_port: '8001'
````

Explicaci√≥n

- Como vimos previamente, un `ConfigMap` permite `almacenar datos de configuraci√≥n no confidenciales` en forma de pares
  `clave-valor`.
- En este caso, estamos almacenando:
    - Configuraci√≥n de la base de datos (`host`, `puerto`, `nombre`, `usuario` y `contrase√±a`).
    - Informaci√≥n para la comunicaci√≥n entre microservicios (`host` y` puerto del servicio relacionado`).
- Las claves definidas en el `ConfigMap` pueden ir en min√∫sculas porque simplemente representan nombres de
  configuraci√≥n dentro del par `clave-valor` (por ejemplo, `db_host: s-postgres`).
- Las variables de entorno reales se definir√°n luego en el `Deployment`, donde puedes mapear una variable en
  may√∫sculas (como `DB_HOST`) a la clave del `ConfigMap` (`db_host`). Es all√≠ donde se establece la relaci√≥n entre
  ambas.

> ‚ö†Ô∏è `Importante`: Aunque en este ejemplo se est√°n incluyendo `db_username` y `db_password` dentro del `ConfigMap`,
> en la pr√°ctica estos datos deber√≠an manejarse con un objeto `Secret`, ya que contienen informaci√≥n sensible.
> Este cambio se implementar√° m√°s adelante en la lecci√≥n correspondiente.

### Aplicando los ConfigMaps al cl√∫ster

Una vez creados los archivos `YAML`, aplicamos ambos `ConfigMap` con el siguiente comando:

````bash
$ kubectl apply -f .\kubernetes\configmaps\configmap-course.yml -f .\kubernetes\configmaps\configmap-user.yml
configmap/cm-course-service created
configmap/cm-user-service created
````

Luego, list√°ndolos, verificamos que los `configMaps` hayan sido creados.

````bash
$ kubectl get configMap
NAME                DATA   AGE
cm-course-service   8      22s
cm-user-service     8      22s
kube-root-ca.crt    1      14d
````

En la columna `DATA` se muestra la cantidad de `claves (key)` definidas en el bloque `data:` del `ConfigMap`.
Por ejemplo, `cm-user-service` contiene `8` pares `clave-valor`, por lo tanto, su valor en la columna `DATA` es `8`.

## Uso de ConfigMaps en los Pods de los Deployments

Podemos configurar un `Pod` para que consuma valores desde un `ConfigMap`, lo cual permite que los contenedores
utilicen esos datos como variables de entorno, sin necesidad de codificarlos directamente dentro del manifiesto.

En este caso, vamos a usar los `ConfigMaps` definidos anteriormente para inyectar la configuraci√≥n dentro de los
contenedores de nuestros microservicios, a trav√©s de los `Deployment`.

### Configuraci√≥n del Deployment del microservicio de usuarios

A continuaci√≥n se muestra el contenido del archivo `deployment-user.yml`, donde configuramos el contenedor para que
obtenga los valores para sus variables de entorno desde el `ConfigMap` llamado `cm-user-service`.

````yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: d-user-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: d-user-service
  template:
    metadata:
      labels:
        app: d-user-service
    spec:
      containers:
        - image: magadiflo/user-service:latest
          name: c-user-service
          ports:
            - containerPort: 8001
          env:
            - name: CONTAINER_PORT
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: container_port
            - name: DB_HOST
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_host
            - name: DB_PORT
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_port
            - name: DB_NAME
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_name
            - name: DB_USERNAME
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_username
            - name: DB_PASSWORD
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_password
            - name: COURSE_SERVICE_HOST
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: course_service_host
            - name: COURSE_SERVICE_PORT
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: course_service_port
````

**Explicaci√≥n**

- La clave `env` dentro de `spec.containers` permite definir variables de entorno para el contenedor.
- La instrucci√≥n `valueFrom.configMapKeyRef` indica que el valor ser√° tomado desde un `ConfigMap`.
- `configMapKeyRef.name` especifica el nombre del `ConfigMap` desde el cual se extraer√° el valor (en este caso,
  `cm-user-service`).
- `configMapKeyRef.key` indica la clave espec√≠fica dentro del `ConfigMap` cuyo valor ser√° asignado a la variable de
  entorno definida en `name`.

Por ejemplo:

````yml
- name: DB_HOST
  valueFrom:
    configMapKeyRef:
      name: cm-user-service
      key: db_host
````

Significa que la variable de entorno `DB_HOST` dentro del contenedor tomar√° el valor asignado a la clave `db_host`
en el `ConfigMap` `cm-user-service`.

### Configuraci√≥n del Deployment del microservicio de cursos

````yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: d-course-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: d-course-service
  template:
    metadata:
      labels:
        app: d-course-service
    spec:
      containers:
        - image: magadiflo/course-service:latest
          name: c-course-service
          ports:
            - containerPort: 8002
          env:
            - name: CONTAINER_PORT
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: container_port
            - name: DB_HOST
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: db_host
            - name: DB_PORT
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: db_port
            - name: DB_NAME
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: db_name
            - name: DB_USERNAME
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: db_username
            - name: DB_PASSWORD
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: db_password
            - name: USER_SERVICE_HOST
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: user_service_host
            - name: USER_SERVICE_PORT
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: user_service_port
````

### Configuraci√≥n del Deployment de la base de datos Postgres

````yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: d-postgres
spec:
  replicas: 1
  selector:
    matchLabels:
      app: d-postgres
  template:
    metadata:
      labels:
        app: d-postgres
    spec:
      containers:
        - image: postgres:17-alpine
          name: c-postgres
          ports:
            - containerPort: 5432
          env:
            - name: POSTGRES_DB
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: db_name
            - name: POSTGRES_USER
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: db_username
            - name: POSTGRES_PASSWORD
              valueFrom:
                configMapKeyRef:
                  name: cm-course-service
                  key: db_password
          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
      volumes:
        - name: postgres-data
          persistentVolumeClaim:
            claimName: pvc-postgres
````

### Configuraci√≥n del Deployment de la base de datos de MySQL

````yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: d-mysql
spec:
  replicas: 1
  selector:
    matchLabels:
      app: d-mysql
  template:
    metadata:
      labels:
        app: d-mysql
    spec:
      containers:
        - image: mysql:8.0.41-debian
          name: c-mysql
          ports:
            - containerPort: 3306
          env:
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_password
            - name: MYSQL_DATABASE
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_name
            - name: MYSQL_USER
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_username
            - name: MYSQL_PASSWORD
              valueFrom:
                configMapKeyRef:
                  name: cm-user-service
                  key: db_password
          volumeMounts:
            - name: mysql-data
              mountPath: /var/lib/mysql
      volumes:
        - name: mysql-data
          persistentVolumeClaim:
            claimName: pvc-mysql
````

## Aplica cambios en los deployments

Una vez configurados los archivos `Deployment`, es momento de aplicar los cambios al cl√∫ster. Para ello, ejecutamos
el siguiente comando:

````bash
$ kubectl apply -f .\kubernetes\deployments\deployment-mysql.yml -f .\kubernetes\deployments\deployment-postgres.yml -f .\kubernetes\deployments\deployment-user.yml -f .\kubernetes\deployments\deployment-course.yml
deployment.apps/d-mysql configured
deployment.apps/d-postgres configured
deployment.apps/d-user-service configured
deployment.apps/d-course-service configured
````

### Verificar los Pods en ejecuci√≥n

Listamos los pods para verificar que se hayan creado (o actualizado) correctamente:

````bash
$ kubectl get pods
NAME                                READY   STATUS    RESTARTS      AGE
d-course-service-5cfb4f4dd5-rlxxf   1/1     Running   0             77s
d-mysql-5b458669cf-jwkcc            1/1     Running   0             77s
d-postgres-75895cdd44-kpvnf         1/1     Running   1 (14s ago)   77s
d-user-service-55fbf67cf4-f7dbd     1/1     Running   0             77s
````

### Inspeccionar el contenido del Pod

Podemos usar el comando `kubectl describe pod` para inspeccionar un `pod` en detalle. Esto nos permite verificar
si las variables de entorno han sido correctamente asociadas desde el `ConfigMap`.

````bash
$ kubectl describe pod d-user-service-55fbf67cf4-f7dbd
Name:             d-user-service-55fbf67cf4-f7dbd
Namespace:        default
Priority:         0
Service Account:  default
Node:             minikube/192.168.49.2
Start Time:       Sun, 03 Aug 2025 20:11:17 -0500
Labels:           app=d-user-service
                  pod-template-hash=55fbf67cf4
Annotations:      <none>
Status:           Running
IP:               10.244.0.97
IPs:
  IP:           10.244.0.97
Controlled By:  ReplicaSet/d-user-service-55fbf67cf4
Containers:
  c-user-service:
    Container ID:   docker://3bb52bc2e4577997a6f3aefd6ddd6a59b565fedc78556e10548e531595c5cf50
    Image:          magadiflo/user-service:latest
    Image ID:       docker-pullable://magadiflo/user-service@sha256:d0edef392f95e3e3e082745d166f3f86da4fe3d29d86a3300ce0bcfb5ef68a4b
    Port:           8001/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Sun, 03 Aug 2025 20:11:19 -0500
    Ready:          True
    Restart Count:  0
    Environment:
      CONTAINER_PORT:       <set to the key 'container_port' of config map 'cm-user-service'>       Optional: false
      DB_HOST:              <set to the key 'db_host' of config map 'cm-user-service'>              Optional: false
      DB_PORT:              <set to the key 'db_port' of config map 'cm-user-service'>              Optional: false
      DB_NAME:              <set to the key 'db_name' of config map 'cm-user-service'>              Optional: false
      DB_USERNAME:          <set to the key 'db_username' of config map 'cm-user-service'>          Optional: false
      DB_PASSWORD:          <set to the key 'db_password' of config map 'cm-user-service'>          Optional: false
      COURSE_SERVICE_HOST:  <set to the key 'course_service_host' of config map 'cm-user-service'>  Optional: false
      COURSE_SERVICE_PORT:  <set to the key 'course_service_port' of config map 'cm-user-service'>  Optional: false
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-cr84b (ro)
Conditions:
  Type                        Status
  PodReadyToStartContainers   True
  Initialized                 True
  Ready                       True
  ContainersReady             True
  PodScheduled                True
Volumes:
  kube-api-access-cr84b:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    Optional:                false
    DownwardAPI:             true
QoS Class:                   BestEffort
Node-Selectors:              <none>
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age    From               Message
  ----    ------     ----   ----               -------
  Normal  Scheduled  6m     default-scheduler  Successfully assigned default/d-user-service-55fbf67cf4-f7dbd to minikube
  Normal  Pulling    5m59s  kubelet            Pulling image "magadiflo/user-service:latest"
  Normal  Pulled     5m58s  kubelet            Successfully pulled image "magadiflo/user-service:latest" in 1.094s (1.094s including waiting). Image size: 270793294 bytes.
  Normal  Created    5m58s  kubelet            Created container: c-user-service
  Normal  Started    5m58s  kubelet            Started container c-user-service
````

La salida anterior nos confirma que cada variable de entorno ha sido correctamente inyectada desde el `ConfigMap`
correspondiente.

### Verificar que la aplicaci√≥n sigue funcionando

Finalmente, probamos que los servicios sigan funcionando correctamente despu√©s de aplicar los cambios:

````bash
$ curl -v -G --data "loadRelations=true" http://127.0.0.1:63850/api/v1/courses/1 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 04 Aug 2025 01:16:17 GMT
<
{
  "id": 1,
  "name": "Spring Boot 3",
  "users": [
    {
      "id": 2,
      "name": "Milagros",
      "email": "milagros@gmail.com",
      "password": "123456"
    }
  ]
}
````

Esto confirma que la aplicaci√≥n sigue operativa y que los `ConfigMaps` han sido correctamente referenciados en los
`Deployments`.

## [Agregando Secrets](https://kubernetes.io/docs/concepts/configuration/secret/)

Recordemos que los objetos `ConfigMap` no est√°n dise√±ados para almacenar datos confidenciales, ya que no aplican ning√∫n
mecanismo de encriptaci√≥n o restricci√≥n de acceso por defecto. Si los datos que deseamos almacenar son sensibles, como
contrase√±as o credenciales, debemos utilizar un objeto `Secret`.

Un `Secret` es un recurso de `Kubernetes` dise√±ado espec√≠ficamente para contener peque√±as cantidades de datos sensibles,
como contrase√±as, tokens o claves de acceso. Al usar `Secrets`, evitamos incluir datos privados directamente en el
c√≥digo fuente o en los manifiestos de despliegue.

### Objetivo de esta lecci√≥n

Hasta este punto, hemos almacenado temporalmente las credenciales de conexi√≥n a las bases de datos dentro de los
`ConfigMaps`. Sin embargo, como se trata de informaci√≥n sensible, a partir de ahora las moveremos a archivos `Secret`,
uno para cada microservicio.

### Tipos de Secret

Al crear un `Secret`, se puede especificar su tipo mediante el campo `type`. Esto ayuda a `Kubernetes` (y a las
herramientas que lo usan) a saber c√≥mo debe tratar los datos.

`Kubernetes` incluye algunos tipos integrados `(built-in)` para casos comunes:

| Tipo integrado (`type`)               | Uso t√≠pico                                  |
|---------------------------------------|---------------------------------------------|
| `Opaque`                              | Datos arbitrarios definidos por el usuario. |
| `kubernetes.io/service-account-token` | Token de cuenta de servicio.                |
| `kubernetes.io/dockerconfigjson`      | Credenciales para registro de im√°genes.     |
| ...                                   | ...                                         |

> Si no se especifica el `type`, el valor predeterminado es `Opaque`.

### Archivos Secret para los microservicios

`secret-user.yml`

````yml
apiVersion: v1
kind: Secret
metadata:
  name: sec-user-service
type: Opaque
data:
  db_username: YWRtaW4=     #admin
  db_password: bWFnYWRpZmxv #magadiflo
````

`secret-course.yml`

````yml
apiVersion: v1
kind: Secret
metadata:
  name: sec-course-service
type: Opaque
data:
  db_username: cG9zdGdyZXM=   #postgres
  db_password: bWFnYWRpZmxv   #magadiflo
````

**D√≥nde**

- `type: Opaque` indica que se trata de un secreto gen√©rico definido por el usuario.
- Los valores de las claves (`db_username`, `db_password`) deben estar codificados en `Base64`, no en texto plano. Por
  ejemplo:
    - `admin` ‚Üí `YWRtaW4=`
    - `magadiflo` ‚Üí `bWFnYWRpZmxv`
- Podemos usar herramientas en l√≠nea como [base64encode](https://www.base64encode.org/) o ejecutar el siguiente comando
  en `Git Bash`, `WSL` o `Linux/macOS`:
  ````bash
  $ echo -n "admin" | base64
  ````

‚ö†Ô∏è Importante 1
> En `Windows PowerShell` o `CMD`, el comando `echo -n` no funciona correctamente porque `echo` no interpreta `-n`
> como una opci√≥n. En ese caso, se recomienda utilizar `Git Bash`, `WSL` o una terminal compatible.

‚ö†Ô∏è Importante 2
> Ahora que hemos creado archivos `Secret` para almacenar las credenciales de conexi√≥n, debemos eliminar esos datos
> confidenciales de los `ConfigMaps` (`db_username` y `db_password`), ya que su lugar adecuado es el `Secret`.

## Configurar secretos en los pods de los Deployments

Una vez creados los archivos `Secret` para nuestros microservicios, es momento de utilizarlos dentro de los
`Deployments`. La forma de hacerlo es a trav√©s de la propiedad `env.valueFrom.secretKeyRef`, que permite inyectar
valores directamente desde un `Secret` como variables de entorno.

A continuaci√≥n, mostraremos c√≥mo se configura cada uno de los archivos `Deployment`.

`deployment-user.yml`. Configuramos el contenedor del microservicio `user-service` para que obtenga las credenciales de
conexi√≥n desde el `Secret` llamado `sec-user-service`:

````yml
#...
env:
  #...
  - name: DB_USERNAME
    valueFrom:
      secretKeyRef:
        name: sec-user-service
        key: db_username
  - name: DB_PASSWORD
    valueFrom:
      secretKeyRef:
        name: sec-user-service
        key: db_password
#...
````

`deployment-course.yml`. De manera similar, configuramos el contenedor del microservicio `course-service` para usar el
`Secret` `sec-course-service`:

````yml
#...
env:
  #...
  - name: DB_USERNAME
    valueFrom:
      secretKeyRef:
        name: sec-course-service
        key: db_username
  - name: DB_PASSWORD
    valueFrom:
      secretKeyRef:
        name: sec-course-service
        key: db_password
#...
````

`deployment-mysql.yml`. El contenedor del servicio de base de datos `MySQL` tambi√©n necesita acceder a credenciales.
Aqu√≠ se reutiliza el `Secret` `sec-user-service` para inyectar las variables correspondientes al entorno de `MySQL`:

````yml
#...
spec:
  containers:
    - image: mysql:8.0.41-debian
      name: c-mysql
      ports:
        - containerPort: 3306
      env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: sec-user-service
              key: db_password
        - name: MYSQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: cm-user-service
              key: db_name
        - name: MYSQL_USER
          valueFrom:
            secretKeyRef:
              name: sec-user-service
              key: db_username
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: sec-user-service
              key: db_password
#...
````

`deployment-postgres.yml`. Por √∫ltimo, configuramos el contenedor de la base de datos `PostgreSQL` para que utilice el
`Secret` `sec-course-service`:

````yml
#...
spec:
  containers:
    - image: postgres:17-alpine
      name: c-postgres
      ports:
        - containerPort: 5432
      env:
        - name: POSTGRES_DB
          valueFrom:
            configMapKeyRef:
              name: cm-course-service
              key: db_name
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: sec-course-service
              key: db_username
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: sec-course-service
              key: db_password
#...
````

### üîç ¬øQu√© estamos haciendo aqu√≠?

- `secretKeyRef`: Nos permite acceder a un valor almacenado en un `Secret`. Este valor se inyecta como una variable de
  entorno.
- `name`: Es el nombre del `Secret` al que se hace referencia.
- `key`: Es la clave dentro del `Secret` cuyo valor queremos usar.

> ‚ö†Ô∏è Aseg√∫rate de que los nombres de los `Secrets` y las claves (`db_username`, `db_password`, etc.) coincidan
> exactamente con los definidos en tus archivos `Secret`. `Kubernetes` no hace validaci√≥n autom√°tica y fallar√°
> silenciosamente si hay errores de nombre.
