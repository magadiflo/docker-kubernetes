# Sección 09: Docker Networks - Comunicación entre contenedores - Volúmenes

---

## Dockerizando course-service

### En el course-service

Hasta ahora el microservicio `course-service` lo hemos estado trabajando sin dockerizar, así que en este apartado
lo dockerizaremos. El primer cambio que haremos será modificar la `url` de conexión de la base de datos. Como el
`course-service` estará dockerizada, necesitamos que apunte a la base de datos de nuestra máquina local, eso lo
logramos reemplazando el `localhost` con el dominio especial de docker `host.docker.internal`.

````yml
spring:
  application:
    name: course-service
  datasource:
    url: jdbc:postgresql://host.docker.internal:5432/db_course_service
````

> Más adelante, veremos cómo dockerizar las bases de datos de `PostgreSQL` y `MySQL` para que tengamos toda la
> aplicación 100% dockerizada.

Recordemos que nuestro `course-service` se comunica con el microservicio `user-service` usando el `RestClient`.

Como ahora trabajaremos con contenedores Docker ejecutados manualmente, necesitamos modificar la URL del microservicio
`user-service` para que la comunicación desde `course-service` funcione correctamente dentro de la red de `Docker`.

Esta modificación se realiza en el archivo `application.yml` del `course-service`:

````yml
custom:
  user-service:
    base-url: http://c-user-service:8001/api/v1/users
````

Donde:

- `c-user-service` es el nombre del contenedor que le asignaremos al microservicio `user-service` al momento de
  ejecutarlo con la opción `--name` en el comando `docker container run`.
- El puerto `8001` corresponde al puerto expuesto dentro del contenedor, es decir, el puerto en el que la aplicación
  `user-service` `está escuchando internamente`.
- Para que este nombre (`c-user-service`) sea accesible desde otros contenedores, ambos contenedores (`user-service` y
  `course-service`) deben estar conectados a la misma red personalizada de `Docker`, la cual se puede crear con el
  comando `docker network create`.

Ahora, crearemos el `Dockerfile` para el microservicio `course-service`. Notar que tiene los mismos comandos que
usamos en el `Dockerfile` del microservicio `user-service`, con la única diferencia que aquí estamos exponiendo el
puerto `8002` correspondiente al `courser-service`.

````dockerfile
FROM eclipse-temurin:21-jdk-alpine AS dependencies
WORKDIR /app
COPY ./mvnw ./
COPY ./.mvn ./.mvn
COPY ./pom.xml ./
RUN sed -i -e 's/\r$//' ./mvnw
RUN ./mvnw dependency:go-offline
COPY ./src ./src
RUN ./mvnw clean package -DskipTests

FROM eclipse-temurin:21-jre-alpine AS builder
WORKDIR /app
COPY --from=dependencies /app/target/*.jar ./app.jar
RUN java -Djarmode=layertools -jar app.jar extract

FROM eclipse-temurin:21-jre-alpine AS runner
WORKDIR /app
RUN mkdir ./logs
COPY --from=builder /app/dependencies ./
COPY --from=builder /app/spring-boot-loader ./
COPY --from=builder /app/snapshot-dependencies ./
COPY --from=builder /app/application ./
EXPOSE 8002
CMD ["java", "org.springframework.boot.loader.launch.JarLauncher"]
````

Ahora que ya tenemos lo necesario, crearemos la imagen del microservicio `course-service`.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-9)                                          
$ docker image build -t course-service .\business-domain\course-service -f .\business-domain\course-service\Dockerfile                              
[+] Building 90.0s (25/25) FINISHED                                                                                                                 
 => [internal] load build definition from Dockerfile                                                                                                
 => => transferring dockerfile: 794B                                                                                                                
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jre-alpine                                                                    
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                                    
 => [auth] library/eclipse-temurin:pull token for registry-1.docker.io                                                                              
 => [internal] load .dockerignore                                                                                                                   
 => => transferring context: 2B                                                                                                                     
 => [dependencies 1/9] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0 
 => => resolve docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0              
 => [internal] load build context                                                                                                                   
 => => transferring context: 50.45kB                                                                                                                
 => [builder 1/4] FROM docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd      
 => => resolve docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd              
 => CACHED [dependencies 2/9] WORKDIR /app                                                                                                          
 => CACHED [dependencies 3/9] COPY ./mvnw ./                                                                                                        
 => CACHED [dependencies 4/9] COPY ./.mvn ./.mvn                                                                                                    
 => [dependencies 5/9] COPY ./pom.xml ./                                                                                                            
 => [dependencies 6/9] RUN sed -i -e 's/\r$//' ./mvnw                                                                                               
 => [dependencies 7/9] RUN ./mvnw dependency:go-offline                                                                                             
 => [dependencies 8/9] COPY ./src ./src                                                                                                             
 => [dependencies 9/9] RUN ./mvnw clean package -DskipTests                                                                                         
 => CACHED [builder 2/4] WORKDIR /app                                                                                                               
 => [builder 3/4] COPY --from=dependencies /app/target/*.jar ./app.jar                                                                              
 => [builder 4/4] RUN java -Djarmode=layertools -jar app.jar extract                                                                                
 => CACHED [runner 3/7] RUN mkdir ./logs                                                                                                            
 => [runner 4/7] COPY --from=builder /app/dependencies ./                                                                                           
 => [runner 5/7] COPY --from=builder /app/spring-boot-loader ./                                                                                     
 => [runner 6/7] COPY --from=builder /app/snapshot-dependencies ./                                                                                  
 => [runner 7/7] COPY --from=builder /app/application ./                                                                                            
 => exporting to image                                                                                                                              
 => => exporting layers                                                                                                                             
 => => exporting manifest sha256:cb3f19bc9b28486a6576dd01e8560550c9f9341971b525b0a378baa7334732e5                                                   
 => => exporting config sha256:375f85e39ad28992a73271a6170ae1ecfdb86f841e2852cdab3b9b68cdedfafe                                                     
 => => exporting attestation manifest sha256:12d1d2e11a2a087e134518c1edf016c31b736ccbe0068f33b02b592b38f4b071                                       
 => => exporting manifest list sha256:5b3c98ddaeb94291f7a9b5d7bda88420097a0c0c2aa1fb2445bb6ec3700b3dbb                                              
 => => naming to docker.io/library/course-service:latest                                                                                            
 => => unpacking to docker.io/library/course-service:latest                                                                                         
                                                                                                                                                    
View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/s1n4dqm8li3l10wy6gm3cqc9l                                          
````

Luego listamos las imágenes y vemos que el nuestro ya se encuentra en la lista.

````bash
$ docker image ls
REPOSITORY       TAG       IMAGE ID       CREATED          SIZE
course-service   latest    5b3c98ddaeb9   58 seconds ago   405MB
````

### En el user-service

Recordemos que nuestro `user-service` se comunica con el microservicio `course-service` usando el `RestClient`.

Como ahora trabajaremos con contenedores Docker ejecutados manualmente, necesitamos modificar la URL del microservicio
`course-service` para que la comunicación desde `user-service` funcione correctamente dentro de la red de `Docker`.

Esta modificación se realiza en el archivo `application.yml` del `user-service`:

````yml
custom:
  course-service:
    base-url: http://c-course-service:8002/api/v1/courses
````

Donde:

- `c-course-service` es el nombre del contenedor que le asignaremos al microservicio `course-service` al momento de
  ejecutarlo con la opción `--name` en el comando `docker container run`.

Luego de realizar la modificación, construimos la imagen para el microservicio `user-service`.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-9)                                         
$ docker image build -t user-service .\business-domain\user-service -f .\business-domain\user-service\Dockerfile                                   
[+] Building 19.4s (25/25) FINISHED                                                                                                                
 => [internal] load build definition from Dockerfile                                                                                               
 => => transferring dockerfile: 794B                                                                                                               
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jre-alpine                                                                   
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                                   
 => [auth] library/eclipse-temurin:pull token for registry-1.docker.io                                                                             
 => [internal] load .dockerignore                                                                                                                  
 => => transferring context: 214B                                                                                                                  
 => [builder 1/4] FROM docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd     
 => => resolve docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd             
 => [dependencies 1/9] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => => resolve docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0             
 => [internal] load build context                                                                                                                  
 => => transferring context: 3.58kB                                                                                                                
 => CACHED [dependencies 2/9] WORKDIR /app                                                                                                         
 => CACHED [dependencies 3/9] COPY ./mvnw ./                                                                                                       
 => CACHED [dependencies 4/9] COPY ./.mvn ./.mvn                                                                                                   
 => CACHED [dependencies 5/9] COPY ./pom.xml ./                                                                                                    
 => CACHED [dependencies 6/9] RUN sed -i -e 's/\r$//' ./mvnw                                                                                       
 => CACHED [dependencies 7/9] RUN ./mvnw dependency:go-offline                                                                                     
 => [dependencies 8/9] COPY ./src ./src                                                                                                            
 => [dependencies 9/9] RUN ./mvnw clean package -DskipTests                                                                                        
 => CACHED [builder 2/4] WORKDIR /app                                                                                                              
 => [builder 3/4] COPY --from=dependencies /app/target/*.jar ./app.jar                                                                             
 => [builder 4/4] RUN java -Djarmode=layertools -jar app.jar extract                                                                               
 => CACHED [runner 3/7] RUN mkdir ./logs                                                                                                           
 => CACHED [runner 4/7] COPY --from=builder /app/dependencies ./                                                                                   
 => CACHED [runner 5/7] COPY --from=builder /app/spring-boot-loader ./                                                                             
 => CACHED [runner 6/7] COPY --from=builder /app/snapshot-dependencies ./                                                                          
 => [runner 7/7] COPY --from=builder /app/application ./                                                                                           
 => exporting to image                                                                                                                             
 => => exporting layers                                                                                                                            
 => => exporting manifest sha256:59200bc008340ce77f4a35b2ff6f063ef9595388c6637be889fa465cfd872b39                                                  
 => => exporting config sha256:00c9435f86d16eb95ff7c0fed865dafb43475c7c6aa999670a776f63a9572d4a                                                    
 => => exporting attestation manifest sha256:2ec9d86ea4fd37586e925abe71d9b5ebafc35df5c5ac06ab113ef668006e4443                                      
 => => exporting manifest list sha256:bb8dcd87e6b2d4ee6390a80a3978b4e78c4748b870b10ad21d237405e7258e82                                             
 => => naming to docker.io/library/user-service:latest                                                                                             
 => => unpacking to docker.io/library/user-service:latest                                                                                          
                                                                                                                                                   
View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/w72ang74tnibnb0u2ama73sjm                                         
````

Hasta este punto, si listamos las imágenes, veremos las dos que acabamos de construir `user-service` y `course-service`.

````bash
$ docker image ls
REPOSITORY       TAG       IMAGE ID       CREATED              SIZE
user-service     latest    bb8dcd87e6b2   About a minute ago   407MB
course-service   latest    5b3c98ddaeb9   6 minutes ago        405MB
````

## Configura la red o network

Listamos las redes para ver cuáles se encuentran creadas por defecto en Docker.

````bash
$ docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
a2b662e2a591   bridge    bridge    local
8c77b18a87f1   host      host      local
fe251eccddcc   none      null      local
````

Dónde

- `bridge`: Red por defecto para contenedores; permite acceso a internet y comunicación entre contenedores conectados,
  pero `no resuelve nombres de contenedores automáticamente`.
- `host`: El contenedor comparte la red del host, sin aislamiento de red; útil para aplicaciones que necesitan el mismo
  stack de red del sistema anfitrión.
- `none`: El contenedor no tiene acceso a ninguna red; se usa cuando necesitas un contenedor completamente aislado a
  nivel de red.

Ahora, para comunicar nuestros microservicios, crearemos una red personalizada llamada `docker-kubernetes-net`.

````bash
$ docker network create docker-kubernetes-net
6946c0fdc9f2f7d5b5f5a9d7a2dd8764b0768866af9565cba9c99659dd9c211d
````

Listamos nuevamente las redes. Vemos que la red `docker-kubernetes-net` está creada correctamente.

````bash
$ docker network ls
NETWORK ID     NAME                    DRIVER    SCOPE
a2b662e2a591   bridge                  bridge    local
6946c0fdc9f2   docker-kubernetes-net   bridge    local
8c77b18a87f1   host                    host      local
fe251eccddcc   none                    null      local
````

💡 Nota:
> Si no creas explícitamente una red en `Docker`, los contenedores se ejecutan en una red por defecto llamada `bridge`.
> Esta red es la configuración estándar para contenedores que no se asocian a una red personalizada. Esta red permite
> acceso a internet, pero `no permite la resolución de nombres entre contenedores`.
>
> Por lo tanto, si deseamos que nuestros contenedores se comuniquen usando sus nombres
> (como `http://c-user-service:8001`), es recomendable usar una red personalizada. En nuestro caso, la red
> personalizada que creamos es `docker-kubernetes-net`.
>
> ✅ Ambas redes son tipo `bridge`, pero se comportan distinto por diseño.
>
> - La red por defecto llamado `bridge` no habilita un sistema de resolución de nombres entre contenedores. Es una red
    "mínima" pensada para contenedores simples o pruebas rápidas. Los contenedores conectados a esta red no pueden
    resolverse por su nombre (`--name`), `solo se ven por IP`. Por eso, para que dos contenedores se comuniquen en esta
    red, tendrías que pasarles la IP del otro (lo cual es frágil y no recomendable).
>
>
> - La red `bridge personalizada` (como `docker-kubernetes-net`), es creada por nosotros mismos con el comando
    `docker network create`. Docker configura automáticamente `un DNS interno` para esta red. Este DNS
    `resuelve los nombres de los contenedores` en esa red. Los contenedores `sí pueden comunicarse usando sus nombres`
    (los que defines con `--name`), como si fuera un mini sistema de nombres interno.

## Comunicación entre contenedores

Creamos los contenedores de nuestros dos microservicios. Observar que estamos agregando la red creada anteriormente
`docker-kubernetes-net`. Además, cada contenedor tiene como `--name` el `c-user-service` y `c-course-service`.
Estos nombres los estamos usando dentro de las configuraciones de nuestros microservicios para que puedan comunicarse
entre sí.

Creamos el contenedor para el `user-service`.

````bash
$ docker container run -d -p 8001:8001 --rm --name c-user-service --network docker-kubernetes-net user-service
f0c5b9399714c7b56cc49326651165ab02b5f8f8d5b1345c18f17d4b07774c37
````

Creamos el contenedor para el `course-serivce`.

````bash
$ docker container run -d -p 8002:8002 --rm --name c-course-service --network docker-kubernetes-net course-service
f7fa93ac69de8d20e6c05a1a4363c36e782136759dbcf0d8b40df59b8c117a7d
````

Podemos inspeccionar la red `docker-kubernetes-net` para ver que los dos contenedores creados anteriormente ya están
asociados a él.

````bash
$ docker network inspect docker-kubernetes-net
[
    {
        "Name": "docker-kubernetes-net",
        "Id": "6946c0fdc9f2f7d5b5f5a9d7a2dd8764b0768866af9565cba9c99659dd9c211d",
        "Created": "2025-05-28T05:07:20.686757576Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv4": true,
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "f0c5b9399714c7b56cc49326651165ab02b5f8f8d5b1345c18f17d4b07774c37": {
                "Name": "c-user-service",
                "EndpointID": "638c6704eb9e2979cbf6a93731c1e9375479fb993fb868d5a5920f7e82a7fe0b",
                "MacAddress": "76:1c:8c:f6:4b:ea",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            },
            "f7fa93ac69de8d20e6c05a1a4363c36e782136759dbcf0d8b40df59b8c117a7d": {
                "Name": "c-course-service",
                "EndpointID": "7948cc25a598080182884149b2d05819392419f993d1fdde72b1e72985484d8a",
                "MacAddress": "26:4d:76:be:52:fd",
                "IPv4Address": "172.18.0.3/16",
                "IPv6Address": ""
            }
        },
        "Options": {
            "com.docker.network.enable_ipv4": "true",
            "com.docker.network.enable_ipv6": "false"
        },
        "Labels": {}
    }
]
````

Después de crear los contenedores, los podemos listar para ver que están levantados correctamente con status `Up`.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE            COMMAND                  CREATED              STATUS              PORTS                    NAMES
f7fa93ac69de   course-service   "/__cacert_entrypoin…"   About a minute ago   Up About a minute   0.0.0.0:8002->8002/tcp   c-course-service
f0c5b9399714   user-service     "/__cacert_entrypoin…"   2 minutes ago        Up 2 minutes        0.0.0.0:8001->8001/tcp   c-user-service
````

Probamos la comunicación entre nuestros dos contenedores simplemente haciendo una petión http hacia el microservicio
de cursos. Este endpoint traerá la información de un curso y los usuarios asociados a dicho curso.

````bash
$ curl -v -G --data "loadRelations=true" http://localhost:8002/api/v1/courses/1 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 29 May 2025 04:24:31 GMT
<
{
  "id": 1,
  "name": "Spring Boot",
  "users": [
    {
      "id": 6,
      "name": "Lesly",
      "email": "lesly@gmail.com",
      "password": "123456"
    }
  ]
}
````

## Dockerizando MySQL

Hasta este punto el `c-user-service` está apuntando hacía `MySQL` que está instalado en mi máquina local. Pero ahora,
vamos a contenerizar `MySQL` para tenerlo dentro de nuestra plataforma de `Docker`. Para eso, necesitamos bajar la
imagen de `MySQL`, así que en nuestra terminal ejecutamos el siguiente comando.

````bash
$ docker pull mysql:8.0.41-debian
````

Donde, `mysql` es el nombre de la imagen y `8.0.41-debian` es el tag o la versión de la imagen.

Si listamos las imágenes, veremos que entre ellas está la imagen bajada de `MySQL`. Por defecto la imagen se baja
desde la plataforma de [Docker Hub.](https://hub.docker.com/)

````bash 
$ docker image ls
REPOSITORY       TAG             IMAGE ID       CREATED        SIZE
user-service     latest          bb8dcd87e6b2   24 hours ago   407MB
course-service   latest          5b3c98ddaeb9   24 hours ago   405MB
mysql            8.0.41-debian   b2252987e0ec   4 months ago   812MB
````

Como ya tenemos la imagen de `MySQL` en nuestra plataforma de `Docker` procedemos a crearle un contenedor.

````bash
$ docker container run -d -p 3307:3306 --name c-mysql -e MYSQL_DATABASE=db_user_service -e MYSQL_ROOT_PASSWORD=magadiflo -e MYSQL_USER=admin -e MYSQL_PASSWORD=magadiflo --network docker-kubernetes-net mysql:8.0.41-debian
566e80c6cdcc26af044e191379190083e38c133ce12f83d7e225d7437a665e93
````

**Donde**

- `-p 3307:3306`, el puerto externo estamos colocando en `3307`, ya que actualmente tenemos `MySQL` instalada en nuestra
  pc local y está corriendo en el puerto `3306`. El puerto interno lo dejamos tal cual `3306`, ya que eso trabaja al
  interno del contenedor, mientras que el externo hace referencia a nuestra máquina local.
- `--name c-mysql`, le damos un nombre al contenedor.
- `--network docker-kubernetes-net`, se conecta el contenedor a la red `Docker` personalizada `docker-kubernetes-net`.
- `-e (--env)`, nos permite establecer variables de entorno. Cada variable de entorno a definir, debe estar precedido
  por la bandera `-e` o `--env`.

**Importante**

- Usuario y contraseña personalizados
    - La imagen oficial de `MySQL` permite crear un usuario adicional (en este caso `admin`) mediante las variables
      `MYSQL_USER` y `MYSQL_PASSWORD`.
    - Este usuario tiene acceso a la base de datos indicada en `MYSQL_DATABASE` (`db_user_service`).
    - La configuración de `MYSQL_ROOT_PASSWORD` es obligatoria aunque usemos un usuario personalizado, porque la imagen
      necesita definir siempre la contraseña del usuario `root` al iniciarse.
- Si no se especifica un volumen, los datos almacenados en la base de datos se perderán al eliminar el contenedor, ya
  que `MySQL` guarda sus datos en el sistema de archivos interno del contenedor, el cual se destruye al eliminarlo.

Listamos los contenedores.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE                 COMMAND                  CREATED          STATUS          PORTS                               NAMES
566e80c6cdcc   mysql:8.0.41-debian   "docker-entrypoint.s…"   6 minutes ago    Up 6 minutes    33060/tcp, 0.0.0.0:3307->3306/tcp   c-mysql
f7fa93ac69de   course-service        "/__cacert_entrypoin…"   25 minutes ago   Up 25 minutes   0.0.0.0:8002->8002/tcp              c-course-service
f0c5b9399714   user-service          "/__cacert_entrypoin…"   26 minutes ago   Up 26 minutes   0.0.0.0:8001->8001/tcp              c-user-service
````

Verificamos si podemos conectarnos desde `DBeaver` hacia nuestro `MySql` contenerizado que se está ejecutando en
el puerto externo `3307`. El resultado debe ser una conexión exitosa.

![01.png](assets/section-09/01.png)

**Importante**
> Si nos sale el siguiente error cuando nos conectamos con `DBeaver` al contenedor de `MySQL`:
>
> `MySQL : Public Key Retrieval is not allowed` lo que debemos hacer es una configuración en el `DBeaver`.
> Vamos a `Ajustes de conexión/Driver properties/allowPublicKeyRetrieval = true`.
>
> [StackOverflow](https://stackoverflow.com/questions/50379839/connection-java-mysql-public-key-retrieval-is-not-allowed)
