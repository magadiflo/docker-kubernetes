# SecciÃ³n 09: Docker Networks - ComunicaciÃ³n entre contenedores - VolÃºmenes

---

## Dockerizando course-service

### En el course-service

Hasta ahora el microservicio `course-service` lo hemos estado trabajando sin dockerizar, asÃ­ que en este apartado
lo dockerizaremos. El primer cambio que haremos serÃ¡ modificar la `url` de conexiÃ³n de la base de datos. Como el
`course-service` estarÃ¡ dockerizada, necesitamos que apunte a la base de datos de nuestra mÃ¡quina local, eso lo
logramos reemplazando el `localhost` con el dominio especial de docker `host.docker.internal`.

````yml
spring:
  application:
    name: course-service
  datasource:
    url: jdbc:postgresql://host.docker.internal:5432/db_course_service
````

> MÃ¡s adelante, veremos cÃ³mo dockerizar las bases de datos de `PostgreSQL` y `MySQL` para que tengamos toda la
> aplicaciÃ³n 100% dockerizada.

Recordemos que nuestro `course-service` se comunica con el microservicio `user-service` usando el `RestClient`.

Como ahora trabajaremos con contenedores Docker ejecutados manualmente, necesitamos modificar la URL del microservicio
`user-service` para que la comunicaciÃ³n desde `course-service` funcione correctamente dentro de la red de `Docker`.

Esta modificaciÃ³n se realiza en el archivo `application.yml` del `course-service`:

````yml
custom:
  user-service:
    base-url: http://c-user-service:8001/api/v1/users
````

Donde:

- `c-user-service` es el nombre del contenedor que le asignaremos al microservicio `user-service` al momento de
  ejecutarlo con la opciÃ³n `--name` en el comando `docker container run`.
- El puerto `8001` corresponde al puerto expuesto dentro del contenedor, es decir, el puerto en el que la aplicaciÃ³n
  `user-service` `estÃ¡ escuchando internamente`.
- Para que este nombre (`c-user-service`) sea accesible desde otros contenedores, ambos contenedores (`user-service` y
  `course-service`) deben estar conectados a la misma red personalizada de `Docker`, la cual se puede crear con el
  comando `docker network create`.

Ahora, crearemos el `Dockerfile` para el microservicio `course-service`. Notar que tiene los mismos comandos que
usamos en el `Dockerfile` del microservicio `user-service`, con la Ãºnica diferencia que aquÃ­ estamos exponiendo el
puerto `8002` correspondiente al `courser-service`.

````dockerfile
FROM eclipse-temurin:21-jdk-alpine AS dependencies
WORKDIR /app
COPY ./mvnw ./
COPY ./.mvn ./.mvn
COPY ./pom.xml ./
RUN sed -i -e 's/\r$//' ./mvnw
RUN ./mvnw dependency:go-offline
COPY ./src ./src
RUN ./mvnw clean package -DskipTests

FROM eclipse-temurin:21-jre-alpine AS builder
WORKDIR /app
COPY --from=dependencies /app/target/*.jar ./app.jar
RUN java -Djarmode=layertools -jar app.jar extract

FROM eclipse-temurin:21-jre-alpine AS runner
WORKDIR /app
RUN mkdir ./logs
COPY --from=builder /app/dependencies ./
COPY --from=builder /app/spring-boot-loader ./
COPY --from=builder /app/snapshot-dependencies ./
COPY --from=builder /app/application ./
EXPOSE 8002
CMD ["java", "org.springframework.boot.loader.launch.JarLauncher"]
````

Ahora que ya tenemos lo necesario, crearemos la imagen del microservicio `course-service`.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-9)                                          
$ docker image build -t course-service .\business-domain\course-service -f .\business-domain\course-service\Dockerfile                              
[+] Building 90.0s (25/25) FINISHED                                                                                                                 
 => [internal] load build definition from Dockerfile                                                                                                
 => => transferring dockerfile: 794B                                                                                                                
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jre-alpine                                                                    
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                                    
 => [auth] library/eclipse-temurin:pull token for registry-1.docker.io                                                                              
 => [internal] load .dockerignore                                                                                                                   
 => => transferring context: 2B                                                                                                                     
 => [dependencies 1/9] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0 
 => => resolve docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0              
 => [internal] load build context                                                                                                                   
 => => transferring context: 50.45kB                                                                                                                
 => [builder 1/4] FROM docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd      
 => => resolve docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd              
 => CACHED [dependencies 2/9] WORKDIR /app                                                                                                          
 => CACHED [dependencies 3/9] COPY ./mvnw ./                                                                                                        
 => CACHED [dependencies 4/9] COPY ./.mvn ./.mvn                                                                                                    
 => [dependencies 5/9] COPY ./pom.xml ./                                                                                                            
 => [dependencies 6/9] RUN sed -i -e 's/\r$//' ./mvnw                                                                                               
 => [dependencies 7/9] RUN ./mvnw dependency:go-offline                                                                                             
 => [dependencies 8/9] COPY ./src ./src                                                                                                             
 => [dependencies 9/9] RUN ./mvnw clean package -DskipTests                                                                                         
 => CACHED [builder 2/4] WORKDIR /app                                                                                                               
 => [builder 3/4] COPY --from=dependencies /app/target/*.jar ./app.jar                                                                              
 => [builder 4/4] RUN java -Djarmode=layertools -jar app.jar extract                                                                                
 => CACHED [runner 3/7] RUN mkdir ./logs                                                                                                            
 => [runner 4/7] COPY --from=builder /app/dependencies ./                                                                                           
 => [runner 5/7] COPY --from=builder /app/spring-boot-loader ./                                                                                     
 => [runner 6/7] COPY --from=builder /app/snapshot-dependencies ./                                                                                  
 => [runner 7/7] COPY --from=builder /app/application ./                                                                                            
 => exporting to image                                                                                                                              
 => => exporting layers                                                                                                                             
 => => exporting manifest sha256:cb3f19bc9b28486a6576dd01e8560550c9f9341971b525b0a378baa7334732e5                                                   
 => => exporting config sha256:375f85e39ad28992a73271a6170ae1ecfdb86f841e2852cdab3b9b68cdedfafe                                                     
 => => exporting attestation manifest sha256:12d1d2e11a2a087e134518c1edf016c31b736ccbe0068f33b02b592b38f4b071                                       
 => => exporting manifest list sha256:5b3c98ddaeb94291f7a9b5d7bda88420097a0c0c2aa1fb2445bb6ec3700b3dbb                                              
 => => naming to docker.io/library/course-service:latest                                                                                            
 => => unpacking to docker.io/library/course-service:latest                                                                                         
                                                                                                                                                    
View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/s1n4dqm8li3l10wy6gm3cqc9l                                          
````

Luego listamos las imÃ¡genes y vemos que el nuestro ya se encuentra en la lista.

````bash
$ docker image ls
REPOSITORY       TAG       IMAGE ID       CREATED          SIZE
course-service   latest    5b3c98ddaeb9   58 seconds ago   405MB
````

### En el user-service

Recordemos que nuestro `user-service` se comunica con el microservicio `course-service` usando el `RestClient`.

Como ahora trabajaremos con contenedores Docker ejecutados manualmente, necesitamos modificar la URL del microservicio
`course-service` para que la comunicaciÃ³n desde `user-service` funcione correctamente dentro de la red de `Docker`.

Esta modificaciÃ³n se realiza en el archivo `application.yml` del `user-service`:

````yml
custom:
  course-service:
    base-url: http://c-course-service:8002/api/v1/courses
````

Donde:

- `c-course-service` es el nombre del contenedor que le asignaremos al microservicio `course-service` al momento de
  ejecutarlo con la opciÃ³n `--name` en el comando `docker container run`.

Luego de realizar la modificaciÃ³n, construimos la imagen para el microservicio `user-service`.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\08.docker_kubernetes\docker-kubernetes (feature/section-9)                                         
$ docker image build -t user-service .\business-domain\user-service -f .\business-domain\user-service\Dockerfile                                   
[+] Building 19.4s (25/25) FINISHED                                                                                                                
 => [internal] load build definition from Dockerfile                                                                                               
 => => transferring dockerfile: 794B                                                                                                               
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jre-alpine                                                                   
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                                   
 => [auth] library/eclipse-temurin:pull token for registry-1.docker.io                                                                             
 => [internal] load .dockerignore                                                                                                                  
 => => transferring context: 214B                                                                                                                  
 => [builder 1/4] FROM docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd     
 => => resolve docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd             
 => [dependencies 1/9] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0
 => => resolve docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0             
 => [internal] load build context                                                                                                                  
 => => transferring context: 3.58kB                                                                                                                
 => CACHED [dependencies 2/9] WORKDIR /app                                                                                                         
 => CACHED [dependencies 3/9] COPY ./mvnw ./                                                                                                       
 => CACHED [dependencies 4/9] COPY ./.mvn ./.mvn                                                                                                   
 => CACHED [dependencies 5/9] COPY ./pom.xml ./                                                                                                    
 => CACHED [dependencies 6/9] RUN sed -i -e 's/\r$//' ./mvnw                                                                                       
 => CACHED [dependencies 7/9] RUN ./mvnw dependency:go-offline                                                                                     
 => [dependencies 8/9] COPY ./src ./src                                                                                                            
 => [dependencies 9/9] RUN ./mvnw clean package -DskipTests                                                                                        
 => CACHED [builder 2/4] WORKDIR /app                                                                                                              
 => [builder 3/4] COPY --from=dependencies /app/target/*.jar ./app.jar                                                                             
 => [builder 4/4] RUN java -Djarmode=layertools -jar app.jar extract                                                                               
 => CACHED [runner 3/7] RUN mkdir ./logs                                                                                                           
 => CACHED [runner 4/7] COPY --from=builder /app/dependencies ./                                                                                   
 => CACHED [runner 5/7] COPY --from=builder /app/spring-boot-loader ./                                                                             
 => CACHED [runner 6/7] COPY --from=builder /app/snapshot-dependencies ./                                                                          
 => [runner 7/7] COPY --from=builder /app/application ./                                                                                           
 => exporting to image                                                                                                                             
 => => exporting layers                                                                                                                            
 => => exporting manifest sha256:59200bc008340ce77f4a35b2ff6f063ef9595388c6637be889fa465cfd872b39                                                  
 => => exporting config sha256:00c9435f86d16eb95ff7c0fed865dafb43475c7c6aa999670a776f63a9572d4a                                                    
 => => exporting attestation manifest sha256:2ec9d86ea4fd37586e925abe71d9b5ebafc35df5c5ac06ab113ef668006e4443                                      
 => => exporting manifest list sha256:bb8dcd87e6b2d4ee6390a80a3978b4e78c4748b870b10ad21d237405e7258e82                                             
 => => naming to docker.io/library/user-service:latest                                                                                             
 => => unpacking to docker.io/library/user-service:latest                                                                                          
                                                                                                                                                   
View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/w72ang74tnibnb0u2ama73sjm                                         
````

Hasta este punto, si listamos las imÃ¡genes, veremos las dos que acabamos de construir `user-service` y `course-service`.

````bash
$ docker image ls
REPOSITORY       TAG       IMAGE ID       CREATED              SIZE
user-service     latest    bb8dcd87e6b2   About a minute ago   407MB
course-service   latest    5b3c98ddaeb9   6 minutes ago        405MB
````

## Configura la red o network

Listamos las redes para ver cuÃ¡les se encuentran creadas por defecto en Docker.

````bash
$ docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
a2b662e2a591   bridge    bridge    local
8c77b18a87f1   host      host      local
fe251eccddcc   none      null      local
````

DÃ³nde

- `bridge`: Red por defecto para contenedores; permite acceso a internet y comunicaciÃ³n entre contenedores conectados,
  pero `no resuelve nombres de contenedores automÃ¡ticamente`.
- `host`: El contenedor comparte la red del host, sin aislamiento de red; Ãºtil para aplicaciones que necesitan el mismo
  stack de red del sistema anfitriÃ³n.
- `none`: El contenedor no tiene acceso a ninguna red; se usa cuando necesitas un contenedor completamente aislado a
  nivel de red.

Ahora, para comunicar nuestros microservicios, crearemos una red personalizada llamada `docker-kubernetes-net`.

````bash
$ docker network create docker-kubernetes-net
6946c0fdc9f2f7d5b5f5a9d7a2dd8764b0768866af9565cba9c99659dd9c211d
````

Listamos nuevamente las redes. Vemos que la red `docker-kubernetes-net` estÃ¡ creada correctamente.

````bash
$ docker network ls
NETWORK ID     NAME                    DRIVER    SCOPE
a2b662e2a591   bridge                  bridge    local
6946c0fdc9f2   docker-kubernetes-net   bridge    local
8c77b18a87f1   host                    host      local
fe251eccddcc   none                    null      local
````

ðŸ’¡ Nota:
> Si no creas explÃ­citamente una red en `Docker`, los contenedores se ejecutan en una red por defecto llamada `bridge`.
> Esta red es la configuraciÃ³n estÃ¡ndar para contenedores que no se asocian a una red personalizada. Esta red permite
> acceso a internet, pero `no permite la resoluciÃ³n de nombres entre contenedores`.
>
> Por lo tanto, si deseamos que nuestros contenedores se comuniquen usando sus nombres
> (como `http://c-user-service:8001`), es recomendable usar una red personalizada. En nuestro caso, la red
> personalizada que creamos es `docker-kubernetes-net`.
>
> âœ… Ambas redes son tipo `bridge`, pero se comportan distinto por diseÃ±o.
>
> - La red por defecto llamado `bridge` no habilita un sistema de resoluciÃ³n de nombres entre contenedores. Es una red
    "mÃ­nima" pensada para contenedores simples o pruebas rÃ¡pidas. Los contenedores conectados a esta red no pueden
    resolverse por su nombre (`--name`), `solo se ven por IP`. Por eso, para que dos contenedores se comuniquen en esta
    red, tendrÃ­as que pasarles la IP del otro (lo cual es frÃ¡gil y no recomendable).
>
>
> - La red `bridge personalizada` (como `docker-kubernetes-net`), es creada por nosotros mismos con el comando
    `docker network create`. Docker configura automÃ¡ticamente `un DNS interno` para esta red. Este DNS
    `resuelve los nombres de los contenedores` en esa red. Los contenedores `sÃ­ pueden comunicarse usando sus nombres`
    (los que defines con `--name`), como si fuera un mini sistema de nombres interno.

## ComunicaciÃ³n entre contenedores

Creamos los contenedores de nuestros dos microservicios. Observar que estamos agregando la red creada anteriormente
`docker-kubernetes-net`. AdemÃ¡s, cada contenedor tiene como `--name` el `c-user-service` y `c-course-service`.
Estos nombres los estamos usando dentro de las configuraciones de nuestros microservicios para que puedan comunicarse
entre sÃ­.

Creamos el contenedor para el `user-service`.

````bash
$ docker container run -d -p 8001:8001 --rm --name c-user-service --network docker-kubernetes-net user-service
f0c5b9399714c7b56cc49326651165ab02b5f8f8d5b1345c18f17d4b07774c37
````

Creamos el contenedor para el `course-serivce`.

````bash
$ docker container run -d -p 8002:8002 --rm --name c-course-service --network docker-kubernetes-net course-service
f7fa93ac69de8d20e6c05a1a4363c36e782136759dbcf0d8b40df59b8c117a7d
````

Podemos inspeccionar la red `docker-kubernetes-net` para ver que los dos contenedores creados anteriormente ya estÃ¡n
asociados a Ã©l.

````bash
$ docker network inspect docker-kubernetes-net
[
    {
        "Name": "docker-kubernetes-net",
        "Id": "6946c0fdc9f2f7d5b5f5a9d7a2dd8764b0768866af9565cba9c99659dd9c211d",
        "Created": "2025-05-28T05:07:20.686757576Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv4": true,
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "f0c5b9399714c7b56cc49326651165ab02b5f8f8d5b1345c18f17d4b07774c37": {
                "Name": "c-user-service",
                "EndpointID": "638c6704eb9e2979cbf6a93731c1e9375479fb993fb868d5a5920f7e82a7fe0b",
                "MacAddress": "76:1c:8c:f6:4b:ea",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            },
            "f7fa93ac69de8d20e6c05a1a4363c36e782136759dbcf0d8b40df59b8c117a7d": {
                "Name": "c-course-service",
                "EndpointID": "7948cc25a598080182884149b2d05819392419f993d1fdde72b1e72985484d8a",
                "MacAddress": "26:4d:76:be:52:fd",
                "IPv4Address": "172.18.0.3/16",
                "IPv6Address": ""
            }
        },
        "Options": {
            "com.docker.network.enable_ipv4": "true",
            "com.docker.network.enable_ipv6": "false"
        },
        "Labels": {}
    }
]
````

DespuÃ©s de crear los contenedores, los podemos listar para ver que estÃ¡n levantados correctamente con status `Up`.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE            COMMAND                  CREATED              STATUS              PORTS                    NAMES
f7fa93ac69de   course-service   "/__cacert_entrypoinâ€¦"   About a minute ago   Up About a minute   0.0.0.0:8002->8002/tcp   c-course-service
f0c5b9399714   user-service     "/__cacert_entrypoinâ€¦"   2 minutes ago        Up 2 minutes        0.0.0.0:8001->8001/tcp   c-user-service
````

Probamos la comunicaciÃ³n entre nuestros dos contenedores simplemente haciendo una petiÃ³n http hacia el microservicio
de cursos. Este endpoint traerÃ¡ la informaciÃ³n de un curso y los usuarios asociados a dicho curso.

````bash
$ curl -v -G --data "loadRelations=true" http://localhost:8002/api/v1/courses/1 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 29 May 2025 04:24:31 GMT
<
{
  "id": 1,
  "name": "Spring Boot",
  "users": [
    {
      "id": 6,
      "name": "Lesly",
      "email": "lesly@gmail.com",
      "password": "123456"
    }
  ]
}
````
